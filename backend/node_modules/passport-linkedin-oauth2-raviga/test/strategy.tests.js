const should = require('should');
const nock = require('nock');
const crypto = require('crypto');
const Strategy = require('../lib/index').OAuth2Strategy;
const profileExample = require('./profile.json');

nock.disableNetConnect();

describe('LinkedIn Strategy', function () {
  const origin = 'https://api.linkedin.com';
  const profilePath = '/v2/userinfo?oauth2_access_token=whatever';

  it('sanity check', function (done) {
    const options = {
      clientID: 'clientId',
      clientSecret: 'clientSecret',
    };
    const st = new Strategy(options, function () {});

    st.name.should.eql('linkedin');
    const decodedProfilePath = decodeURIComponent(profilePath).replace(
      '?oauth2_access_token=whatever',
      ''
    );
    st.profileUrl.should.eql(`${origin}${decodedProfilePath}`);
    done();
  });

  describe('configuration', function() {
    it('should enable PKCE by default', function() {
      const options = {
        clientID: 'clientId',
        clientSecret: 'clientSecret',
      };
      const st = new Strategy(options, function () {});
      
      should(st.options.pkce).be.true();
      should(st.options.pkceVerifier).not.be.empty();
      should(st.options.pkceChallenge).not.be.empty();
      should(st.options.pkceChallengeMethod).eql('S256');
    });

    it('should allow disabling PKCE', function() {
      const options = {
        clientID: 'clientId',
        clientSecret: 'clientSecret',
        pkce: false
      };
      const st = new Strategy(options, function () {});
      
      should(st.options.pkce).be.false();
      should(st.options.pkceVerifier).be.undefined();
      should(st.options.pkceChallenge).be.undefined();
    });

    it('should enable state parameter by default', function() {
      const options = {
        clientID: 'clientId',
        clientSecret: 'clientSecret',
      };
      const st = new Strategy(options, function () {});
      
      should(st.options.state).be.true();
    });

    it('should set default scopes', function() {
      const options = {
        clientID: 'clientId',
        clientSecret: 'clientSecret',
      };
      const st = new Strategy(options, function () {});
      
      should(st.options.scope).eql(['profile', 'email', 'openid']);
    });
  });

  describe('authorization parameters', function() {
    it('should include state if provided', function() {
      const st = new Strategy({
        clientID: 'clientId',
        clientSecret: 'clientSecret',
      }, function() {});

      const params = st.authorizationParams({ state: 'test-state' });
      params.should.have.property('state', 'test-state');
    });

    it('should include access_type if provided', function() {
      const st = new Strategy({
        clientID: 'clientId',
        clientSecret: 'clientSecret',
      }, function() {});

      const params = st.authorizationParams({ accessType: 'offline' });
      params.should.have.property('access_type', 'offline');
    });

    it('should include prompt if provided', function() {
      const st = new Strategy({
        clientID: 'clientId',
        clientSecret: 'clientSecret',
      }, function() {});

      const params = st.authorizationParams({ prompt: 'select_account' });
      params.should.have.property('prompt', 'select_account');
    });

    it('should include login_hint if provided', function() {
      const st = new Strategy({
        clientID: 'clientId',
        clientSecret: 'clientSecret',
      }, function() {});

      const params = st.authorizationParams({ loginHint: 'test@example.com' });
      params.should.have.property('login_hint', 'test@example.com');
    });
  });

  describe('userProfile(accessToken, done)', function () {
    context('with profile and email scope', function () {
      beforeEach(function () {
        this.scope = nock(origin).get(profilePath).reply(200, profileExample);
      });

      afterEach(function () {
        this.scope.done();
      });

      it('passes id, firstname, lastname and profile picture fields to callback', function (done) {
        const options = {
          clientID: 'clientId',
          clientSecret: 'clientSecret',
          scope: ['profile', 'email', 'openid'],
        };

        const st = new Strategy(options, function () {});

        st.userProfile('whatever', function (err, profile) {
          should.not.exist(err);
          profile.id.should.eql('782bbtaQ');
          profile.givenName.should.eql('John');
          profile.familyName.should.eql('Doe');
          profile.displayName.should.eql('John Doe');
          profile.picture.should.eql(
            'https://media.licdn-ei.com/dms/image/C5F03AQHqK8v7tB1HCQ/profile-displayphoto-shrink_100_100/0/'
          );
          profile.email.should.eql('doe@email.com');
          done();
        });
      });
    });

    context('when LinkedIn API returns an error', function () {
      const apiError = {
        error: {
          message: 'Invalid access token',
          status: 401
        }
      };

      beforeEach(function () {
        this.scope = nock(origin)
          .get(profilePath)
          .reply(401, apiError);
      });

      afterEach(function () {
        this.scope.done();
      });

      it('should return LinkedInAPIError', function (done) {
        const st = new Strategy({
          clientID: 'clientId',
          clientSecret: 'clientSecret',
        }, function () {});

        st.userProfile('whatever', function (err, profile) {
          should.exist(err);
          err.should.be.instanceof(Strategy.LinkedInAPIError);
          err.message.should.eql('Invalid access token');
          err.code.should.eql(401);
          should.not.exist(profile);
          done();
        });
      });
    });

    context('when OAuth error occurs', function () {
      const oauthError = {
        error: 'invalid_token',
        error_description: 'Token has expired'
      };

      beforeEach(function () {
        this.scope = nock(origin)
          .get(profilePath)
          .reply(401, oauthError);
      });

      afterEach(function () {
        this.scope.done();
      });

      it('should return UserInfoError', function (done) {
        const st = new Strategy({
          clientID: 'clientId',
          clientSecret: 'clientSecret',
        }, function () {});

        st.userProfile('whatever', function (err, profile) {
          should.exist(err);
          err.should.be.instanceof(Strategy.UserInfoError);
          err.message.should.eql('Token has expired');
          err.type.should.eql('invalid_token');
          should.not.exist(profile);
          done();
        });
      });
    });

    context('when parsing error occurs', function () {
      beforeEach(function () {
        this.scope = nock(origin)
          .get(profilePath)
          .reply(200, 'invalid json');
      });

      afterEach(function () {
        this.scope.done();
      });

      it('should return error', function (done) {
        const st = new Strategy({
          clientID: 'clientId',
          clientSecret: 'clientSecret',
        }, function () {});

        st.userProfile('whatever', function (err, profile) {
          should.exist(err);
          err.message.should.eql('Failed to parse user profile');
          should.not.exist(profile);
          done();
        });
      });
    });
  });
});
