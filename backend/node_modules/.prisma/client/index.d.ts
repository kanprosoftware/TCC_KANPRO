
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model login
 * 
 */
export type login = $Result.DefaultSelection<Prisma.$loginPayload>
/**
 * Model usuario
 * 
 */
export type usuario = $Result.DefaultSelection<Prisma.$usuarioPayload>
/**
 * Model projeto
 * 
 */
export type projeto = $Result.DefaultSelection<Prisma.$projetoPayload>
/**
 * Model tecnologia
 * 
 */
export type tecnologia = $Result.DefaultSelection<Prisma.$tecnologiaPayload>
/**
 * Model tarefa
 * 
 */
export type tarefa = $Result.DefaultSelection<Prisma.$tarefaPayload>
/**
 * Model projetoUsuario
 * 
 */
export type projetoUsuario = $Result.DefaultSelection<Prisma.$projetoUsuarioPayload>
/**
 * Model projetoTecnologia
 * 
 */
export type projetoTecnologia = $Result.DefaultSelection<Prisma.$projetoTecnologiaPayload>
/**
 * Model habilidadeUsuario
 * 
 */
export type habilidadeUsuario = $Result.DefaultSelection<Prisma.$habilidadeUsuarioPayload>
/**
 * Model recurso
 * 
 */
export type recurso = $Result.DefaultSelection<Prisma.$recursoPayload>
/**
 * Model anexoProjeto
 * 
 */
export type anexoProjeto = $Result.DefaultSelection<Prisma.$anexoProjetoPayload>
/**
 * Model participacaoTarefa
 * 
 */
export type participacaoTarefa = $Result.DefaultSelection<Prisma.$participacaoTarefaPayload>
/**
 * Model comentario
 * 
 */
export type comentario = $Result.DefaultSelection<Prisma.$comentarioPayload>
/**
 * Model anexoTarefa
 * 
 */
export type anexoTarefa = $Result.DefaultSelection<Prisma.$anexoTarefaPayload>
/**
 * Model anexoComentario
 * 
 */
export type anexoComentario = $Result.DefaultSelection<Prisma.$anexoComentarioPayload>
/**
 * Model permissao
 * 
 */
export type permissao = $Result.DefaultSelection<Prisma.$permissaoPayload>
/**
 * Model permissaoProjeto
 * 
 */
export type permissaoProjeto = $Result.DefaultSelection<Prisma.$permissaoProjetoPayload>
/**
 * Model pausaTarefa
 * 
 */
export type pausaTarefa = $Result.DefaultSelection<Prisma.$pausaTarefaPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Logins
 * const logins = await prisma.login.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Logins
   * const logins = await prisma.login.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.login`: Exposes CRUD operations for the **login** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logins
    * const logins = await prisma.login.findMany()
    * ```
    */
  get login(): Prisma.loginDelegate<ExtArgs>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.usuarioDelegate<ExtArgs>;

  /**
   * `prisma.projeto`: Exposes CRUD operations for the **projeto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projetos
    * const projetos = await prisma.projeto.findMany()
    * ```
    */
  get projeto(): Prisma.projetoDelegate<ExtArgs>;

  /**
   * `prisma.tecnologia`: Exposes CRUD operations for the **tecnologia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tecnologias
    * const tecnologias = await prisma.tecnologia.findMany()
    * ```
    */
  get tecnologia(): Prisma.tecnologiaDelegate<ExtArgs>;

  /**
   * `prisma.tarefa`: Exposes CRUD operations for the **tarefa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tarefas
    * const tarefas = await prisma.tarefa.findMany()
    * ```
    */
  get tarefa(): Prisma.tarefaDelegate<ExtArgs>;

  /**
   * `prisma.projetoUsuario`: Exposes CRUD operations for the **projetoUsuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjetoUsuarios
    * const projetoUsuarios = await prisma.projetoUsuario.findMany()
    * ```
    */
  get projetoUsuario(): Prisma.projetoUsuarioDelegate<ExtArgs>;

  /**
   * `prisma.projetoTecnologia`: Exposes CRUD operations for the **projetoTecnologia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjetoTecnologias
    * const projetoTecnologias = await prisma.projetoTecnologia.findMany()
    * ```
    */
  get projetoTecnologia(): Prisma.projetoTecnologiaDelegate<ExtArgs>;

  /**
   * `prisma.habilidadeUsuario`: Exposes CRUD operations for the **habilidadeUsuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HabilidadeUsuarios
    * const habilidadeUsuarios = await prisma.habilidadeUsuario.findMany()
    * ```
    */
  get habilidadeUsuario(): Prisma.habilidadeUsuarioDelegate<ExtArgs>;

  /**
   * `prisma.recurso`: Exposes CRUD operations for the **recurso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recursos
    * const recursos = await prisma.recurso.findMany()
    * ```
    */
  get recurso(): Prisma.recursoDelegate<ExtArgs>;

  /**
   * `prisma.anexoProjeto`: Exposes CRUD operations for the **anexoProjeto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnexoProjetos
    * const anexoProjetos = await prisma.anexoProjeto.findMany()
    * ```
    */
  get anexoProjeto(): Prisma.anexoProjetoDelegate<ExtArgs>;

  /**
   * `prisma.participacaoTarefa`: Exposes CRUD operations for the **participacaoTarefa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParticipacaoTarefas
    * const participacaoTarefas = await prisma.participacaoTarefa.findMany()
    * ```
    */
  get participacaoTarefa(): Prisma.participacaoTarefaDelegate<ExtArgs>;

  /**
   * `prisma.comentario`: Exposes CRUD operations for the **comentario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comentarios
    * const comentarios = await prisma.comentario.findMany()
    * ```
    */
  get comentario(): Prisma.comentarioDelegate<ExtArgs>;

  /**
   * `prisma.anexoTarefa`: Exposes CRUD operations for the **anexoTarefa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnexoTarefas
    * const anexoTarefas = await prisma.anexoTarefa.findMany()
    * ```
    */
  get anexoTarefa(): Prisma.anexoTarefaDelegate<ExtArgs>;

  /**
   * `prisma.anexoComentario`: Exposes CRUD operations for the **anexoComentario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnexoComentarios
    * const anexoComentarios = await prisma.anexoComentario.findMany()
    * ```
    */
  get anexoComentario(): Prisma.anexoComentarioDelegate<ExtArgs>;

  /**
   * `prisma.permissao`: Exposes CRUD operations for the **permissao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissaos
    * const permissaos = await prisma.permissao.findMany()
    * ```
    */
  get permissao(): Prisma.permissaoDelegate<ExtArgs>;

  /**
   * `prisma.permissaoProjeto`: Exposes CRUD operations for the **permissaoProjeto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PermissaoProjetos
    * const permissaoProjetos = await prisma.permissaoProjeto.findMany()
    * ```
    */
  get permissaoProjeto(): Prisma.permissaoProjetoDelegate<ExtArgs>;

  /**
   * `prisma.pausaTarefa`: Exposes CRUD operations for the **pausaTarefa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PausaTarefas
    * const pausaTarefas = await prisma.pausaTarefa.findMany()
    * ```
    */
  get pausaTarefa(): Prisma.pausaTarefaDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    login: 'login',
    usuario: 'usuario',
    projeto: 'projeto',
    tecnologia: 'tecnologia',
    tarefa: 'tarefa',
    projetoUsuario: 'projetoUsuario',
    projetoTecnologia: 'projetoTecnologia',
    habilidadeUsuario: 'habilidadeUsuario',
    recurso: 'recurso',
    anexoProjeto: 'anexoProjeto',
    participacaoTarefa: 'participacaoTarefa',
    comentario: 'comentario',
    anexoTarefa: 'anexoTarefa',
    anexoComentario: 'anexoComentario',
    permissao: 'permissao',
    permissaoProjeto: 'permissaoProjeto',
    pausaTarefa: 'pausaTarefa'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "login" | "usuario" | "projeto" | "tecnologia" | "tarefa" | "projetoUsuario" | "projetoTecnologia" | "habilidadeUsuario" | "recurso" | "anexoProjeto" | "participacaoTarefa" | "comentario" | "anexoTarefa" | "anexoComentario" | "permissao" | "permissaoProjeto" | "pausaTarefa"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      login: {
        payload: Prisma.$loginPayload<ExtArgs>
        fields: Prisma.loginFieldRefs
        operations: {
          findUnique: {
            args: Prisma.loginFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loginPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.loginFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loginPayload>
          }
          findFirst: {
            args: Prisma.loginFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loginPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.loginFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loginPayload>
          }
          findMany: {
            args: Prisma.loginFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loginPayload>[]
          }
          create: {
            args: Prisma.loginCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loginPayload>
          }
          createMany: {
            args: Prisma.loginCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.loginCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loginPayload>[]
          }
          delete: {
            args: Prisma.loginDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loginPayload>
          }
          update: {
            args: Prisma.loginUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loginPayload>
          }
          deleteMany: {
            args: Prisma.loginDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.loginUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.loginUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$loginPayload>
          }
          aggregate: {
            args: Prisma.LoginAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogin>
          }
          groupBy: {
            args: Prisma.loginGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoginGroupByOutputType>[]
          }
          count: {
            args: Prisma.loginCountArgs<ExtArgs>
            result: $Utils.Optional<LoginCountAggregateOutputType> | number
          }
        }
      }
      usuario: {
        payload: Prisma.$usuarioPayload<ExtArgs>
        fields: Prisma.usuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          findFirst: {
            args: Prisma.usuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          findMany: {
            args: Prisma.usuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>[]
          }
          create: {
            args: Prisma.usuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          createMany: {
            args: Prisma.usuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>[]
          }
          delete: {
            args: Prisma.usuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          update: {
            args: Prisma.usuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          deleteMany: {
            args: Prisma.usuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.usuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.usuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      projeto: {
        payload: Prisma.$projetoPayload<ExtArgs>
        fields: Prisma.projetoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.projetoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.projetoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>
          }
          findFirst: {
            args: Prisma.projetoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.projetoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>
          }
          findMany: {
            args: Prisma.projetoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>[]
          }
          create: {
            args: Prisma.projetoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>
          }
          createMany: {
            args: Prisma.projetoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.projetoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>[]
          }
          delete: {
            args: Prisma.projetoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>
          }
          update: {
            args: Prisma.projetoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>
          }
          deleteMany: {
            args: Prisma.projetoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.projetoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.projetoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>
          }
          aggregate: {
            args: Prisma.ProjetoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjeto>
          }
          groupBy: {
            args: Prisma.projetoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjetoGroupByOutputType>[]
          }
          count: {
            args: Prisma.projetoCountArgs<ExtArgs>
            result: $Utils.Optional<ProjetoCountAggregateOutputType> | number
          }
        }
      }
      tecnologia: {
        payload: Prisma.$tecnologiaPayload<ExtArgs>
        fields: Prisma.tecnologiaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tecnologiaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tecnologiaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tecnologiaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tecnologiaPayload>
          }
          findFirst: {
            args: Prisma.tecnologiaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tecnologiaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tecnologiaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tecnologiaPayload>
          }
          findMany: {
            args: Prisma.tecnologiaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tecnologiaPayload>[]
          }
          create: {
            args: Prisma.tecnologiaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tecnologiaPayload>
          }
          createMany: {
            args: Prisma.tecnologiaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tecnologiaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tecnologiaPayload>[]
          }
          delete: {
            args: Prisma.tecnologiaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tecnologiaPayload>
          }
          update: {
            args: Prisma.tecnologiaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tecnologiaPayload>
          }
          deleteMany: {
            args: Prisma.tecnologiaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tecnologiaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tecnologiaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tecnologiaPayload>
          }
          aggregate: {
            args: Prisma.TecnologiaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTecnologia>
          }
          groupBy: {
            args: Prisma.tecnologiaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TecnologiaGroupByOutputType>[]
          }
          count: {
            args: Prisma.tecnologiaCountArgs<ExtArgs>
            result: $Utils.Optional<TecnologiaCountAggregateOutputType> | number
          }
        }
      }
      tarefa: {
        payload: Prisma.$tarefaPayload<ExtArgs>
        fields: Prisma.tarefaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tarefaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tarefaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>
          }
          findFirst: {
            args: Prisma.tarefaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tarefaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>
          }
          findMany: {
            args: Prisma.tarefaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>[]
          }
          create: {
            args: Prisma.tarefaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>
          }
          createMany: {
            args: Prisma.tarefaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tarefaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>[]
          }
          delete: {
            args: Prisma.tarefaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>
          }
          update: {
            args: Prisma.tarefaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>
          }
          deleteMany: {
            args: Prisma.tarefaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tarefaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tarefaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>
          }
          aggregate: {
            args: Prisma.TarefaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTarefa>
          }
          groupBy: {
            args: Prisma.tarefaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TarefaGroupByOutputType>[]
          }
          count: {
            args: Prisma.tarefaCountArgs<ExtArgs>
            result: $Utils.Optional<TarefaCountAggregateOutputType> | number
          }
        }
      }
      projetoUsuario: {
        payload: Prisma.$projetoUsuarioPayload<ExtArgs>
        fields: Prisma.projetoUsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.projetoUsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoUsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.projetoUsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoUsuarioPayload>
          }
          findFirst: {
            args: Prisma.projetoUsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoUsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.projetoUsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoUsuarioPayload>
          }
          findMany: {
            args: Prisma.projetoUsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoUsuarioPayload>[]
          }
          create: {
            args: Prisma.projetoUsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoUsuarioPayload>
          }
          createMany: {
            args: Prisma.projetoUsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.projetoUsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoUsuarioPayload>[]
          }
          delete: {
            args: Prisma.projetoUsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoUsuarioPayload>
          }
          update: {
            args: Prisma.projetoUsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoUsuarioPayload>
          }
          deleteMany: {
            args: Prisma.projetoUsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.projetoUsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.projetoUsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoUsuarioPayload>
          }
          aggregate: {
            args: Prisma.ProjetoUsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjetoUsuario>
          }
          groupBy: {
            args: Prisma.projetoUsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjetoUsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.projetoUsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<ProjetoUsuarioCountAggregateOutputType> | number
          }
        }
      }
      projetoTecnologia: {
        payload: Prisma.$projetoTecnologiaPayload<ExtArgs>
        fields: Prisma.projetoTecnologiaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.projetoTecnologiaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoTecnologiaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.projetoTecnologiaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoTecnologiaPayload>
          }
          findFirst: {
            args: Prisma.projetoTecnologiaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoTecnologiaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.projetoTecnologiaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoTecnologiaPayload>
          }
          findMany: {
            args: Prisma.projetoTecnologiaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoTecnologiaPayload>[]
          }
          create: {
            args: Prisma.projetoTecnologiaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoTecnologiaPayload>
          }
          createMany: {
            args: Prisma.projetoTecnologiaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.projetoTecnologiaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoTecnologiaPayload>[]
          }
          delete: {
            args: Prisma.projetoTecnologiaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoTecnologiaPayload>
          }
          update: {
            args: Prisma.projetoTecnologiaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoTecnologiaPayload>
          }
          deleteMany: {
            args: Prisma.projetoTecnologiaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.projetoTecnologiaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.projetoTecnologiaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoTecnologiaPayload>
          }
          aggregate: {
            args: Prisma.ProjetoTecnologiaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjetoTecnologia>
          }
          groupBy: {
            args: Prisma.projetoTecnologiaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjetoTecnologiaGroupByOutputType>[]
          }
          count: {
            args: Prisma.projetoTecnologiaCountArgs<ExtArgs>
            result: $Utils.Optional<ProjetoTecnologiaCountAggregateOutputType> | number
          }
        }
      }
      habilidadeUsuario: {
        payload: Prisma.$habilidadeUsuarioPayload<ExtArgs>
        fields: Prisma.habilidadeUsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.habilidadeUsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habilidadeUsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.habilidadeUsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habilidadeUsuarioPayload>
          }
          findFirst: {
            args: Prisma.habilidadeUsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habilidadeUsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.habilidadeUsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habilidadeUsuarioPayload>
          }
          findMany: {
            args: Prisma.habilidadeUsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habilidadeUsuarioPayload>[]
          }
          create: {
            args: Prisma.habilidadeUsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habilidadeUsuarioPayload>
          }
          createMany: {
            args: Prisma.habilidadeUsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.habilidadeUsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habilidadeUsuarioPayload>[]
          }
          delete: {
            args: Prisma.habilidadeUsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habilidadeUsuarioPayload>
          }
          update: {
            args: Prisma.habilidadeUsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habilidadeUsuarioPayload>
          }
          deleteMany: {
            args: Prisma.habilidadeUsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.habilidadeUsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.habilidadeUsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$habilidadeUsuarioPayload>
          }
          aggregate: {
            args: Prisma.HabilidadeUsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHabilidadeUsuario>
          }
          groupBy: {
            args: Prisma.habilidadeUsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<HabilidadeUsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.habilidadeUsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<HabilidadeUsuarioCountAggregateOutputType> | number
          }
        }
      }
      recurso: {
        payload: Prisma.$recursoPayload<ExtArgs>
        fields: Prisma.recursoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.recursoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recursoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.recursoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recursoPayload>
          }
          findFirst: {
            args: Prisma.recursoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recursoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.recursoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recursoPayload>
          }
          findMany: {
            args: Prisma.recursoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recursoPayload>[]
          }
          create: {
            args: Prisma.recursoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recursoPayload>
          }
          createMany: {
            args: Prisma.recursoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.recursoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recursoPayload>[]
          }
          delete: {
            args: Prisma.recursoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recursoPayload>
          }
          update: {
            args: Prisma.recursoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recursoPayload>
          }
          deleteMany: {
            args: Prisma.recursoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.recursoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.recursoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recursoPayload>
          }
          aggregate: {
            args: Prisma.RecursoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecurso>
          }
          groupBy: {
            args: Prisma.recursoGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecursoGroupByOutputType>[]
          }
          count: {
            args: Prisma.recursoCountArgs<ExtArgs>
            result: $Utils.Optional<RecursoCountAggregateOutputType> | number
          }
        }
      }
      anexoProjeto: {
        payload: Prisma.$anexoProjetoPayload<ExtArgs>
        fields: Prisma.anexoProjetoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.anexoProjetoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoProjetoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.anexoProjetoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoProjetoPayload>
          }
          findFirst: {
            args: Prisma.anexoProjetoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoProjetoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.anexoProjetoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoProjetoPayload>
          }
          findMany: {
            args: Prisma.anexoProjetoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoProjetoPayload>[]
          }
          create: {
            args: Prisma.anexoProjetoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoProjetoPayload>
          }
          createMany: {
            args: Prisma.anexoProjetoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.anexoProjetoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoProjetoPayload>[]
          }
          delete: {
            args: Prisma.anexoProjetoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoProjetoPayload>
          }
          update: {
            args: Prisma.anexoProjetoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoProjetoPayload>
          }
          deleteMany: {
            args: Prisma.anexoProjetoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.anexoProjetoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.anexoProjetoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoProjetoPayload>
          }
          aggregate: {
            args: Prisma.AnexoProjetoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnexoProjeto>
          }
          groupBy: {
            args: Prisma.anexoProjetoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnexoProjetoGroupByOutputType>[]
          }
          count: {
            args: Prisma.anexoProjetoCountArgs<ExtArgs>
            result: $Utils.Optional<AnexoProjetoCountAggregateOutputType> | number
          }
        }
      }
      participacaoTarefa: {
        payload: Prisma.$participacaoTarefaPayload<ExtArgs>
        fields: Prisma.participacaoTarefaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.participacaoTarefaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$participacaoTarefaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.participacaoTarefaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$participacaoTarefaPayload>
          }
          findFirst: {
            args: Prisma.participacaoTarefaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$participacaoTarefaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.participacaoTarefaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$participacaoTarefaPayload>
          }
          findMany: {
            args: Prisma.participacaoTarefaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$participacaoTarefaPayload>[]
          }
          create: {
            args: Prisma.participacaoTarefaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$participacaoTarefaPayload>
          }
          createMany: {
            args: Prisma.participacaoTarefaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.participacaoTarefaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$participacaoTarefaPayload>[]
          }
          delete: {
            args: Prisma.participacaoTarefaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$participacaoTarefaPayload>
          }
          update: {
            args: Prisma.participacaoTarefaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$participacaoTarefaPayload>
          }
          deleteMany: {
            args: Prisma.participacaoTarefaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.participacaoTarefaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.participacaoTarefaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$participacaoTarefaPayload>
          }
          aggregate: {
            args: Prisma.ParticipacaoTarefaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParticipacaoTarefa>
          }
          groupBy: {
            args: Prisma.participacaoTarefaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParticipacaoTarefaGroupByOutputType>[]
          }
          count: {
            args: Prisma.participacaoTarefaCountArgs<ExtArgs>
            result: $Utils.Optional<ParticipacaoTarefaCountAggregateOutputType> | number
          }
        }
      }
      comentario: {
        payload: Prisma.$comentarioPayload<ExtArgs>
        fields: Prisma.comentarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.comentarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.comentarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentarioPayload>
          }
          findFirst: {
            args: Prisma.comentarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.comentarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentarioPayload>
          }
          findMany: {
            args: Prisma.comentarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentarioPayload>[]
          }
          create: {
            args: Prisma.comentarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentarioPayload>
          }
          createMany: {
            args: Prisma.comentarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.comentarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentarioPayload>[]
          }
          delete: {
            args: Prisma.comentarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentarioPayload>
          }
          update: {
            args: Prisma.comentarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentarioPayload>
          }
          deleteMany: {
            args: Prisma.comentarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.comentarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.comentarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentarioPayload>
          }
          aggregate: {
            args: Prisma.ComentarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComentario>
          }
          groupBy: {
            args: Prisma.comentarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComentarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.comentarioCountArgs<ExtArgs>
            result: $Utils.Optional<ComentarioCountAggregateOutputType> | number
          }
        }
      }
      anexoTarefa: {
        payload: Prisma.$anexoTarefaPayload<ExtArgs>
        fields: Prisma.anexoTarefaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.anexoTarefaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoTarefaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.anexoTarefaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoTarefaPayload>
          }
          findFirst: {
            args: Prisma.anexoTarefaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoTarefaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.anexoTarefaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoTarefaPayload>
          }
          findMany: {
            args: Prisma.anexoTarefaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoTarefaPayload>[]
          }
          create: {
            args: Prisma.anexoTarefaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoTarefaPayload>
          }
          createMany: {
            args: Prisma.anexoTarefaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.anexoTarefaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoTarefaPayload>[]
          }
          delete: {
            args: Prisma.anexoTarefaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoTarefaPayload>
          }
          update: {
            args: Prisma.anexoTarefaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoTarefaPayload>
          }
          deleteMany: {
            args: Prisma.anexoTarefaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.anexoTarefaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.anexoTarefaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoTarefaPayload>
          }
          aggregate: {
            args: Prisma.AnexoTarefaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnexoTarefa>
          }
          groupBy: {
            args: Prisma.anexoTarefaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnexoTarefaGroupByOutputType>[]
          }
          count: {
            args: Prisma.anexoTarefaCountArgs<ExtArgs>
            result: $Utils.Optional<AnexoTarefaCountAggregateOutputType> | number
          }
        }
      }
      anexoComentario: {
        payload: Prisma.$anexoComentarioPayload<ExtArgs>
        fields: Prisma.anexoComentarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.anexoComentarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoComentarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.anexoComentarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoComentarioPayload>
          }
          findFirst: {
            args: Prisma.anexoComentarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoComentarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.anexoComentarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoComentarioPayload>
          }
          findMany: {
            args: Prisma.anexoComentarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoComentarioPayload>[]
          }
          create: {
            args: Prisma.anexoComentarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoComentarioPayload>
          }
          createMany: {
            args: Prisma.anexoComentarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.anexoComentarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoComentarioPayload>[]
          }
          delete: {
            args: Prisma.anexoComentarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoComentarioPayload>
          }
          update: {
            args: Prisma.anexoComentarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoComentarioPayload>
          }
          deleteMany: {
            args: Prisma.anexoComentarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.anexoComentarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.anexoComentarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$anexoComentarioPayload>
          }
          aggregate: {
            args: Prisma.AnexoComentarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnexoComentario>
          }
          groupBy: {
            args: Prisma.anexoComentarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnexoComentarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.anexoComentarioCountArgs<ExtArgs>
            result: $Utils.Optional<AnexoComentarioCountAggregateOutputType> | number
          }
        }
      }
      permissao: {
        payload: Prisma.$permissaoPayload<ExtArgs>
        fields: Prisma.permissaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.permissaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.permissaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissaoPayload>
          }
          findFirst: {
            args: Prisma.permissaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.permissaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissaoPayload>
          }
          findMany: {
            args: Prisma.permissaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissaoPayload>[]
          }
          create: {
            args: Prisma.permissaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissaoPayload>
          }
          createMany: {
            args: Prisma.permissaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.permissaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissaoPayload>[]
          }
          delete: {
            args: Prisma.permissaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissaoPayload>
          }
          update: {
            args: Prisma.permissaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissaoPayload>
          }
          deleteMany: {
            args: Prisma.permissaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.permissaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.permissaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissaoPayload>
          }
          aggregate: {
            args: Prisma.PermissaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermissao>
          }
          groupBy: {
            args: Prisma.permissaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.permissaoCountArgs<ExtArgs>
            result: $Utils.Optional<PermissaoCountAggregateOutputType> | number
          }
        }
      }
      permissaoProjeto: {
        payload: Prisma.$permissaoProjetoPayload<ExtArgs>
        fields: Prisma.permissaoProjetoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.permissaoProjetoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissaoProjetoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.permissaoProjetoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissaoProjetoPayload>
          }
          findFirst: {
            args: Prisma.permissaoProjetoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissaoProjetoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.permissaoProjetoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissaoProjetoPayload>
          }
          findMany: {
            args: Prisma.permissaoProjetoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissaoProjetoPayload>[]
          }
          create: {
            args: Prisma.permissaoProjetoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissaoProjetoPayload>
          }
          createMany: {
            args: Prisma.permissaoProjetoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.permissaoProjetoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissaoProjetoPayload>[]
          }
          delete: {
            args: Prisma.permissaoProjetoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissaoProjetoPayload>
          }
          update: {
            args: Prisma.permissaoProjetoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissaoProjetoPayload>
          }
          deleteMany: {
            args: Prisma.permissaoProjetoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.permissaoProjetoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.permissaoProjetoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissaoProjetoPayload>
          }
          aggregate: {
            args: Prisma.PermissaoProjetoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermissaoProjeto>
          }
          groupBy: {
            args: Prisma.permissaoProjetoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissaoProjetoGroupByOutputType>[]
          }
          count: {
            args: Prisma.permissaoProjetoCountArgs<ExtArgs>
            result: $Utils.Optional<PermissaoProjetoCountAggregateOutputType> | number
          }
        }
      }
      pausaTarefa: {
        payload: Prisma.$pausaTarefaPayload<ExtArgs>
        fields: Prisma.pausaTarefaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pausaTarefaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pausaTarefaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pausaTarefaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pausaTarefaPayload>
          }
          findFirst: {
            args: Prisma.pausaTarefaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pausaTarefaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pausaTarefaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pausaTarefaPayload>
          }
          findMany: {
            args: Prisma.pausaTarefaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pausaTarefaPayload>[]
          }
          create: {
            args: Prisma.pausaTarefaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pausaTarefaPayload>
          }
          createMany: {
            args: Prisma.pausaTarefaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pausaTarefaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pausaTarefaPayload>[]
          }
          delete: {
            args: Prisma.pausaTarefaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pausaTarefaPayload>
          }
          update: {
            args: Prisma.pausaTarefaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pausaTarefaPayload>
          }
          deleteMany: {
            args: Prisma.pausaTarefaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pausaTarefaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.pausaTarefaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pausaTarefaPayload>
          }
          aggregate: {
            args: Prisma.PausaTarefaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePausaTarefa>
          }
          groupBy: {
            args: Prisma.pausaTarefaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PausaTarefaGroupByOutputType>[]
          }
          count: {
            args: Prisma.pausaTarefaCountArgs<ExtArgs>
            result: $Utils.Optional<PausaTarefaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    projetoUsuarios: number
    habilidades: number
    permissoes: number
    permissoesProjeto: number
    participacoes: number
    comentarios: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projetoUsuarios?: boolean | UsuarioCountOutputTypeCountProjetoUsuariosArgs
    habilidades?: boolean | UsuarioCountOutputTypeCountHabilidadesArgs
    permissoes?: boolean | UsuarioCountOutputTypeCountPermissoesArgs
    permissoesProjeto?: boolean | UsuarioCountOutputTypeCountPermissoesProjetoArgs
    participacoes?: boolean | UsuarioCountOutputTypeCountParticipacoesArgs
    comentarios?: boolean | UsuarioCountOutputTypeCountComentariosArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountProjetoUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projetoUsuarioWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountHabilidadesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: habilidadeUsuarioWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountPermissoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permissaoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountPermissoesProjetoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permissaoProjetoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountParticipacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: participacaoTarefaWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountComentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comentarioWhereInput
  }


  /**
   * Count Type ProjetoCountOutputType
   */

  export type ProjetoCountOutputType = {
    projetoUsuarios: number
    tecnologias: number
    recursos: number
    anexos: number
    permissoes: number
  }

  export type ProjetoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projetoUsuarios?: boolean | ProjetoCountOutputTypeCountProjetoUsuariosArgs
    tecnologias?: boolean | ProjetoCountOutputTypeCountTecnologiasArgs
    recursos?: boolean | ProjetoCountOutputTypeCountRecursosArgs
    anexos?: boolean | ProjetoCountOutputTypeCountAnexosArgs
    permissoes?: boolean | ProjetoCountOutputTypeCountPermissoesArgs
  }

  // Custom InputTypes
  /**
   * ProjetoCountOutputType without action
   */
  export type ProjetoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjetoCountOutputType
     */
    select?: ProjetoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjetoCountOutputType without action
   */
  export type ProjetoCountOutputTypeCountProjetoUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projetoUsuarioWhereInput
  }

  /**
   * ProjetoCountOutputType without action
   */
  export type ProjetoCountOutputTypeCountTecnologiasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projetoTecnologiaWhereInput
  }

  /**
   * ProjetoCountOutputType without action
   */
  export type ProjetoCountOutputTypeCountRecursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recursoWhereInput
  }

  /**
   * ProjetoCountOutputType without action
   */
  export type ProjetoCountOutputTypeCountAnexosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: anexoProjetoWhereInput
  }

  /**
   * ProjetoCountOutputType without action
   */
  export type ProjetoCountOutputTypeCountPermissoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permissaoProjetoWhereInput
  }


  /**
   * Count Type TecnologiaCountOutputType
   */

  export type TecnologiaCountOutputType = {
    habilidades: number
    projetos: number
  }

  export type TecnologiaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    habilidades?: boolean | TecnologiaCountOutputTypeCountHabilidadesArgs
    projetos?: boolean | TecnologiaCountOutputTypeCountProjetosArgs
  }

  // Custom InputTypes
  /**
   * TecnologiaCountOutputType without action
   */
  export type TecnologiaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TecnologiaCountOutputType
     */
    select?: TecnologiaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TecnologiaCountOutputType without action
   */
  export type TecnologiaCountOutputTypeCountHabilidadesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: habilidadeUsuarioWhereInput
  }

  /**
   * TecnologiaCountOutputType without action
   */
  export type TecnologiaCountOutputTypeCountProjetosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projetoTecnologiaWhereInput
  }


  /**
   * Count Type TarefaCountOutputType
   */

  export type TarefaCountOutputType = {
    participacoes: number
    anexos: number
    pausas: number
  }

  export type TarefaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participacoes?: boolean | TarefaCountOutputTypeCountParticipacoesArgs
    anexos?: boolean | TarefaCountOutputTypeCountAnexosArgs
    pausas?: boolean | TarefaCountOutputTypeCountPausasArgs
  }

  // Custom InputTypes
  /**
   * TarefaCountOutputType without action
   */
  export type TarefaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TarefaCountOutputType
     */
    select?: TarefaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TarefaCountOutputType without action
   */
  export type TarefaCountOutputTypeCountParticipacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: participacaoTarefaWhereInput
  }

  /**
   * TarefaCountOutputType without action
   */
  export type TarefaCountOutputTypeCountAnexosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: anexoTarefaWhereInput
  }

  /**
   * TarefaCountOutputType without action
   */
  export type TarefaCountOutputTypeCountPausasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pausaTarefaWhereInput
  }


  /**
   * Count Type ProjetoUsuarioCountOutputType
   */

  export type ProjetoUsuarioCountOutputType = {
    participacoes: number
  }

  export type ProjetoUsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participacoes?: boolean | ProjetoUsuarioCountOutputTypeCountParticipacoesArgs
  }

  // Custom InputTypes
  /**
   * ProjetoUsuarioCountOutputType without action
   */
  export type ProjetoUsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjetoUsuarioCountOutputType
     */
    select?: ProjetoUsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjetoUsuarioCountOutputType without action
   */
  export type ProjetoUsuarioCountOutputTypeCountParticipacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: participacaoTarefaWhereInput
  }


  /**
   * Count Type ParticipacaoTarefaCountOutputType
   */

  export type ParticipacaoTarefaCountOutputType = {
    comentarios: number
    usuarios: number
  }

  export type ParticipacaoTarefaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comentarios?: boolean | ParticipacaoTarefaCountOutputTypeCountComentariosArgs
    usuarios?: boolean | ParticipacaoTarefaCountOutputTypeCountUsuariosArgs
  }

  // Custom InputTypes
  /**
   * ParticipacaoTarefaCountOutputType without action
   */
  export type ParticipacaoTarefaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipacaoTarefaCountOutputType
     */
    select?: ParticipacaoTarefaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParticipacaoTarefaCountOutputType without action
   */
  export type ParticipacaoTarefaCountOutputTypeCountComentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comentarioWhereInput
  }

  /**
   * ParticipacaoTarefaCountOutputType without action
   */
  export type ParticipacaoTarefaCountOutputTypeCountUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuarioWhereInput
  }


  /**
   * Count Type ComentarioCountOutputType
   */

  export type ComentarioCountOutputType = {
    anexos: number
  }

  export type ComentarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anexos?: boolean | ComentarioCountOutputTypeCountAnexosArgs
  }

  // Custom InputTypes
  /**
   * ComentarioCountOutputType without action
   */
  export type ComentarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComentarioCountOutputType
     */
    select?: ComentarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComentarioCountOutputType without action
   */
  export type ComentarioCountOutputTypeCountAnexosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: anexoComentarioWhereInput
  }


  /**
   * Count Type AnexoTarefaCountOutputType
   */

  export type AnexoTarefaCountOutputType = {
    anexosComentario: number
  }

  export type AnexoTarefaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anexosComentario?: boolean | AnexoTarefaCountOutputTypeCountAnexosComentarioArgs
  }

  // Custom InputTypes
  /**
   * AnexoTarefaCountOutputType without action
   */
  export type AnexoTarefaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnexoTarefaCountOutputType
     */
    select?: AnexoTarefaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AnexoTarefaCountOutputType without action
   */
  export type AnexoTarefaCountOutputTypeCountAnexosComentarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: anexoComentarioWhereInput
  }


  /**
   * Models
   */

  /**
   * Model login
   */

  export type AggregateLogin = {
    _count: LoginCountAggregateOutputType | null
    _avg: LoginAvgAggregateOutputType | null
    _sum: LoginSumAggregateOutputType | null
    _min: LoginMinAggregateOutputType | null
    _max: LoginMaxAggregateOutputType | null
  }

  export type LoginAvgAggregateOutputType = {
    login_id: number | null
  }

  export type LoginSumAggregateOutputType = {
    login_id: number | null
  }

  export type LoginMinAggregateOutputType = {
    login_id: number | null
    email: string | null
    password: string | null
    is_verified: boolean | null
    provider: string | null
    provider_id: string | null
    profile_image: string | null
    ativo: boolean | null
  }

  export type LoginMaxAggregateOutputType = {
    login_id: number | null
    email: string | null
    password: string | null
    is_verified: boolean | null
    provider: string | null
    provider_id: string | null
    profile_image: string | null
    ativo: boolean | null
  }

  export type LoginCountAggregateOutputType = {
    login_id: number
    email: number
    password: number
    is_verified: number
    provider: number
    provider_id: number
    profile_image: number
    ativo: number
    _all: number
  }


  export type LoginAvgAggregateInputType = {
    login_id?: true
  }

  export type LoginSumAggregateInputType = {
    login_id?: true
  }

  export type LoginMinAggregateInputType = {
    login_id?: true
    email?: true
    password?: true
    is_verified?: true
    provider?: true
    provider_id?: true
    profile_image?: true
    ativo?: true
  }

  export type LoginMaxAggregateInputType = {
    login_id?: true
    email?: true
    password?: true
    is_verified?: true
    provider?: true
    provider_id?: true
    profile_image?: true
    ativo?: true
  }

  export type LoginCountAggregateInputType = {
    login_id?: true
    email?: true
    password?: true
    is_verified?: true
    provider?: true
    provider_id?: true
    profile_image?: true
    ativo?: true
    _all?: true
  }

  export type LoginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which login to aggregate.
     */
    where?: loginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logins to fetch.
     */
    orderBy?: loginOrderByWithRelationInput | loginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: loginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned logins
    **/
    _count?: true | LoginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoginAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoginSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoginMaxAggregateInputType
  }

  export type GetLoginAggregateType<T extends LoginAggregateArgs> = {
        [P in keyof T & keyof AggregateLogin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogin[P]>
      : GetScalarType<T[P], AggregateLogin[P]>
  }




  export type loginGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: loginWhereInput
    orderBy?: loginOrderByWithAggregationInput | loginOrderByWithAggregationInput[]
    by: LoginScalarFieldEnum[] | LoginScalarFieldEnum
    having?: loginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoginCountAggregateInputType | true
    _avg?: LoginAvgAggregateInputType
    _sum?: LoginSumAggregateInputType
    _min?: LoginMinAggregateInputType
    _max?: LoginMaxAggregateInputType
  }

  export type LoginGroupByOutputType = {
    login_id: number
    email: string
    password: string | null
    is_verified: boolean
    provider: string
    provider_id: string | null
    profile_image: string | null
    ativo: boolean
    _count: LoginCountAggregateOutputType | null
    _avg: LoginAvgAggregateOutputType | null
    _sum: LoginSumAggregateOutputType | null
    _min: LoginMinAggregateOutputType | null
    _max: LoginMaxAggregateOutputType | null
  }

  type GetLoginGroupByPayload<T extends loginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoginGroupByOutputType[P]>
            : GetScalarType<T[P], LoginGroupByOutputType[P]>
        }
      >
    >


  export type loginSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    login_id?: boolean
    email?: boolean
    password?: boolean
    is_verified?: boolean
    provider?: boolean
    provider_id?: boolean
    profile_image?: boolean
    ativo?: boolean
    usuario?: boolean | login$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["login"]>

  export type loginSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    login_id?: boolean
    email?: boolean
    password?: boolean
    is_verified?: boolean
    provider?: boolean
    provider_id?: boolean
    profile_image?: boolean
    ativo?: boolean
  }, ExtArgs["result"]["login"]>

  export type loginSelectScalar = {
    login_id?: boolean
    email?: boolean
    password?: boolean
    is_verified?: boolean
    provider?: boolean
    provider_id?: boolean
    profile_image?: boolean
    ativo?: boolean
  }

  export type loginInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | login$usuarioArgs<ExtArgs>
  }
  export type loginIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $loginPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "login"
    objects: {
      usuario: Prisma.$usuarioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      login_id: number
      email: string
      password: string | null
      is_verified: boolean
      provider: string
      provider_id: string | null
      profile_image: string | null
      ativo: boolean
    }, ExtArgs["result"]["login"]>
    composites: {}
  }

  type loginGetPayload<S extends boolean | null | undefined | loginDefaultArgs> = $Result.GetResult<Prisma.$loginPayload, S>

  type loginCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<loginFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LoginCountAggregateInputType | true
    }

  export interface loginDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['login'], meta: { name: 'login' } }
    /**
     * Find zero or one Login that matches the filter.
     * @param {loginFindUniqueArgs} args - Arguments to find a Login
     * @example
     * // Get one Login
     * const login = await prisma.login.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends loginFindUniqueArgs>(args: SelectSubset<T, loginFindUniqueArgs<ExtArgs>>): Prisma__loginClient<$Result.GetResult<Prisma.$loginPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Login that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {loginFindUniqueOrThrowArgs} args - Arguments to find a Login
     * @example
     * // Get one Login
     * const login = await prisma.login.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends loginFindUniqueOrThrowArgs>(args: SelectSubset<T, loginFindUniqueOrThrowArgs<ExtArgs>>): Prisma__loginClient<$Result.GetResult<Prisma.$loginPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Login that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loginFindFirstArgs} args - Arguments to find a Login
     * @example
     * // Get one Login
     * const login = await prisma.login.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends loginFindFirstArgs>(args?: SelectSubset<T, loginFindFirstArgs<ExtArgs>>): Prisma__loginClient<$Result.GetResult<Prisma.$loginPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Login that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loginFindFirstOrThrowArgs} args - Arguments to find a Login
     * @example
     * // Get one Login
     * const login = await prisma.login.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends loginFindFirstOrThrowArgs>(args?: SelectSubset<T, loginFindFirstOrThrowArgs<ExtArgs>>): Prisma__loginClient<$Result.GetResult<Prisma.$loginPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Logins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loginFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logins
     * const logins = await prisma.login.findMany()
     * 
     * // Get first 10 Logins
     * const logins = await prisma.login.findMany({ take: 10 })
     * 
     * // Only select the `login_id`
     * const loginWithLogin_idOnly = await prisma.login.findMany({ select: { login_id: true } })
     * 
     */
    findMany<T extends loginFindManyArgs>(args?: SelectSubset<T, loginFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$loginPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Login.
     * @param {loginCreateArgs} args - Arguments to create a Login.
     * @example
     * // Create one Login
     * const Login = await prisma.login.create({
     *   data: {
     *     // ... data to create a Login
     *   }
     * })
     * 
     */
    create<T extends loginCreateArgs>(args: SelectSubset<T, loginCreateArgs<ExtArgs>>): Prisma__loginClient<$Result.GetResult<Prisma.$loginPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Logins.
     * @param {loginCreateManyArgs} args - Arguments to create many Logins.
     * @example
     * // Create many Logins
     * const login = await prisma.login.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends loginCreateManyArgs>(args?: SelectSubset<T, loginCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Logins and returns the data saved in the database.
     * @param {loginCreateManyAndReturnArgs} args - Arguments to create many Logins.
     * @example
     * // Create many Logins
     * const login = await prisma.login.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Logins and only return the `login_id`
     * const loginWithLogin_idOnly = await prisma.login.createManyAndReturn({ 
     *   select: { login_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends loginCreateManyAndReturnArgs>(args?: SelectSubset<T, loginCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$loginPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Login.
     * @param {loginDeleteArgs} args - Arguments to delete one Login.
     * @example
     * // Delete one Login
     * const Login = await prisma.login.delete({
     *   where: {
     *     // ... filter to delete one Login
     *   }
     * })
     * 
     */
    delete<T extends loginDeleteArgs>(args: SelectSubset<T, loginDeleteArgs<ExtArgs>>): Prisma__loginClient<$Result.GetResult<Prisma.$loginPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Login.
     * @param {loginUpdateArgs} args - Arguments to update one Login.
     * @example
     * // Update one Login
     * const login = await prisma.login.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends loginUpdateArgs>(args: SelectSubset<T, loginUpdateArgs<ExtArgs>>): Prisma__loginClient<$Result.GetResult<Prisma.$loginPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Logins.
     * @param {loginDeleteManyArgs} args - Arguments to filter Logins to delete.
     * @example
     * // Delete a few Logins
     * const { count } = await prisma.login.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends loginDeleteManyArgs>(args?: SelectSubset<T, loginDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logins
     * const login = await prisma.login.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends loginUpdateManyArgs>(args: SelectSubset<T, loginUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Login.
     * @param {loginUpsertArgs} args - Arguments to update or create a Login.
     * @example
     * // Update or create a Login
     * const login = await prisma.login.upsert({
     *   create: {
     *     // ... data to create a Login
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Login we want to update
     *   }
     * })
     */
    upsert<T extends loginUpsertArgs>(args: SelectSubset<T, loginUpsertArgs<ExtArgs>>): Prisma__loginClient<$Result.GetResult<Prisma.$loginPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Logins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loginCountArgs} args - Arguments to filter Logins to count.
     * @example
     * // Count the number of Logins
     * const count = await prisma.login.count({
     *   where: {
     *     // ... the filter for the Logins we want to count
     *   }
     * })
    **/
    count<T extends loginCountArgs>(
      args?: Subset<T, loginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Login.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoginAggregateArgs>(args: Subset<T, LoginAggregateArgs>): Prisma.PrismaPromise<GetLoginAggregateType<T>>

    /**
     * Group by Login.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {loginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends loginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: loginGroupByArgs['orderBy'] }
        : { orderBy?: loginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, loginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the login model
   */
  readonly fields: loginFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for login.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__loginClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends login$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, login$usuarioArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the login model
   */ 
  interface loginFieldRefs {
    readonly login_id: FieldRef<"login", 'Int'>
    readonly email: FieldRef<"login", 'String'>
    readonly password: FieldRef<"login", 'String'>
    readonly is_verified: FieldRef<"login", 'Boolean'>
    readonly provider: FieldRef<"login", 'String'>
    readonly provider_id: FieldRef<"login", 'String'>
    readonly profile_image: FieldRef<"login", 'String'>
    readonly ativo: FieldRef<"login", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * login findUnique
   */
  export type loginFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login
     */
    select?: loginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: loginInclude<ExtArgs> | null
    /**
     * Filter, which login to fetch.
     */
    where: loginWhereUniqueInput
  }

  /**
   * login findUniqueOrThrow
   */
  export type loginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login
     */
    select?: loginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: loginInclude<ExtArgs> | null
    /**
     * Filter, which login to fetch.
     */
    where: loginWhereUniqueInput
  }

  /**
   * login findFirst
   */
  export type loginFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login
     */
    select?: loginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: loginInclude<ExtArgs> | null
    /**
     * Filter, which login to fetch.
     */
    where?: loginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logins to fetch.
     */
    orderBy?: loginOrderByWithRelationInput | loginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logins.
     */
    cursor?: loginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logins.
     */
    distinct?: LoginScalarFieldEnum | LoginScalarFieldEnum[]
  }

  /**
   * login findFirstOrThrow
   */
  export type loginFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login
     */
    select?: loginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: loginInclude<ExtArgs> | null
    /**
     * Filter, which login to fetch.
     */
    where?: loginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logins to fetch.
     */
    orderBy?: loginOrderByWithRelationInput | loginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logins.
     */
    cursor?: loginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logins.
     */
    distinct?: LoginScalarFieldEnum | LoginScalarFieldEnum[]
  }

  /**
   * login findMany
   */
  export type loginFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login
     */
    select?: loginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: loginInclude<ExtArgs> | null
    /**
     * Filter, which logins to fetch.
     */
    where?: loginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logins to fetch.
     */
    orderBy?: loginOrderByWithRelationInput | loginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing logins.
     */
    cursor?: loginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logins.
     */
    skip?: number
    distinct?: LoginScalarFieldEnum | LoginScalarFieldEnum[]
  }

  /**
   * login create
   */
  export type loginCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login
     */
    select?: loginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: loginInclude<ExtArgs> | null
    /**
     * The data needed to create a login.
     */
    data: XOR<loginCreateInput, loginUncheckedCreateInput>
  }

  /**
   * login createMany
   */
  export type loginCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many logins.
     */
    data: loginCreateManyInput | loginCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * login createManyAndReturn
   */
  export type loginCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login
     */
    select?: loginSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many logins.
     */
    data: loginCreateManyInput | loginCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * login update
   */
  export type loginUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login
     */
    select?: loginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: loginInclude<ExtArgs> | null
    /**
     * The data needed to update a login.
     */
    data: XOR<loginUpdateInput, loginUncheckedUpdateInput>
    /**
     * Choose, which login to update.
     */
    where: loginWhereUniqueInput
  }

  /**
   * login updateMany
   */
  export type loginUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update logins.
     */
    data: XOR<loginUpdateManyMutationInput, loginUncheckedUpdateManyInput>
    /**
     * Filter which logins to update
     */
    where?: loginWhereInput
  }

  /**
   * login upsert
   */
  export type loginUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login
     */
    select?: loginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: loginInclude<ExtArgs> | null
    /**
     * The filter to search for the login to update in case it exists.
     */
    where: loginWhereUniqueInput
    /**
     * In case the login found by the `where` argument doesn't exist, create a new login with this data.
     */
    create: XOR<loginCreateInput, loginUncheckedCreateInput>
    /**
     * In case the login was found with the provided `where` argument, update it with this data.
     */
    update: XOR<loginUpdateInput, loginUncheckedUpdateInput>
  }

  /**
   * login delete
   */
  export type loginDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login
     */
    select?: loginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: loginInclude<ExtArgs> | null
    /**
     * Filter which login to delete.
     */
    where: loginWhereUniqueInput
  }

  /**
   * login deleteMany
   */
  export type loginDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which logins to delete
     */
    where?: loginWhereInput
  }

  /**
   * login.usuario
   */
  export type login$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    where?: usuarioWhereInput
  }

  /**
   * login without action
   */
  export type loginDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the login
     */
    select?: loginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: loginInclude<ExtArgs> | null
  }


  /**
   * Model usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    usuario_id: number | null
    login_id: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    usuario_id: number | null
    login_id: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    usuario_id: number | null
    nome: string | null
    created_at: Date | null
    roule: string | null
    login_id: number | null
  }

  export type UsuarioMaxAggregateOutputType = {
    usuario_id: number | null
    nome: string | null
    created_at: Date | null
    roule: string | null
    login_id: number | null
  }

  export type UsuarioCountAggregateOutputType = {
    usuario_id: number
    nome: number
    created_at: number
    roule: number
    login_id: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    usuario_id?: true
    login_id?: true
  }

  export type UsuarioSumAggregateInputType = {
    usuario_id?: true
    login_id?: true
  }

  export type UsuarioMinAggregateInputType = {
    usuario_id?: true
    nome?: true
    created_at?: true
    roule?: true
    login_id?: true
  }

  export type UsuarioMaxAggregateInputType = {
    usuario_id?: true
    nome?: true
    created_at?: true
    roule?: true
    login_id?: true
  }

  export type UsuarioCountAggregateInputType = {
    usuario_id?: true
    nome?: true
    created_at?: true
    roule?: true
    login_id?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuario to aggregate.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type usuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuarioWhereInput
    orderBy?: usuarioOrderByWithAggregationInput | usuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: usuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    usuario_id: number
    nome: string
    created_at: Date
    roule: string | null
    login_id: number
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends usuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type usuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    usuario_id?: boolean
    nome?: boolean
    created_at?: boolean
    roule?: boolean
    login_id?: boolean
    login?: boolean | loginDefaultArgs<ExtArgs>
    projetoUsuarios?: boolean | usuario$projetoUsuariosArgs<ExtArgs>
    habilidades?: boolean | usuario$habilidadesArgs<ExtArgs>
    permissoes?: boolean | usuario$permissoesArgs<ExtArgs>
    permissoesProjeto?: boolean | usuario$permissoesProjetoArgs<ExtArgs>
    participacoes?: boolean | usuario$participacoesArgs<ExtArgs>
    comentarios?: boolean | usuario$comentariosArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type usuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    usuario_id?: boolean
    nome?: boolean
    created_at?: boolean
    roule?: boolean
    login_id?: boolean
    login?: boolean | loginDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type usuarioSelectScalar = {
    usuario_id?: boolean
    nome?: boolean
    created_at?: boolean
    roule?: boolean
    login_id?: boolean
  }

  export type usuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    login?: boolean | loginDefaultArgs<ExtArgs>
    projetoUsuarios?: boolean | usuario$projetoUsuariosArgs<ExtArgs>
    habilidades?: boolean | usuario$habilidadesArgs<ExtArgs>
    permissoes?: boolean | usuario$permissoesArgs<ExtArgs>
    permissoesProjeto?: boolean | usuario$permissoesProjetoArgs<ExtArgs>
    participacoes?: boolean | usuario$participacoesArgs<ExtArgs>
    comentarios?: boolean | usuario$comentariosArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    login?: boolean | loginDefaultArgs<ExtArgs>
  }

  export type $usuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usuario"
    objects: {
      login: Prisma.$loginPayload<ExtArgs>
      projetoUsuarios: Prisma.$projetoUsuarioPayload<ExtArgs>[]
      habilidades: Prisma.$habilidadeUsuarioPayload<ExtArgs>[]
      permissoes: Prisma.$permissaoPayload<ExtArgs>[]
      permissoesProjeto: Prisma.$permissaoProjetoPayload<ExtArgs>[]
      participacoes: Prisma.$participacaoTarefaPayload<ExtArgs>[]
      comentarios: Prisma.$comentarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      usuario_id: number
      nome: string
      created_at: Date
      roule: string | null
      login_id: number
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type usuarioGetPayload<S extends boolean | null | undefined | usuarioDefaultArgs> = $Result.GetResult<Prisma.$usuarioPayload, S>

  type usuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface usuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usuario'], meta: { name: 'usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {usuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usuarioFindUniqueArgs>(args: SelectSubset<T, usuarioFindUniqueArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, usuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usuarioFindFirstArgs>(args?: SelectSubset<T, usuarioFindFirstArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, usuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `usuario_id`
     * const usuarioWithUsuario_idOnly = await prisma.usuario.findMany({ select: { usuario_id: true } })
     * 
     */
    findMany<T extends usuarioFindManyArgs>(args?: SelectSubset<T, usuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario.
     * @param {usuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends usuarioCreateArgs>(args: SelectSubset<T, usuarioCreateArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {usuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usuarioCreateManyArgs>(args?: SelectSubset<T, usuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {usuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `usuario_id`
     * const usuarioWithUsuario_idOnly = await prisma.usuario.createManyAndReturn({ 
     *   select: { usuario_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, usuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Usuario.
     * @param {usuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends usuarioDeleteArgs>(args: SelectSubset<T, usuarioDeleteArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {usuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usuarioUpdateArgs>(args: SelectSubset<T, usuarioUpdateArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {usuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usuarioDeleteManyArgs>(args?: SelectSubset<T, usuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usuarioUpdateManyArgs>(args: SelectSubset<T, usuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {usuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends usuarioUpsertArgs>(args: SelectSubset<T, usuarioUpsertArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends usuarioCountArgs>(
      args?: Subset<T, usuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usuarioGroupByArgs['orderBy'] }
        : { orderBy?: usuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usuario model
   */
  readonly fields: usuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    login<T extends loginDefaultArgs<ExtArgs> = {}>(args?: Subset<T, loginDefaultArgs<ExtArgs>>): Prisma__loginClient<$Result.GetResult<Prisma.$loginPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    projetoUsuarios<T extends usuario$projetoUsuariosArgs<ExtArgs> = {}>(args?: Subset<T, usuario$projetoUsuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projetoUsuarioPayload<ExtArgs>, T, "findMany"> | Null>
    habilidades<T extends usuario$habilidadesArgs<ExtArgs> = {}>(args?: Subset<T, usuario$habilidadesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$habilidadeUsuarioPayload<ExtArgs>, T, "findMany"> | Null>
    permissoes<T extends usuario$permissoesArgs<ExtArgs> = {}>(args?: Subset<T, usuario$permissoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissaoPayload<ExtArgs>, T, "findMany"> | Null>
    permissoesProjeto<T extends usuario$permissoesProjetoArgs<ExtArgs> = {}>(args?: Subset<T, usuario$permissoesProjetoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissaoProjetoPayload<ExtArgs>, T, "findMany"> | Null>
    participacoes<T extends usuario$participacoesArgs<ExtArgs> = {}>(args?: Subset<T, usuario$participacoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$participacaoTarefaPayload<ExtArgs>, T, "findMany"> | Null>
    comentarios<T extends usuario$comentariosArgs<ExtArgs> = {}>(args?: Subset<T, usuario$comentariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usuario model
   */ 
  interface usuarioFieldRefs {
    readonly usuario_id: FieldRef<"usuario", 'Int'>
    readonly nome: FieldRef<"usuario", 'String'>
    readonly created_at: FieldRef<"usuario", 'DateTime'>
    readonly roule: FieldRef<"usuario", 'String'>
    readonly login_id: FieldRef<"usuario", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * usuario findUnique
   */
  export type usuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario findUniqueOrThrow
   */
  export type usuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario findFirst
   */
  export type usuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * usuario findFirstOrThrow
   */
  export type usuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * usuario findMany
   */
  export type usuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * usuario create
   */
  export type usuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a usuario.
     */
    data: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
  }

  /**
   * usuario createMany
   */
  export type usuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usuarios.
     */
    data: usuarioCreateManyInput | usuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usuario createManyAndReturn
   */
  export type usuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many usuarios.
     */
    data: usuarioCreateManyInput | usuarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * usuario update
   */
  export type usuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a usuario.
     */
    data: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
    /**
     * Choose, which usuario to update.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario updateMany
   */
  export type usuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usuarios.
     */
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyInput>
    /**
     * Filter which usuarios to update
     */
    where?: usuarioWhereInput
  }

  /**
   * usuario upsert
   */
  export type usuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the usuario to update in case it exists.
     */
    where: usuarioWhereUniqueInput
    /**
     * In case the usuario found by the `where` argument doesn't exist, create a new usuario with this data.
     */
    create: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
    /**
     * In case the usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
  }

  /**
   * usuario delete
   */
  export type usuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter which usuario to delete.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario deleteMany
   */
  export type usuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuarios to delete
     */
    where?: usuarioWhereInput
  }

  /**
   * usuario.projetoUsuarios
   */
  export type usuario$projetoUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoUsuario
     */
    select?: projetoUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoUsuarioInclude<ExtArgs> | null
    where?: projetoUsuarioWhereInput
    orderBy?: projetoUsuarioOrderByWithRelationInput | projetoUsuarioOrderByWithRelationInput[]
    cursor?: projetoUsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjetoUsuarioScalarFieldEnum | ProjetoUsuarioScalarFieldEnum[]
  }

  /**
   * usuario.habilidades
   */
  export type usuario$habilidadesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habilidadeUsuario
     */
    select?: habilidadeUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habilidadeUsuarioInclude<ExtArgs> | null
    where?: habilidadeUsuarioWhereInput
    orderBy?: habilidadeUsuarioOrderByWithRelationInput | habilidadeUsuarioOrderByWithRelationInput[]
    cursor?: habilidadeUsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HabilidadeUsuarioScalarFieldEnum | HabilidadeUsuarioScalarFieldEnum[]
  }

  /**
   * usuario.permissoes
   */
  export type usuario$permissoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissao
     */
    select?: permissaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoInclude<ExtArgs> | null
    where?: permissaoWhereInput
    orderBy?: permissaoOrderByWithRelationInput | permissaoOrderByWithRelationInput[]
    cursor?: permissaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissaoScalarFieldEnum | PermissaoScalarFieldEnum[]
  }

  /**
   * usuario.permissoesProjeto
   */
  export type usuario$permissoesProjetoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissaoProjeto
     */
    select?: permissaoProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoProjetoInclude<ExtArgs> | null
    where?: permissaoProjetoWhereInput
    orderBy?: permissaoProjetoOrderByWithRelationInput | permissaoProjetoOrderByWithRelationInput[]
    cursor?: permissaoProjetoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissaoProjetoScalarFieldEnum | PermissaoProjetoScalarFieldEnum[]
  }

  /**
   * usuario.participacoes
   */
  export type usuario$participacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the participacaoTarefa
     */
    select?: participacaoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: participacaoTarefaInclude<ExtArgs> | null
    where?: participacaoTarefaWhereInput
    orderBy?: participacaoTarefaOrderByWithRelationInput | participacaoTarefaOrderByWithRelationInput[]
    cursor?: participacaoTarefaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParticipacaoTarefaScalarFieldEnum | ParticipacaoTarefaScalarFieldEnum[]
  }

  /**
   * usuario.comentarios
   */
  export type usuario$comentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
    where?: comentarioWhereInput
    orderBy?: comentarioOrderByWithRelationInput | comentarioOrderByWithRelationInput[]
    cursor?: comentarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * usuario without action
   */
  export type usuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
  }


  /**
   * Model projeto
   */

  export type AggregateProjeto = {
    _count: ProjetoCountAggregateOutputType | null
    _avg: ProjetoAvgAggregateOutputType | null
    _sum: ProjetoSumAggregateOutputType | null
    _min: ProjetoMinAggregateOutputType | null
    _max: ProjetoMaxAggregateOutputType | null
  }

  export type ProjetoAvgAggregateOutputType = {
    projeto_id: number | null
  }

  export type ProjetoSumAggregateOutputType = {
    projeto_id: number | null
  }

  export type ProjetoMinAggregateOutputType = {
    projeto_id: number | null
    nome: string | null
    descricao: string | null
    created_at: Date | null
    conclude_at: Date | null
  }

  export type ProjetoMaxAggregateOutputType = {
    projeto_id: number | null
    nome: string | null
    descricao: string | null
    created_at: Date | null
    conclude_at: Date | null
  }

  export type ProjetoCountAggregateOutputType = {
    projeto_id: number
    nome: number
    descricao: number
    created_at: number
    conclude_at: number
    _all: number
  }


  export type ProjetoAvgAggregateInputType = {
    projeto_id?: true
  }

  export type ProjetoSumAggregateInputType = {
    projeto_id?: true
  }

  export type ProjetoMinAggregateInputType = {
    projeto_id?: true
    nome?: true
    descricao?: true
    created_at?: true
    conclude_at?: true
  }

  export type ProjetoMaxAggregateInputType = {
    projeto_id?: true
    nome?: true
    descricao?: true
    created_at?: true
    conclude_at?: true
  }

  export type ProjetoCountAggregateInputType = {
    projeto_id?: true
    nome?: true
    descricao?: true
    created_at?: true
    conclude_at?: true
    _all?: true
  }

  export type ProjetoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projeto to aggregate.
     */
    where?: projetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projetos to fetch.
     */
    orderBy?: projetoOrderByWithRelationInput | projetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: projetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projetos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned projetos
    **/
    _count?: true | ProjetoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjetoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjetoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjetoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjetoMaxAggregateInputType
  }

  export type GetProjetoAggregateType<T extends ProjetoAggregateArgs> = {
        [P in keyof T & keyof AggregateProjeto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjeto[P]>
      : GetScalarType<T[P], AggregateProjeto[P]>
  }




  export type projetoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projetoWhereInput
    orderBy?: projetoOrderByWithAggregationInput | projetoOrderByWithAggregationInput[]
    by: ProjetoScalarFieldEnum[] | ProjetoScalarFieldEnum
    having?: projetoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjetoCountAggregateInputType | true
    _avg?: ProjetoAvgAggregateInputType
    _sum?: ProjetoSumAggregateInputType
    _min?: ProjetoMinAggregateInputType
    _max?: ProjetoMaxAggregateInputType
  }

  export type ProjetoGroupByOutputType = {
    projeto_id: number
    nome: string
    descricao: string
    created_at: Date
    conclude_at: Date | null
    _count: ProjetoCountAggregateOutputType | null
    _avg: ProjetoAvgAggregateOutputType | null
    _sum: ProjetoSumAggregateOutputType | null
    _min: ProjetoMinAggregateOutputType | null
    _max: ProjetoMaxAggregateOutputType | null
  }

  type GetProjetoGroupByPayload<T extends projetoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjetoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjetoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjetoGroupByOutputType[P]>
            : GetScalarType<T[P], ProjetoGroupByOutputType[P]>
        }
      >
    >


  export type projetoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projeto_id?: boolean
    nome?: boolean
    descricao?: boolean
    created_at?: boolean
    conclude_at?: boolean
    projetoUsuarios?: boolean | projeto$projetoUsuariosArgs<ExtArgs>
    tecnologias?: boolean | projeto$tecnologiasArgs<ExtArgs>
    recursos?: boolean | projeto$recursosArgs<ExtArgs>
    anexos?: boolean | projeto$anexosArgs<ExtArgs>
    permissoes?: boolean | projeto$permissoesArgs<ExtArgs>
    _count?: boolean | ProjetoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projeto"]>

  export type projetoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projeto_id?: boolean
    nome?: boolean
    descricao?: boolean
    created_at?: boolean
    conclude_at?: boolean
  }, ExtArgs["result"]["projeto"]>

  export type projetoSelectScalar = {
    projeto_id?: boolean
    nome?: boolean
    descricao?: boolean
    created_at?: boolean
    conclude_at?: boolean
  }

  export type projetoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projetoUsuarios?: boolean | projeto$projetoUsuariosArgs<ExtArgs>
    tecnologias?: boolean | projeto$tecnologiasArgs<ExtArgs>
    recursos?: boolean | projeto$recursosArgs<ExtArgs>
    anexos?: boolean | projeto$anexosArgs<ExtArgs>
    permissoes?: boolean | projeto$permissoesArgs<ExtArgs>
    _count?: boolean | ProjetoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type projetoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $projetoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "projeto"
    objects: {
      projetoUsuarios: Prisma.$projetoUsuarioPayload<ExtArgs>[]
      tecnologias: Prisma.$projetoTecnologiaPayload<ExtArgs>[]
      recursos: Prisma.$recursoPayload<ExtArgs>[]
      anexos: Prisma.$anexoProjetoPayload<ExtArgs>[]
      permissoes: Prisma.$permissaoProjetoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      projeto_id: number
      nome: string
      descricao: string
      created_at: Date
      conclude_at: Date | null
    }, ExtArgs["result"]["projeto"]>
    composites: {}
  }

  type projetoGetPayload<S extends boolean | null | undefined | projetoDefaultArgs> = $Result.GetResult<Prisma.$projetoPayload, S>

  type projetoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<projetoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjetoCountAggregateInputType | true
    }

  export interface projetoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['projeto'], meta: { name: 'projeto' } }
    /**
     * Find zero or one Projeto that matches the filter.
     * @param {projetoFindUniqueArgs} args - Arguments to find a Projeto
     * @example
     * // Get one Projeto
     * const projeto = await prisma.projeto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends projetoFindUniqueArgs>(args: SelectSubset<T, projetoFindUniqueArgs<ExtArgs>>): Prisma__projetoClient<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Projeto that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {projetoFindUniqueOrThrowArgs} args - Arguments to find a Projeto
     * @example
     * // Get one Projeto
     * const projeto = await prisma.projeto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends projetoFindUniqueOrThrowArgs>(args: SelectSubset<T, projetoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__projetoClient<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Projeto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoFindFirstArgs} args - Arguments to find a Projeto
     * @example
     * // Get one Projeto
     * const projeto = await prisma.projeto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends projetoFindFirstArgs>(args?: SelectSubset<T, projetoFindFirstArgs<ExtArgs>>): Prisma__projetoClient<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Projeto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoFindFirstOrThrowArgs} args - Arguments to find a Projeto
     * @example
     * // Get one Projeto
     * const projeto = await prisma.projeto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends projetoFindFirstOrThrowArgs>(args?: SelectSubset<T, projetoFindFirstOrThrowArgs<ExtArgs>>): Prisma__projetoClient<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projetos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projetos
     * const projetos = await prisma.projeto.findMany()
     * 
     * // Get first 10 Projetos
     * const projetos = await prisma.projeto.findMany({ take: 10 })
     * 
     * // Only select the `projeto_id`
     * const projetoWithProjeto_idOnly = await prisma.projeto.findMany({ select: { projeto_id: true } })
     * 
     */
    findMany<T extends projetoFindManyArgs>(args?: SelectSubset<T, projetoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Projeto.
     * @param {projetoCreateArgs} args - Arguments to create a Projeto.
     * @example
     * // Create one Projeto
     * const Projeto = await prisma.projeto.create({
     *   data: {
     *     // ... data to create a Projeto
     *   }
     * })
     * 
     */
    create<T extends projetoCreateArgs>(args: SelectSubset<T, projetoCreateArgs<ExtArgs>>): Prisma__projetoClient<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projetos.
     * @param {projetoCreateManyArgs} args - Arguments to create many Projetos.
     * @example
     * // Create many Projetos
     * const projeto = await prisma.projeto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends projetoCreateManyArgs>(args?: SelectSubset<T, projetoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projetos and returns the data saved in the database.
     * @param {projetoCreateManyAndReturnArgs} args - Arguments to create many Projetos.
     * @example
     * // Create many Projetos
     * const projeto = await prisma.projeto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projetos and only return the `projeto_id`
     * const projetoWithProjeto_idOnly = await prisma.projeto.createManyAndReturn({ 
     *   select: { projeto_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends projetoCreateManyAndReturnArgs>(args?: SelectSubset<T, projetoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Projeto.
     * @param {projetoDeleteArgs} args - Arguments to delete one Projeto.
     * @example
     * // Delete one Projeto
     * const Projeto = await prisma.projeto.delete({
     *   where: {
     *     // ... filter to delete one Projeto
     *   }
     * })
     * 
     */
    delete<T extends projetoDeleteArgs>(args: SelectSubset<T, projetoDeleteArgs<ExtArgs>>): Prisma__projetoClient<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Projeto.
     * @param {projetoUpdateArgs} args - Arguments to update one Projeto.
     * @example
     * // Update one Projeto
     * const projeto = await prisma.projeto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends projetoUpdateArgs>(args: SelectSubset<T, projetoUpdateArgs<ExtArgs>>): Prisma__projetoClient<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projetos.
     * @param {projetoDeleteManyArgs} args - Arguments to filter Projetos to delete.
     * @example
     * // Delete a few Projetos
     * const { count } = await prisma.projeto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends projetoDeleteManyArgs>(args?: SelectSubset<T, projetoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projetos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projetos
     * const projeto = await prisma.projeto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends projetoUpdateManyArgs>(args: SelectSubset<T, projetoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Projeto.
     * @param {projetoUpsertArgs} args - Arguments to update or create a Projeto.
     * @example
     * // Update or create a Projeto
     * const projeto = await prisma.projeto.upsert({
     *   create: {
     *     // ... data to create a Projeto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Projeto we want to update
     *   }
     * })
     */
    upsert<T extends projetoUpsertArgs>(args: SelectSubset<T, projetoUpsertArgs<ExtArgs>>): Prisma__projetoClient<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projetos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoCountArgs} args - Arguments to filter Projetos to count.
     * @example
     * // Count the number of Projetos
     * const count = await prisma.projeto.count({
     *   where: {
     *     // ... the filter for the Projetos we want to count
     *   }
     * })
    **/
    count<T extends projetoCountArgs>(
      args?: Subset<T, projetoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjetoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Projeto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjetoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjetoAggregateArgs>(args: Subset<T, ProjetoAggregateArgs>): Prisma.PrismaPromise<GetProjetoAggregateType<T>>

    /**
     * Group by Projeto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends projetoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: projetoGroupByArgs['orderBy'] }
        : { orderBy?: projetoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, projetoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjetoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the projeto model
   */
  readonly fields: projetoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for projeto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__projetoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projetoUsuarios<T extends projeto$projetoUsuariosArgs<ExtArgs> = {}>(args?: Subset<T, projeto$projetoUsuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projetoUsuarioPayload<ExtArgs>, T, "findMany"> | Null>
    tecnologias<T extends projeto$tecnologiasArgs<ExtArgs> = {}>(args?: Subset<T, projeto$tecnologiasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projetoTecnologiaPayload<ExtArgs>, T, "findMany"> | Null>
    recursos<T extends projeto$recursosArgs<ExtArgs> = {}>(args?: Subset<T, projeto$recursosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recursoPayload<ExtArgs>, T, "findMany"> | Null>
    anexos<T extends projeto$anexosArgs<ExtArgs> = {}>(args?: Subset<T, projeto$anexosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$anexoProjetoPayload<ExtArgs>, T, "findMany"> | Null>
    permissoes<T extends projeto$permissoesArgs<ExtArgs> = {}>(args?: Subset<T, projeto$permissoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissaoProjetoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the projeto model
   */ 
  interface projetoFieldRefs {
    readonly projeto_id: FieldRef<"projeto", 'Int'>
    readonly nome: FieldRef<"projeto", 'String'>
    readonly descricao: FieldRef<"projeto", 'String'>
    readonly created_at: FieldRef<"projeto", 'DateTime'>
    readonly conclude_at: FieldRef<"projeto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * projeto findUnique
   */
  export type projetoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null
    /**
     * Filter, which projeto to fetch.
     */
    where: projetoWhereUniqueInput
  }

  /**
   * projeto findUniqueOrThrow
   */
  export type projetoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null
    /**
     * Filter, which projeto to fetch.
     */
    where: projetoWhereUniqueInput
  }

  /**
   * projeto findFirst
   */
  export type projetoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null
    /**
     * Filter, which projeto to fetch.
     */
    where?: projetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projetos to fetch.
     */
    orderBy?: projetoOrderByWithRelationInput | projetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projetos.
     */
    cursor?: projetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projetos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projetos.
     */
    distinct?: ProjetoScalarFieldEnum | ProjetoScalarFieldEnum[]
  }

  /**
   * projeto findFirstOrThrow
   */
  export type projetoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null
    /**
     * Filter, which projeto to fetch.
     */
    where?: projetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projetos to fetch.
     */
    orderBy?: projetoOrderByWithRelationInput | projetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projetos.
     */
    cursor?: projetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projetos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projetos.
     */
    distinct?: ProjetoScalarFieldEnum | ProjetoScalarFieldEnum[]
  }

  /**
   * projeto findMany
   */
  export type projetoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null
    /**
     * Filter, which projetos to fetch.
     */
    where?: projetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projetos to fetch.
     */
    orderBy?: projetoOrderByWithRelationInput | projetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing projetos.
     */
    cursor?: projetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projetos.
     */
    skip?: number
    distinct?: ProjetoScalarFieldEnum | ProjetoScalarFieldEnum[]
  }

  /**
   * projeto create
   */
  export type projetoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null
    /**
     * The data needed to create a projeto.
     */
    data: XOR<projetoCreateInput, projetoUncheckedCreateInput>
  }

  /**
   * projeto createMany
   */
  export type projetoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many projetos.
     */
    data: projetoCreateManyInput | projetoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * projeto createManyAndReturn
   */
  export type projetoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many projetos.
     */
    data: projetoCreateManyInput | projetoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * projeto update
   */
  export type projetoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null
    /**
     * The data needed to update a projeto.
     */
    data: XOR<projetoUpdateInput, projetoUncheckedUpdateInput>
    /**
     * Choose, which projeto to update.
     */
    where: projetoWhereUniqueInput
  }

  /**
   * projeto updateMany
   */
  export type projetoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update projetos.
     */
    data: XOR<projetoUpdateManyMutationInput, projetoUncheckedUpdateManyInput>
    /**
     * Filter which projetos to update
     */
    where?: projetoWhereInput
  }

  /**
   * projeto upsert
   */
  export type projetoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null
    /**
     * The filter to search for the projeto to update in case it exists.
     */
    where: projetoWhereUniqueInput
    /**
     * In case the projeto found by the `where` argument doesn't exist, create a new projeto with this data.
     */
    create: XOR<projetoCreateInput, projetoUncheckedCreateInput>
    /**
     * In case the projeto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<projetoUpdateInput, projetoUncheckedUpdateInput>
  }

  /**
   * projeto delete
   */
  export type projetoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null
    /**
     * Filter which projeto to delete.
     */
    where: projetoWhereUniqueInput
  }

  /**
   * projeto deleteMany
   */
  export type projetoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projetos to delete
     */
    where?: projetoWhereInput
  }

  /**
   * projeto.projetoUsuarios
   */
  export type projeto$projetoUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoUsuario
     */
    select?: projetoUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoUsuarioInclude<ExtArgs> | null
    where?: projetoUsuarioWhereInput
    orderBy?: projetoUsuarioOrderByWithRelationInput | projetoUsuarioOrderByWithRelationInput[]
    cursor?: projetoUsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjetoUsuarioScalarFieldEnum | ProjetoUsuarioScalarFieldEnum[]
  }

  /**
   * projeto.tecnologias
   */
  export type projeto$tecnologiasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoTecnologia
     */
    select?: projetoTecnologiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoTecnologiaInclude<ExtArgs> | null
    where?: projetoTecnologiaWhereInput
    orderBy?: projetoTecnologiaOrderByWithRelationInput | projetoTecnologiaOrderByWithRelationInput[]
    cursor?: projetoTecnologiaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjetoTecnologiaScalarFieldEnum | ProjetoTecnologiaScalarFieldEnum[]
  }

  /**
   * projeto.recursos
   */
  export type projeto$recursosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null
    where?: recursoWhereInput
    orderBy?: recursoOrderByWithRelationInput | recursoOrderByWithRelationInput[]
    cursor?: recursoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecursoScalarFieldEnum | RecursoScalarFieldEnum[]
  }

  /**
   * projeto.anexos
   */
  export type projeto$anexosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoProjeto
     */
    select?: anexoProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoProjetoInclude<ExtArgs> | null
    where?: anexoProjetoWhereInput
    orderBy?: anexoProjetoOrderByWithRelationInput | anexoProjetoOrderByWithRelationInput[]
    cursor?: anexoProjetoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnexoProjetoScalarFieldEnum | AnexoProjetoScalarFieldEnum[]
  }

  /**
   * projeto.permissoes
   */
  export type projeto$permissoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissaoProjeto
     */
    select?: permissaoProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoProjetoInclude<ExtArgs> | null
    where?: permissaoProjetoWhereInput
    orderBy?: permissaoProjetoOrderByWithRelationInput | permissaoProjetoOrderByWithRelationInput[]
    cursor?: permissaoProjetoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissaoProjetoScalarFieldEnum | PermissaoProjetoScalarFieldEnum[]
  }

  /**
   * projeto without action
   */
  export type projetoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null
  }


  /**
   * Model tecnologia
   */

  export type AggregateTecnologia = {
    _count: TecnologiaCountAggregateOutputType | null
    _avg: TecnologiaAvgAggregateOutputType | null
    _sum: TecnologiaSumAggregateOutputType | null
    _min: TecnologiaMinAggregateOutputType | null
    _max: TecnologiaMaxAggregateOutputType | null
  }

  export type TecnologiaAvgAggregateOutputType = {
    tecnologia_id: number | null
  }

  export type TecnologiaSumAggregateOutputType = {
    tecnologia_id: number | null
  }

  export type TecnologiaMinAggregateOutputType = {
    tecnologia_id: number | null
    descricao: string | null
  }

  export type TecnologiaMaxAggregateOutputType = {
    tecnologia_id: number | null
    descricao: string | null
  }

  export type TecnologiaCountAggregateOutputType = {
    tecnologia_id: number
    descricao: number
    _all: number
  }


  export type TecnologiaAvgAggregateInputType = {
    tecnologia_id?: true
  }

  export type TecnologiaSumAggregateInputType = {
    tecnologia_id?: true
  }

  export type TecnologiaMinAggregateInputType = {
    tecnologia_id?: true
    descricao?: true
  }

  export type TecnologiaMaxAggregateInputType = {
    tecnologia_id?: true
    descricao?: true
  }

  export type TecnologiaCountAggregateInputType = {
    tecnologia_id?: true
    descricao?: true
    _all?: true
  }

  export type TecnologiaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tecnologia to aggregate.
     */
    where?: tecnologiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tecnologias to fetch.
     */
    orderBy?: tecnologiaOrderByWithRelationInput | tecnologiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tecnologiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tecnologias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tecnologias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tecnologias
    **/
    _count?: true | TecnologiaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TecnologiaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TecnologiaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TecnologiaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TecnologiaMaxAggregateInputType
  }

  export type GetTecnologiaAggregateType<T extends TecnologiaAggregateArgs> = {
        [P in keyof T & keyof AggregateTecnologia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTecnologia[P]>
      : GetScalarType<T[P], AggregateTecnologia[P]>
  }




  export type tecnologiaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tecnologiaWhereInput
    orderBy?: tecnologiaOrderByWithAggregationInput | tecnologiaOrderByWithAggregationInput[]
    by: TecnologiaScalarFieldEnum[] | TecnologiaScalarFieldEnum
    having?: tecnologiaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TecnologiaCountAggregateInputType | true
    _avg?: TecnologiaAvgAggregateInputType
    _sum?: TecnologiaSumAggregateInputType
    _min?: TecnologiaMinAggregateInputType
    _max?: TecnologiaMaxAggregateInputType
  }

  export type TecnologiaGroupByOutputType = {
    tecnologia_id: number
    descricao: string
    _count: TecnologiaCountAggregateOutputType | null
    _avg: TecnologiaAvgAggregateOutputType | null
    _sum: TecnologiaSumAggregateOutputType | null
    _min: TecnologiaMinAggregateOutputType | null
    _max: TecnologiaMaxAggregateOutputType | null
  }

  type GetTecnologiaGroupByPayload<T extends tecnologiaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TecnologiaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TecnologiaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TecnologiaGroupByOutputType[P]>
            : GetScalarType<T[P], TecnologiaGroupByOutputType[P]>
        }
      >
    >


  export type tecnologiaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tecnologia_id?: boolean
    descricao?: boolean
    habilidades?: boolean | tecnologia$habilidadesArgs<ExtArgs>
    projetos?: boolean | tecnologia$projetosArgs<ExtArgs>
    _count?: boolean | TecnologiaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tecnologia"]>

  export type tecnologiaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tecnologia_id?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["tecnologia"]>

  export type tecnologiaSelectScalar = {
    tecnologia_id?: boolean
    descricao?: boolean
  }

  export type tecnologiaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    habilidades?: boolean | tecnologia$habilidadesArgs<ExtArgs>
    projetos?: boolean | tecnologia$projetosArgs<ExtArgs>
    _count?: boolean | TecnologiaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tecnologiaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $tecnologiaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tecnologia"
    objects: {
      habilidades: Prisma.$habilidadeUsuarioPayload<ExtArgs>[]
      projetos: Prisma.$projetoTecnologiaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      tecnologia_id: number
      descricao: string
    }, ExtArgs["result"]["tecnologia"]>
    composites: {}
  }

  type tecnologiaGetPayload<S extends boolean | null | undefined | tecnologiaDefaultArgs> = $Result.GetResult<Prisma.$tecnologiaPayload, S>

  type tecnologiaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tecnologiaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TecnologiaCountAggregateInputType | true
    }

  export interface tecnologiaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tecnologia'], meta: { name: 'tecnologia' } }
    /**
     * Find zero or one Tecnologia that matches the filter.
     * @param {tecnologiaFindUniqueArgs} args - Arguments to find a Tecnologia
     * @example
     * // Get one Tecnologia
     * const tecnologia = await prisma.tecnologia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tecnologiaFindUniqueArgs>(args: SelectSubset<T, tecnologiaFindUniqueArgs<ExtArgs>>): Prisma__tecnologiaClient<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tecnologia that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tecnologiaFindUniqueOrThrowArgs} args - Arguments to find a Tecnologia
     * @example
     * // Get one Tecnologia
     * const tecnologia = await prisma.tecnologia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tecnologiaFindUniqueOrThrowArgs>(args: SelectSubset<T, tecnologiaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tecnologiaClient<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tecnologia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tecnologiaFindFirstArgs} args - Arguments to find a Tecnologia
     * @example
     * // Get one Tecnologia
     * const tecnologia = await prisma.tecnologia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tecnologiaFindFirstArgs>(args?: SelectSubset<T, tecnologiaFindFirstArgs<ExtArgs>>): Prisma__tecnologiaClient<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tecnologia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tecnologiaFindFirstOrThrowArgs} args - Arguments to find a Tecnologia
     * @example
     * // Get one Tecnologia
     * const tecnologia = await prisma.tecnologia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tecnologiaFindFirstOrThrowArgs>(args?: SelectSubset<T, tecnologiaFindFirstOrThrowArgs<ExtArgs>>): Prisma__tecnologiaClient<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tecnologias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tecnologiaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tecnologias
     * const tecnologias = await prisma.tecnologia.findMany()
     * 
     * // Get first 10 Tecnologias
     * const tecnologias = await prisma.tecnologia.findMany({ take: 10 })
     * 
     * // Only select the `tecnologia_id`
     * const tecnologiaWithTecnologia_idOnly = await prisma.tecnologia.findMany({ select: { tecnologia_id: true } })
     * 
     */
    findMany<T extends tecnologiaFindManyArgs>(args?: SelectSubset<T, tecnologiaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tecnologia.
     * @param {tecnologiaCreateArgs} args - Arguments to create a Tecnologia.
     * @example
     * // Create one Tecnologia
     * const Tecnologia = await prisma.tecnologia.create({
     *   data: {
     *     // ... data to create a Tecnologia
     *   }
     * })
     * 
     */
    create<T extends tecnologiaCreateArgs>(args: SelectSubset<T, tecnologiaCreateArgs<ExtArgs>>): Prisma__tecnologiaClient<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tecnologias.
     * @param {tecnologiaCreateManyArgs} args - Arguments to create many Tecnologias.
     * @example
     * // Create many Tecnologias
     * const tecnologia = await prisma.tecnologia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tecnologiaCreateManyArgs>(args?: SelectSubset<T, tecnologiaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tecnologias and returns the data saved in the database.
     * @param {tecnologiaCreateManyAndReturnArgs} args - Arguments to create many Tecnologias.
     * @example
     * // Create many Tecnologias
     * const tecnologia = await prisma.tecnologia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tecnologias and only return the `tecnologia_id`
     * const tecnologiaWithTecnologia_idOnly = await prisma.tecnologia.createManyAndReturn({ 
     *   select: { tecnologia_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tecnologiaCreateManyAndReturnArgs>(args?: SelectSubset<T, tecnologiaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tecnologia.
     * @param {tecnologiaDeleteArgs} args - Arguments to delete one Tecnologia.
     * @example
     * // Delete one Tecnologia
     * const Tecnologia = await prisma.tecnologia.delete({
     *   where: {
     *     // ... filter to delete one Tecnologia
     *   }
     * })
     * 
     */
    delete<T extends tecnologiaDeleteArgs>(args: SelectSubset<T, tecnologiaDeleteArgs<ExtArgs>>): Prisma__tecnologiaClient<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tecnologia.
     * @param {tecnologiaUpdateArgs} args - Arguments to update one Tecnologia.
     * @example
     * // Update one Tecnologia
     * const tecnologia = await prisma.tecnologia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tecnologiaUpdateArgs>(args: SelectSubset<T, tecnologiaUpdateArgs<ExtArgs>>): Prisma__tecnologiaClient<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tecnologias.
     * @param {tecnologiaDeleteManyArgs} args - Arguments to filter Tecnologias to delete.
     * @example
     * // Delete a few Tecnologias
     * const { count } = await prisma.tecnologia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tecnologiaDeleteManyArgs>(args?: SelectSubset<T, tecnologiaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tecnologias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tecnologiaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tecnologias
     * const tecnologia = await prisma.tecnologia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tecnologiaUpdateManyArgs>(args: SelectSubset<T, tecnologiaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tecnologia.
     * @param {tecnologiaUpsertArgs} args - Arguments to update or create a Tecnologia.
     * @example
     * // Update or create a Tecnologia
     * const tecnologia = await prisma.tecnologia.upsert({
     *   create: {
     *     // ... data to create a Tecnologia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tecnologia we want to update
     *   }
     * })
     */
    upsert<T extends tecnologiaUpsertArgs>(args: SelectSubset<T, tecnologiaUpsertArgs<ExtArgs>>): Prisma__tecnologiaClient<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tecnologias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tecnologiaCountArgs} args - Arguments to filter Tecnologias to count.
     * @example
     * // Count the number of Tecnologias
     * const count = await prisma.tecnologia.count({
     *   where: {
     *     // ... the filter for the Tecnologias we want to count
     *   }
     * })
    **/
    count<T extends tecnologiaCountArgs>(
      args?: Subset<T, tecnologiaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TecnologiaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tecnologia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TecnologiaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TecnologiaAggregateArgs>(args: Subset<T, TecnologiaAggregateArgs>): Prisma.PrismaPromise<GetTecnologiaAggregateType<T>>

    /**
     * Group by Tecnologia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tecnologiaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tecnologiaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tecnologiaGroupByArgs['orderBy'] }
        : { orderBy?: tecnologiaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tecnologiaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTecnologiaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tecnologia model
   */
  readonly fields: tecnologiaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tecnologia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tecnologiaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    habilidades<T extends tecnologia$habilidadesArgs<ExtArgs> = {}>(args?: Subset<T, tecnologia$habilidadesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$habilidadeUsuarioPayload<ExtArgs>, T, "findMany"> | Null>
    projetos<T extends tecnologia$projetosArgs<ExtArgs> = {}>(args?: Subset<T, tecnologia$projetosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projetoTecnologiaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tecnologia model
   */ 
  interface tecnologiaFieldRefs {
    readonly tecnologia_id: FieldRef<"tecnologia", 'Int'>
    readonly descricao: FieldRef<"tecnologia", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tecnologia findUnique
   */
  export type tecnologiaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaInclude<ExtArgs> | null
    /**
     * Filter, which tecnologia to fetch.
     */
    where: tecnologiaWhereUniqueInput
  }

  /**
   * tecnologia findUniqueOrThrow
   */
  export type tecnologiaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaInclude<ExtArgs> | null
    /**
     * Filter, which tecnologia to fetch.
     */
    where: tecnologiaWhereUniqueInput
  }

  /**
   * tecnologia findFirst
   */
  export type tecnologiaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaInclude<ExtArgs> | null
    /**
     * Filter, which tecnologia to fetch.
     */
    where?: tecnologiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tecnologias to fetch.
     */
    orderBy?: tecnologiaOrderByWithRelationInput | tecnologiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tecnologias.
     */
    cursor?: tecnologiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tecnologias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tecnologias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tecnologias.
     */
    distinct?: TecnologiaScalarFieldEnum | TecnologiaScalarFieldEnum[]
  }

  /**
   * tecnologia findFirstOrThrow
   */
  export type tecnologiaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaInclude<ExtArgs> | null
    /**
     * Filter, which tecnologia to fetch.
     */
    where?: tecnologiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tecnologias to fetch.
     */
    orderBy?: tecnologiaOrderByWithRelationInput | tecnologiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tecnologias.
     */
    cursor?: tecnologiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tecnologias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tecnologias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tecnologias.
     */
    distinct?: TecnologiaScalarFieldEnum | TecnologiaScalarFieldEnum[]
  }

  /**
   * tecnologia findMany
   */
  export type tecnologiaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaInclude<ExtArgs> | null
    /**
     * Filter, which tecnologias to fetch.
     */
    where?: tecnologiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tecnologias to fetch.
     */
    orderBy?: tecnologiaOrderByWithRelationInput | tecnologiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tecnologias.
     */
    cursor?: tecnologiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tecnologias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tecnologias.
     */
    skip?: number
    distinct?: TecnologiaScalarFieldEnum | TecnologiaScalarFieldEnum[]
  }

  /**
   * tecnologia create
   */
  export type tecnologiaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaInclude<ExtArgs> | null
    /**
     * The data needed to create a tecnologia.
     */
    data: XOR<tecnologiaCreateInput, tecnologiaUncheckedCreateInput>
  }

  /**
   * tecnologia createMany
   */
  export type tecnologiaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tecnologias.
     */
    data: tecnologiaCreateManyInput | tecnologiaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tecnologia createManyAndReturn
   */
  export type tecnologiaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many tecnologias.
     */
    data: tecnologiaCreateManyInput | tecnologiaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tecnologia update
   */
  export type tecnologiaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaInclude<ExtArgs> | null
    /**
     * The data needed to update a tecnologia.
     */
    data: XOR<tecnologiaUpdateInput, tecnologiaUncheckedUpdateInput>
    /**
     * Choose, which tecnologia to update.
     */
    where: tecnologiaWhereUniqueInput
  }

  /**
   * tecnologia updateMany
   */
  export type tecnologiaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tecnologias.
     */
    data: XOR<tecnologiaUpdateManyMutationInput, tecnologiaUncheckedUpdateManyInput>
    /**
     * Filter which tecnologias to update
     */
    where?: tecnologiaWhereInput
  }

  /**
   * tecnologia upsert
   */
  export type tecnologiaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaInclude<ExtArgs> | null
    /**
     * The filter to search for the tecnologia to update in case it exists.
     */
    where: tecnologiaWhereUniqueInput
    /**
     * In case the tecnologia found by the `where` argument doesn't exist, create a new tecnologia with this data.
     */
    create: XOR<tecnologiaCreateInput, tecnologiaUncheckedCreateInput>
    /**
     * In case the tecnologia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tecnologiaUpdateInput, tecnologiaUncheckedUpdateInput>
  }

  /**
   * tecnologia delete
   */
  export type tecnologiaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaInclude<ExtArgs> | null
    /**
     * Filter which tecnologia to delete.
     */
    where: tecnologiaWhereUniqueInput
  }

  /**
   * tecnologia deleteMany
   */
  export type tecnologiaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tecnologias to delete
     */
    where?: tecnologiaWhereInput
  }

  /**
   * tecnologia.habilidades
   */
  export type tecnologia$habilidadesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habilidadeUsuario
     */
    select?: habilidadeUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habilidadeUsuarioInclude<ExtArgs> | null
    where?: habilidadeUsuarioWhereInput
    orderBy?: habilidadeUsuarioOrderByWithRelationInput | habilidadeUsuarioOrderByWithRelationInput[]
    cursor?: habilidadeUsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HabilidadeUsuarioScalarFieldEnum | HabilidadeUsuarioScalarFieldEnum[]
  }

  /**
   * tecnologia.projetos
   */
  export type tecnologia$projetosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoTecnologia
     */
    select?: projetoTecnologiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoTecnologiaInclude<ExtArgs> | null
    where?: projetoTecnologiaWhereInput
    orderBy?: projetoTecnologiaOrderByWithRelationInput | projetoTecnologiaOrderByWithRelationInput[]
    cursor?: projetoTecnologiaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjetoTecnologiaScalarFieldEnum | ProjetoTecnologiaScalarFieldEnum[]
  }

  /**
   * tecnologia without action
   */
  export type tecnologiaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tecnologia
     */
    select?: tecnologiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tecnologiaInclude<ExtArgs> | null
  }


  /**
   * Model tarefa
   */

  export type AggregateTarefa = {
    _count: TarefaCountAggregateOutputType | null
    _avg: TarefaAvgAggregateOutputType | null
    _sum: TarefaSumAggregateOutputType | null
    _min: TarefaMinAggregateOutputType | null
    _max: TarefaMaxAggregateOutputType | null
  }

  export type TarefaAvgAggregateOutputType = {
    tarefa_id: number | null
  }

  export type TarefaSumAggregateOutputType = {
    tarefa_id: number | null
  }

  export type TarefaMinAggregateOutputType = {
    tarefa_id: number | null
    titulo: string | null
    descricao: string | null
    createdAt: Date | null
    doing: Date | null
    concludeAt: Date | null
    colorBar: string | null
  }

  export type TarefaMaxAggregateOutputType = {
    tarefa_id: number | null
    titulo: string | null
    descricao: string | null
    createdAt: Date | null
    doing: Date | null
    concludeAt: Date | null
    colorBar: string | null
  }

  export type TarefaCountAggregateOutputType = {
    tarefa_id: number
    titulo: number
    descricao: number
    createdAt: number
    doing: number
    concludeAt: number
    colorBar: number
    _all: number
  }


  export type TarefaAvgAggregateInputType = {
    tarefa_id?: true
  }

  export type TarefaSumAggregateInputType = {
    tarefa_id?: true
  }

  export type TarefaMinAggregateInputType = {
    tarefa_id?: true
    titulo?: true
    descricao?: true
    createdAt?: true
    doing?: true
    concludeAt?: true
    colorBar?: true
  }

  export type TarefaMaxAggregateInputType = {
    tarefa_id?: true
    titulo?: true
    descricao?: true
    createdAt?: true
    doing?: true
    concludeAt?: true
    colorBar?: true
  }

  export type TarefaCountAggregateInputType = {
    tarefa_id?: true
    titulo?: true
    descricao?: true
    createdAt?: true
    doing?: true
    concludeAt?: true
    colorBar?: true
    _all?: true
  }

  export type TarefaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tarefa to aggregate.
     */
    where?: tarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tarefas to fetch.
     */
    orderBy?: tarefaOrderByWithRelationInput | tarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tarefas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tarefas
    **/
    _count?: true | TarefaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TarefaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TarefaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TarefaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TarefaMaxAggregateInputType
  }

  export type GetTarefaAggregateType<T extends TarefaAggregateArgs> = {
        [P in keyof T & keyof AggregateTarefa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTarefa[P]>
      : GetScalarType<T[P], AggregateTarefa[P]>
  }




  export type tarefaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tarefaWhereInput
    orderBy?: tarefaOrderByWithAggregationInput | tarefaOrderByWithAggregationInput[]
    by: TarefaScalarFieldEnum[] | TarefaScalarFieldEnum
    having?: tarefaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TarefaCountAggregateInputType | true
    _avg?: TarefaAvgAggregateInputType
    _sum?: TarefaSumAggregateInputType
    _min?: TarefaMinAggregateInputType
    _max?: TarefaMaxAggregateInputType
  }

  export type TarefaGroupByOutputType = {
    tarefa_id: number
    titulo: string
    descricao: string
    createdAt: Date
    doing: Date | null
    concludeAt: Date | null
    colorBar: string
    _count: TarefaCountAggregateOutputType | null
    _avg: TarefaAvgAggregateOutputType | null
    _sum: TarefaSumAggregateOutputType | null
    _min: TarefaMinAggregateOutputType | null
    _max: TarefaMaxAggregateOutputType | null
  }

  type GetTarefaGroupByPayload<T extends tarefaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TarefaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TarefaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TarefaGroupByOutputType[P]>
            : GetScalarType<T[P], TarefaGroupByOutputType[P]>
        }
      >
    >


  export type tarefaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tarefa_id?: boolean
    titulo?: boolean
    descricao?: boolean
    createdAt?: boolean
    doing?: boolean
    concludeAt?: boolean
    colorBar?: boolean
    participacoes?: boolean | tarefa$participacoesArgs<ExtArgs>
    anexos?: boolean | tarefa$anexosArgs<ExtArgs>
    pausas?: boolean | tarefa$pausasArgs<ExtArgs>
    _count?: boolean | TarefaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tarefa"]>

  export type tarefaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tarefa_id?: boolean
    titulo?: boolean
    descricao?: boolean
    createdAt?: boolean
    doing?: boolean
    concludeAt?: boolean
    colorBar?: boolean
  }, ExtArgs["result"]["tarefa"]>

  export type tarefaSelectScalar = {
    tarefa_id?: boolean
    titulo?: boolean
    descricao?: boolean
    createdAt?: boolean
    doing?: boolean
    concludeAt?: boolean
    colorBar?: boolean
  }

  export type tarefaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participacoes?: boolean | tarefa$participacoesArgs<ExtArgs>
    anexos?: boolean | tarefa$anexosArgs<ExtArgs>
    pausas?: boolean | tarefa$pausasArgs<ExtArgs>
    _count?: boolean | TarefaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tarefaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $tarefaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tarefa"
    objects: {
      participacoes: Prisma.$participacaoTarefaPayload<ExtArgs>[]
      anexos: Prisma.$anexoTarefaPayload<ExtArgs>[]
      pausas: Prisma.$pausaTarefaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      tarefa_id: number
      titulo: string
      descricao: string
      createdAt: Date
      doing: Date | null
      concludeAt: Date | null
      colorBar: string
    }, ExtArgs["result"]["tarefa"]>
    composites: {}
  }

  type tarefaGetPayload<S extends boolean | null | undefined | tarefaDefaultArgs> = $Result.GetResult<Prisma.$tarefaPayload, S>

  type tarefaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tarefaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TarefaCountAggregateInputType | true
    }

  export interface tarefaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tarefa'], meta: { name: 'tarefa' } }
    /**
     * Find zero or one Tarefa that matches the filter.
     * @param {tarefaFindUniqueArgs} args - Arguments to find a Tarefa
     * @example
     * // Get one Tarefa
     * const tarefa = await prisma.tarefa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tarefaFindUniqueArgs>(args: SelectSubset<T, tarefaFindUniqueArgs<ExtArgs>>): Prisma__tarefaClient<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tarefa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tarefaFindUniqueOrThrowArgs} args - Arguments to find a Tarefa
     * @example
     * // Get one Tarefa
     * const tarefa = await prisma.tarefa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tarefaFindUniqueOrThrowArgs>(args: SelectSubset<T, tarefaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tarefaClient<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tarefa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tarefaFindFirstArgs} args - Arguments to find a Tarefa
     * @example
     * // Get one Tarefa
     * const tarefa = await prisma.tarefa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tarefaFindFirstArgs>(args?: SelectSubset<T, tarefaFindFirstArgs<ExtArgs>>): Prisma__tarefaClient<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tarefa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tarefaFindFirstOrThrowArgs} args - Arguments to find a Tarefa
     * @example
     * // Get one Tarefa
     * const tarefa = await prisma.tarefa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tarefaFindFirstOrThrowArgs>(args?: SelectSubset<T, tarefaFindFirstOrThrowArgs<ExtArgs>>): Prisma__tarefaClient<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tarefas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tarefaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tarefas
     * const tarefas = await prisma.tarefa.findMany()
     * 
     * // Get first 10 Tarefas
     * const tarefas = await prisma.tarefa.findMany({ take: 10 })
     * 
     * // Only select the `tarefa_id`
     * const tarefaWithTarefa_idOnly = await prisma.tarefa.findMany({ select: { tarefa_id: true } })
     * 
     */
    findMany<T extends tarefaFindManyArgs>(args?: SelectSubset<T, tarefaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tarefa.
     * @param {tarefaCreateArgs} args - Arguments to create a Tarefa.
     * @example
     * // Create one Tarefa
     * const Tarefa = await prisma.tarefa.create({
     *   data: {
     *     // ... data to create a Tarefa
     *   }
     * })
     * 
     */
    create<T extends tarefaCreateArgs>(args: SelectSubset<T, tarefaCreateArgs<ExtArgs>>): Prisma__tarefaClient<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tarefas.
     * @param {tarefaCreateManyArgs} args - Arguments to create many Tarefas.
     * @example
     * // Create many Tarefas
     * const tarefa = await prisma.tarefa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tarefaCreateManyArgs>(args?: SelectSubset<T, tarefaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tarefas and returns the data saved in the database.
     * @param {tarefaCreateManyAndReturnArgs} args - Arguments to create many Tarefas.
     * @example
     * // Create many Tarefas
     * const tarefa = await prisma.tarefa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tarefas and only return the `tarefa_id`
     * const tarefaWithTarefa_idOnly = await prisma.tarefa.createManyAndReturn({ 
     *   select: { tarefa_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tarefaCreateManyAndReturnArgs>(args?: SelectSubset<T, tarefaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tarefa.
     * @param {tarefaDeleteArgs} args - Arguments to delete one Tarefa.
     * @example
     * // Delete one Tarefa
     * const Tarefa = await prisma.tarefa.delete({
     *   where: {
     *     // ... filter to delete one Tarefa
     *   }
     * })
     * 
     */
    delete<T extends tarefaDeleteArgs>(args: SelectSubset<T, tarefaDeleteArgs<ExtArgs>>): Prisma__tarefaClient<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tarefa.
     * @param {tarefaUpdateArgs} args - Arguments to update one Tarefa.
     * @example
     * // Update one Tarefa
     * const tarefa = await prisma.tarefa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tarefaUpdateArgs>(args: SelectSubset<T, tarefaUpdateArgs<ExtArgs>>): Prisma__tarefaClient<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tarefas.
     * @param {tarefaDeleteManyArgs} args - Arguments to filter Tarefas to delete.
     * @example
     * // Delete a few Tarefas
     * const { count } = await prisma.tarefa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tarefaDeleteManyArgs>(args?: SelectSubset<T, tarefaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tarefas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tarefaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tarefas
     * const tarefa = await prisma.tarefa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tarefaUpdateManyArgs>(args: SelectSubset<T, tarefaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tarefa.
     * @param {tarefaUpsertArgs} args - Arguments to update or create a Tarefa.
     * @example
     * // Update or create a Tarefa
     * const tarefa = await prisma.tarefa.upsert({
     *   create: {
     *     // ... data to create a Tarefa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tarefa we want to update
     *   }
     * })
     */
    upsert<T extends tarefaUpsertArgs>(args: SelectSubset<T, tarefaUpsertArgs<ExtArgs>>): Prisma__tarefaClient<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tarefas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tarefaCountArgs} args - Arguments to filter Tarefas to count.
     * @example
     * // Count the number of Tarefas
     * const count = await prisma.tarefa.count({
     *   where: {
     *     // ... the filter for the Tarefas we want to count
     *   }
     * })
    **/
    count<T extends tarefaCountArgs>(
      args?: Subset<T, tarefaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TarefaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tarefa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarefaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TarefaAggregateArgs>(args: Subset<T, TarefaAggregateArgs>): Prisma.PrismaPromise<GetTarefaAggregateType<T>>

    /**
     * Group by Tarefa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tarefaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tarefaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tarefaGroupByArgs['orderBy'] }
        : { orderBy?: tarefaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tarefaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTarefaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tarefa model
   */
  readonly fields: tarefaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tarefa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tarefaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participacoes<T extends tarefa$participacoesArgs<ExtArgs> = {}>(args?: Subset<T, tarefa$participacoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$participacaoTarefaPayload<ExtArgs>, T, "findMany"> | Null>
    anexos<T extends tarefa$anexosArgs<ExtArgs> = {}>(args?: Subset<T, tarefa$anexosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$anexoTarefaPayload<ExtArgs>, T, "findMany"> | Null>
    pausas<T extends tarefa$pausasArgs<ExtArgs> = {}>(args?: Subset<T, tarefa$pausasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pausaTarefaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tarefa model
   */ 
  interface tarefaFieldRefs {
    readonly tarefa_id: FieldRef<"tarefa", 'Int'>
    readonly titulo: FieldRef<"tarefa", 'String'>
    readonly descricao: FieldRef<"tarefa", 'String'>
    readonly createdAt: FieldRef<"tarefa", 'DateTime'>
    readonly doing: FieldRef<"tarefa", 'DateTime'>
    readonly concludeAt: FieldRef<"tarefa", 'DateTime'>
    readonly colorBar: FieldRef<"tarefa", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tarefa findUnique
   */
  export type tarefaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null
    /**
     * Filter, which tarefa to fetch.
     */
    where: tarefaWhereUniqueInput
  }

  /**
   * tarefa findUniqueOrThrow
   */
  export type tarefaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null
    /**
     * Filter, which tarefa to fetch.
     */
    where: tarefaWhereUniqueInput
  }

  /**
   * tarefa findFirst
   */
  export type tarefaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null
    /**
     * Filter, which tarefa to fetch.
     */
    where?: tarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tarefas to fetch.
     */
    orderBy?: tarefaOrderByWithRelationInput | tarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tarefas.
     */
    cursor?: tarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tarefas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tarefas.
     */
    distinct?: TarefaScalarFieldEnum | TarefaScalarFieldEnum[]
  }

  /**
   * tarefa findFirstOrThrow
   */
  export type tarefaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null
    /**
     * Filter, which tarefa to fetch.
     */
    where?: tarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tarefas to fetch.
     */
    orderBy?: tarefaOrderByWithRelationInput | tarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tarefas.
     */
    cursor?: tarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tarefas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tarefas.
     */
    distinct?: TarefaScalarFieldEnum | TarefaScalarFieldEnum[]
  }

  /**
   * tarefa findMany
   */
  export type tarefaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null
    /**
     * Filter, which tarefas to fetch.
     */
    where?: tarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tarefas to fetch.
     */
    orderBy?: tarefaOrderByWithRelationInput | tarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tarefas.
     */
    cursor?: tarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tarefas.
     */
    skip?: number
    distinct?: TarefaScalarFieldEnum | TarefaScalarFieldEnum[]
  }

  /**
   * tarefa create
   */
  export type tarefaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null
    /**
     * The data needed to create a tarefa.
     */
    data: XOR<tarefaCreateInput, tarefaUncheckedCreateInput>
  }

  /**
   * tarefa createMany
   */
  export type tarefaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tarefas.
     */
    data: tarefaCreateManyInput | tarefaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tarefa createManyAndReturn
   */
  export type tarefaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many tarefas.
     */
    data: tarefaCreateManyInput | tarefaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tarefa update
   */
  export type tarefaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null
    /**
     * The data needed to update a tarefa.
     */
    data: XOR<tarefaUpdateInput, tarefaUncheckedUpdateInput>
    /**
     * Choose, which tarefa to update.
     */
    where: tarefaWhereUniqueInput
  }

  /**
   * tarefa updateMany
   */
  export type tarefaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tarefas.
     */
    data: XOR<tarefaUpdateManyMutationInput, tarefaUncheckedUpdateManyInput>
    /**
     * Filter which tarefas to update
     */
    where?: tarefaWhereInput
  }

  /**
   * tarefa upsert
   */
  export type tarefaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null
    /**
     * The filter to search for the tarefa to update in case it exists.
     */
    where: tarefaWhereUniqueInput
    /**
     * In case the tarefa found by the `where` argument doesn't exist, create a new tarefa with this data.
     */
    create: XOR<tarefaCreateInput, tarefaUncheckedCreateInput>
    /**
     * In case the tarefa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tarefaUpdateInput, tarefaUncheckedUpdateInput>
  }

  /**
   * tarefa delete
   */
  export type tarefaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null
    /**
     * Filter which tarefa to delete.
     */
    where: tarefaWhereUniqueInput
  }

  /**
   * tarefa deleteMany
   */
  export type tarefaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tarefas to delete
     */
    where?: tarefaWhereInput
  }

  /**
   * tarefa.participacoes
   */
  export type tarefa$participacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the participacaoTarefa
     */
    select?: participacaoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: participacaoTarefaInclude<ExtArgs> | null
    where?: participacaoTarefaWhereInput
    orderBy?: participacaoTarefaOrderByWithRelationInput | participacaoTarefaOrderByWithRelationInput[]
    cursor?: participacaoTarefaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParticipacaoTarefaScalarFieldEnum | ParticipacaoTarefaScalarFieldEnum[]
  }

  /**
   * tarefa.anexos
   */
  export type tarefa$anexosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoTarefa
     */
    select?: anexoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoTarefaInclude<ExtArgs> | null
    where?: anexoTarefaWhereInput
    orderBy?: anexoTarefaOrderByWithRelationInput | anexoTarefaOrderByWithRelationInput[]
    cursor?: anexoTarefaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnexoTarefaScalarFieldEnum | AnexoTarefaScalarFieldEnum[]
  }

  /**
   * tarefa.pausas
   */
  export type tarefa$pausasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pausaTarefa
     */
    select?: pausaTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pausaTarefaInclude<ExtArgs> | null
    where?: pausaTarefaWhereInput
    orderBy?: pausaTarefaOrderByWithRelationInput | pausaTarefaOrderByWithRelationInput[]
    cursor?: pausaTarefaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PausaTarefaScalarFieldEnum | PausaTarefaScalarFieldEnum[]
  }

  /**
   * tarefa without action
   */
  export type tarefaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null
  }


  /**
   * Model projetoUsuario
   */

  export type AggregateProjetoUsuario = {
    _count: ProjetoUsuarioCountAggregateOutputType | null
    _avg: ProjetoUsuarioAvgAggregateOutputType | null
    _sum: ProjetoUsuarioSumAggregateOutputType | null
    _min: ProjetoUsuarioMinAggregateOutputType | null
    _max: ProjetoUsuarioMaxAggregateOutputType | null
  }

  export type ProjetoUsuarioAvgAggregateOutputType = {
    projetoUsuario_id: number | null
    projeto_id: number | null
    usuario_id: number | null
  }

  export type ProjetoUsuarioSumAggregateOutputType = {
    projetoUsuario_id: number | null
    projeto_id: number | null
    usuario_id: number | null
  }

  export type ProjetoUsuarioMinAggregateOutputType = {
    projetoUsuario_id: number | null
    projeto_id: number | null
    usuario_id: number | null
    owner: boolean | null
  }

  export type ProjetoUsuarioMaxAggregateOutputType = {
    projetoUsuario_id: number | null
    projeto_id: number | null
    usuario_id: number | null
    owner: boolean | null
  }

  export type ProjetoUsuarioCountAggregateOutputType = {
    projetoUsuario_id: number
    projeto_id: number
    usuario_id: number
    owner: number
    _all: number
  }


  export type ProjetoUsuarioAvgAggregateInputType = {
    projetoUsuario_id?: true
    projeto_id?: true
    usuario_id?: true
  }

  export type ProjetoUsuarioSumAggregateInputType = {
    projetoUsuario_id?: true
    projeto_id?: true
    usuario_id?: true
  }

  export type ProjetoUsuarioMinAggregateInputType = {
    projetoUsuario_id?: true
    projeto_id?: true
    usuario_id?: true
    owner?: true
  }

  export type ProjetoUsuarioMaxAggregateInputType = {
    projetoUsuario_id?: true
    projeto_id?: true
    usuario_id?: true
    owner?: true
  }

  export type ProjetoUsuarioCountAggregateInputType = {
    projetoUsuario_id?: true
    projeto_id?: true
    usuario_id?: true
    owner?: true
    _all?: true
  }

  export type ProjetoUsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projetoUsuario to aggregate.
     */
    where?: projetoUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projetoUsuarios to fetch.
     */
    orderBy?: projetoUsuarioOrderByWithRelationInput | projetoUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: projetoUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projetoUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projetoUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned projetoUsuarios
    **/
    _count?: true | ProjetoUsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjetoUsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjetoUsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjetoUsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjetoUsuarioMaxAggregateInputType
  }

  export type GetProjetoUsuarioAggregateType<T extends ProjetoUsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateProjetoUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjetoUsuario[P]>
      : GetScalarType<T[P], AggregateProjetoUsuario[P]>
  }




  export type projetoUsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projetoUsuarioWhereInput
    orderBy?: projetoUsuarioOrderByWithAggregationInput | projetoUsuarioOrderByWithAggregationInput[]
    by: ProjetoUsuarioScalarFieldEnum[] | ProjetoUsuarioScalarFieldEnum
    having?: projetoUsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjetoUsuarioCountAggregateInputType | true
    _avg?: ProjetoUsuarioAvgAggregateInputType
    _sum?: ProjetoUsuarioSumAggregateInputType
    _min?: ProjetoUsuarioMinAggregateInputType
    _max?: ProjetoUsuarioMaxAggregateInputType
  }

  export type ProjetoUsuarioGroupByOutputType = {
    projetoUsuario_id: number
    projeto_id: number
    usuario_id: number
    owner: boolean
    _count: ProjetoUsuarioCountAggregateOutputType | null
    _avg: ProjetoUsuarioAvgAggregateOutputType | null
    _sum: ProjetoUsuarioSumAggregateOutputType | null
    _min: ProjetoUsuarioMinAggregateOutputType | null
    _max: ProjetoUsuarioMaxAggregateOutputType | null
  }

  type GetProjetoUsuarioGroupByPayload<T extends projetoUsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjetoUsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjetoUsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjetoUsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], ProjetoUsuarioGroupByOutputType[P]>
        }
      >
    >


  export type projetoUsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projetoUsuario_id?: boolean
    projeto_id?: boolean
    usuario_id?: boolean
    owner?: boolean
    projeto?: boolean | projetoDefaultArgs<ExtArgs>
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
    participacoes?: boolean | projetoUsuario$participacoesArgs<ExtArgs>
    _count?: boolean | ProjetoUsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projetoUsuario"]>

  export type projetoUsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projetoUsuario_id?: boolean
    projeto_id?: boolean
    usuario_id?: boolean
    owner?: boolean
    projeto?: boolean | projetoDefaultArgs<ExtArgs>
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projetoUsuario"]>

  export type projetoUsuarioSelectScalar = {
    projetoUsuario_id?: boolean
    projeto_id?: boolean
    usuario_id?: boolean
    owner?: boolean
  }

  export type projetoUsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | projetoDefaultArgs<ExtArgs>
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
    participacoes?: boolean | projetoUsuario$participacoesArgs<ExtArgs>
    _count?: boolean | ProjetoUsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type projetoUsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | projetoDefaultArgs<ExtArgs>
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
  }

  export type $projetoUsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "projetoUsuario"
    objects: {
      projeto: Prisma.$projetoPayload<ExtArgs>
      usuario: Prisma.$usuarioPayload<ExtArgs>
      participacoes: Prisma.$participacaoTarefaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      projetoUsuario_id: number
      projeto_id: number
      usuario_id: number
      owner: boolean
    }, ExtArgs["result"]["projetoUsuario"]>
    composites: {}
  }

  type projetoUsuarioGetPayload<S extends boolean | null | undefined | projetoUsuarioDefaultArgs> = $Result.GetResult<Prisma.$projetoUsuarioPayload, S>

  type projetoUsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<projetoUsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjetoUsuarioCountAggregateInputType | true
    }

  export interface projetoUsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['projetoUsuario'], meta: { name: 'projetoUsuario' } }
    /**
     * Find zero or one ProjetoUsuario that matches the filter.
     * @param {projetoUsuarioFindUniqueArgs} args - Arguments to find a ProjetoUsuario
     * @example
     * // Get one ProjetoUsuario
     * const projetoUsuario = await prisma.projetoUsuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends projetoUsuarioFindUniqueArgs>(args: SelectSubset<T, projetoUsuarioFindUniqueArgs<ExtArgs>>): Prisma__projetoUsuarioClient<$Result.GetResult<Prisma.$projetoUsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjetoUsuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {projetoUsuarioFindUniqueOrThrowArgs} args - Arguments to find a ProjetoUsuario
     * @example
     * // Get one ProjetoUsuario
     * const projetoUsuario = await prisma.projetoUsuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends projetoUsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, projetoUsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__projetoUsuarioClient<$Result.GetResult<Prisma.$projetoUsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjetoUsuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoUsuarioFindFirstArgs} args - Arguments to find a ProjetoUsuario
     * @example
     * // Get one ProjetoUsuario
     * const projetoUsuario = await prisma.projetoUsuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends projetoUsuarioFindFirstArgs>(args?: SelectSubset<T, projetoUsuarioFindFirstArgs<ExtArgs>>): Prisma__projetoUsuarioClient<$Result.GetResult<Prisma.$projetoUsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjetoUsuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoUsuarioFindFirstOrThrowArgs} args - Arguments to find a ProjetoUsuario
     * @example
     * // Get one ProjetoUsuario
     * const projetoUsuario = await prisma.projetoUsuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends projetoUsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, projetoUsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__projetoUsuarioClient<$Result.GetResult<Prisma.$projetoUsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjetoUsuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoUsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjetoUsuarios
     * const projetoUsuarios = await prisma.projetoUsuario.findMany()
     * 
     * // Get first 10 ProjetoUsuarios
     * const projetoUsuarios = await prisma.projetoUsuario.findMany({ take: 10 })
     * 
     * // Only select the `projetoUsuario_id`
     * const projetoUsuarioWithProjetoUsuario_idOnly = await prisma.projetoUsuario.findMany({ select: { projetoUsuario_id: true } })
     * 
     */
    findMany<T extends projetoUsuarioFindManyArgs>(args?: SelectSubset<T, projetoUsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projetoUsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjetoUsuario.
     * @param {projetoUsuarioCreateArgs} args - Arguments to create a ProjetoUsuario.
     * @example
     * // Create one ProjetoUsuario
     * const ProjetoUsuario = await prisma.projetoUsuario.create({
     *   data: {
     *     // ... data to create a ProjetoUsuario
     *   }
     * })
     * 
     */
    create<T extends projetoUsuarioCreateArgs>(args: SelectSubset<T, projetoUsuarioCreateArgs<ExtArgs>>): Prisma__projetoUsuarioClient<$Result.GetResult<Prisma.$projetoUsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjetoUsuarios.
     * @param {projetoUsuarioCreateManyArgs} args - Arguments to create many ProjetoUsuarios.
     * @example
     * // Create many ProjetoUsuarios
     * const projetoUsuario = await prisma.projetoUsuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends projetoUsuarioCreateManyArgs>(args?: SelectSubset<T, projetoUsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjetoUsuarios and returns the data saved in the database.
     * @param {projetoUsuarioCreateManyAndReturnArgs} args - Arguments to create many ProjetoUsuarios.
     * @example
     * // Create many ProjetoUsuarios
     * const projetoUsuario = await prisma.projetoUsuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjetoUsuarios and only return the `projetoUsuario_id`
     * const projetoUsuarioWithProjetoUsuario_idOnly = await prisma.projetoUsuario.createManyAndReturn({ 
     *   select: { projetoUsuario_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends projetoUsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, projetoUsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projetoUsuarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjetoUsuario.
     * @param {projetoUsuarioDeleteArgs} args - Arguments to delete one ProjetoUsuario.
     * @example
     * // Delete one ProjetoUsuario
     * const ProjetoUsuario = await prisma.projetoUsuario.delete({
     *   where: {
     *     // ... filter to delete one ProjetoUsuario
     *   }
     * })
     * 
     */
    delete<T extends projetoUsuarioDeleteArgs>(args: SelectSubset<T, projetoUsuarioDeleteArgs<ExtArgs>>): Prisma__projetoUsuarioClient<$Result.GetResult<Prisma.$projetoUsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjetoUsuario.
     * @param {projetoUsuarioUpdateArgs} args - Arguments to update one ProjetoUsuario.
     * @example
     * // Update one ProjetoUsuario
     * const projetoUsuario = await prisma.projetoUsuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends projetoUsuarioUpdateArgs>(args: SelectSubset<T, projetoUsuarioUpdateArgs<ExtArgs>>): Prisma__projetoUsuarioClient<$Result.GetResult<Prisma.$projetoUsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjetoUsuarios.
     * @param {projetoUsuarioDeleteManyArgs} args - Arguments to filter ProjetoUsuarios to delete.
     * @example
     * // Delete a few ProjetoUsuarios
     * const { count } = await prisma.projetoUsuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends projetoUsuarioDeleteManyArgs>(args?: SelectSubset<T, projetoUsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjetoUsuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoUsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjetoUsuarios
     * const projetoUsuario = await prisma.projetoUsuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends projetoUsuarioUpdateManyArgs>(args: SelectSubset<T, projetoUsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjetoUsuario.
     * @param {projetoUsuarioUpsertArgs} args - Arguments to update or create a ProjetoUsuario.
     * @example
     * // Update or create a ProjetoUsuario
     * const projetoUsuario = await prisma.projetoUsuario.upsert({
     *   create: {
     *     // ... data to create a ProjetoUsuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjetoUsuario we want to update
     *   }
     * })
     */
    upsert<T extends projetoUsuarioUpsertArgs>(args: SelectSubset<T, projetoUsuarioUpsertArgs<ExtArgs>>): Prisma__projetoUsuarioClient<$Result.GetResult<Prisma.$projetoUsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjetoUsuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoUsuarioCountArgs} args - Arguments to filter ProjetoUsuarios to count.
     * @example
     * // Count the number of ProjetoUsuarios
     * const count = await prisma.projetoUsuario.count({
     *   where: {
     *     // ... the filter for the ProjetoUsuarios we want to count
     *   }
     * })
    **/
    count<T extends projetoUsuarioCountArgs>(
      args?: Subset<T, projetoUsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjetoUsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjetoUsuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjetoUsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjetoUsuarioAggregateArgs>(args: Subset<T, ProjetoUsuarioAggregateArgs>): Prisma.PrismaPromise<GetProjetoUsuarioAggregateType<T>>

    /**
     * Group by ProjetoUsuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoUsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends projetoUsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: projetoUsuarioGroupByArgs['orderBy'] }
        : { orderBy?: projetoUsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, projetoUsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjetoUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the projetoUsuario model
   */
  readonly fields: projetoUsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for projetoUsuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__projetoUsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projeto<T extends projetoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projetoDefaultArgs<ExtArgs>>): Prisma__projetoClient<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    usuario<T extends usuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuarioDefaultArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    participacoes<T extends projetoUsuario$participacoesArgs<ExtArgs> = {}>(args?: Subset<T, projetoUsuario$participacoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$participacaoTarefaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the projetoUsuario model
   */ 
  interface projetoUsuarioFieldRefs {
    readonly projetoUsuario_id: FieldRef<"projetoUsuario", 'Int'>
    readonly projeto_id: FieldRef<"projetoUsuario", 'Int'>
    readonly usuario_id: FieldRef<"projetoUsuario", 'Int'>
    readonly owner: FieldRef<"projetoUsuario", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * projetoUsuario findUnique
   */
  export type projetoUsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoUsuario
     */
    select?: projetoUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which projetoUsuario to fetch.
     */
    where: projetoUsuarioWhereUniqueInput
  }

  /**
   * projetoUsuario findUniqueOrThrow
   */
  export type projetoUsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoUsuario
     */
    select?: projetoUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which projetoUsuario to fetch.
     */
    where: projetoUsuarioWhereUniqueInput
  }

  /**
   * projetoUsuario findFirst
   */
  export type projetoUsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoUsuario
     */
    select?: projetoUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which projetoUsuario to fetch.
     */
    where?: projetoUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projetoUsuarios to fetch.
     */
    orderBy?: projetoUsuarioOrderByWithRelationInput | projetoUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projetoUsuarios.
     */
    cursor?: projetoUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projetoUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projetoUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projetoUsuarios.
     */
    distinct?: ProjetoUsuarioScalarFieldEnum | ProjetoUsuarioScalarFieldEnum[]
  }

  /**
   * projetoUsuario findFirstOrThrow
   */
  export type projetoUsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoUsuario
     */
    select?: projetoUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which projetoUsuario to fetch.
     */
    where?: projetoUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projetoUsuarios to fetch.
     */
    orderBy?: projetoUsuarioOrderByWithRelationInput | projetoUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projetoUsuarios.
     */
    cursor?: projetoUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projetoUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projetoUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projetoUsuarios.
     */
    distinct?: ProjetoUsuarioScalarFieldEnum | ProjetoUsuarioScalarFieldEnum[]
  }

  /**
   * projetoUsuario findMany
   */
  export type projetoUsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoUsuario
     */
    select?: projetoUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which projetoUsuarios to fetch.
     */
    where?: projetoUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projetoUsuarios to fetch.
     */
    orderBy?: projetoUsuarioOrderByWithRelationInput | projetoUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing projetoUsuarios.
     */
    cursor?: projetoUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projetoUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projetoUsuarios.
     */
    skip?: number
    distinct?: ProjetoUsuarioScalarFieldEnum | ProjetoUsuarioScalarFieldEnum[]
  }

  /**
   * projetoUsuario create
   */
  export type projetoUsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoUsuario
     */
    select?: projetoUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoUsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a projetoUsuario.
     */
    data: XOR<projetoUsuarioCreateInput, projetoUsuarioUncheckedCreateInput>
  }

  /**
   * projetoUsuario createMany
   */
  export type projetoUsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many projetoUsuarios.
     */
    data: projetoUsuarioCreateManyInput | projetoUsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * projetoUsuario createManyAndReturn
   */
  export type projetoUsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoUsuario
     */
    select?: projetoUsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many projetoUsuarios.
     */
    data: projetoUsuarioCreateManyInput | projetoUsuarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoUsuarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * projetoUsuario update
   */
  export type projetoUsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoUsuario
     */
    select?: projetoUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoUsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a projetoUsuario.
     */
    data: XOR<projetoUsuarioUpdateInput, projetoUsuarioUncheckedUpdateInput>
    /**
     * Choose, which projetoUsuario to update.
     */
    where: projetoUsuarioWhereUniqueInput
  }

  /**
   * projetoUsuario updateMany
   */
  export type projetoUsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update projetoUsuarios.
     */
    data: XOR<projetoUsuarioUpdateManyMutationInput, projetoUsuarioUncheckedUpdateManyInput>
    /**
     * Filter which projetoUsuarios to update
     */
    where?: projetoUsuarioWhereInput
  }

  /**
   * projetoUsuario upsert
   */
  export type projetoUsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoUsuario
     */
    select?: projetoUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoUsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the projetoUsuario to update in case it exists.
     */
    where: projetoUsuarioWhereUniqueInput
    /**
     * In case the projetoUsuario found by the `where` argument doesn't exist, create a new projetoUsuario with this data.
     */
    create: XOR<projetoUsuarioCreateInput, projetoUsuarioUncheckedCreateInput>
    /**
     * In case the projetoUsuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<projetoUsuarioUpdateInput, projetoUsuarioUncheckedUpdateInput>
  }

  /**
   * projetoUsuario delete
   */
  export type projetoUsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoUsuario
     */
    select?: projetoUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoUsuarioInclude<ExtArgs> | null
    /**
     * Filter which projetoUsuario to delete.
     */
    where: projetoUsuarioWhereUniqueInput
  }

  /**
   * projetoUsuario deleteMany
   */
  export type projetoUsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projetoUsuarios to delete
     */
    where?: projetoUsuarioWhereInput
  }

  /**
   * projetoUsuario.participacoes
   */
  export type projetoUsuario$participacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the participacaoTarefa
     */
    select?: participacaoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: participacaoTarefaInclude<ExtArgs> | null
    where?: participacaoTarefaWhereInput
    orderBy?: participacaoTarefaOrderByWithRelationInput | participacaoTarefaOrderByWithRelationInput[]
    cursor?: participacaoTarefaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParticipacaoTarefaScalarFieldEnum | ParticipacaoTarefaScalarFieldEnum[]
  }

  /**
   * projetoUsuario without action
   */
  export type projetoUsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoUsuario
     */
    select?: projetoUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoUsuarioInclude<ExtArgs> | null
  }


  /**
   * Model projetoTecnologia
   */

  export type AggregateProjetoTecnologia = {
    _count: ProjetoTecnologiaCountAggregateOutputType | null
    _avg: ProjetoTecnologiaAvgAggregateOutputType | null
    _sum: ProjetoTecnologiaSumAggregateOutputType | null
    _min: ProjetoTecnologiaMinAggregateOutputType | null
    _max: ProjetoTecnologiaMaxAggregateOutputType | null
  }

  export type ProjetoTecnologiaAvgAggregateOutputType = {
    projetoTecnologia_id: number | null
    tecnologia_id: number | null
    projeto_id: number | null
  }

  export type ProjetoTecnologiaSumAggregateOutputType = {
    projetoTecnologia_id: number | null
    tecnologia_id: number | null
    projeto_id: number | null
  }

  export type ProjetoTecnologiaMinAggregateOutputType = {
    projetoTecnologia_id: number | null
    tecnologia_id: number | null
    projeto_id: number | null
  }

  export type ProjetoTecnologiaMaxAggregateOutputType = {
    projetoTecnologia_id: number | null
    tecnologia_id: number | null
    projeto_id: number | null
  }

  export type ProjetoTecnologiaCountAggregateOutputType = {
    projetoTecnologia_id: number
    tecnologia_id: number
    projeto_id: number
    _all: number
  }


  export type ProjetoTecnologiaAvgAggregateInputType = {
    projetoTecnologia_id?: true
    tecnologia_id?: true
    projeto_id?: true
  }

  export type ProjetoTecnologiaSumAggregateInputType = {
    projetoTecnologia_id?: true
    tecnologia_id?: true
    projeto_id?: true
  }

  export type ProjetoTecnologiaMinAggregateInputType = {
    projetoTecnologia_id?: true
    tecnologia_id?: true
    projeto_id?: true
  }

  export type ProjetoTecnologiaMaxAggregateInputType = {
    projetoTecnologia_id?: true
    tecnologia_id?: true
    projeto_id?: true
  }

  export type ProjetoTecnologiaCountAggregateInputType = {
    projetoTecnologia_id?: true
    tecnologia_id?: true
    projeto_id?: true
    _all?: true
  }

  export type ProjetoTecnologiaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projetoTecnologia to aggregate.
     */
    where?: projetoTecnologiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projetoTecnologias to fetch.
     */
    orderBy?: projetoTecnologiaOrderByWithRelationInput | projetoTecnologiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: projetoTecnologiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projetoTecnologias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projetoTecnologias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned projetoTecnologias
    **/
    _count?: true | ProjetoTecnologiaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjetoTecnologiaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjetoTecnologiaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjetoTecnologiaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjetoTecnologiaMaxAggregateInputType
  }

  export type GetProjetoTecnologiaAggregateType<T extends ProjetoTecnologiaAggregateArgs> = {
        [P in keyof T & keyof AggregateProjetoTecnologia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjetoTecnologia[P]>
      : GetScalarType<T[P], AggregateProjetoTecnologia[P]>
  }




  export type projetoTecnologiaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projetoTecnologiaWhereInput
    orderBy?: projetoTecnologiaOrderByWithAggregationInput | projetoTecnologiaOrderByWithAggregationInput[]
    by: ProjetoTecnologiaScalarFieldEnum[] | ProjetoTecnologiaScalarFieldEnum
    having?: projetoTecnologiaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjetoTecnologiaCountAggregateInputType | true
    _avg?: ProjetoTecnologiaAvgAggregateInputType
    _sum?: ProjetoTecnologiaSumAggregateInputType
    _min?: ProjetoTecnologiaMinAggregateInputType
    _max?: ProjetoTecnologiaMaxAggregateInputType
  }

  export type ProjetoTecnologiaGroupByOutputType = {
    projetoTecnologia_id: number
    tecnologia_id: number
    projeto_id: number
    _count: ProjetoTecnologiaCountAggregateOutputType | null
    _avg: ProjetoTecnologiaAvgAggregateOutputType | null
    _sum: ProjetoTecnologiaSumAggregateOutputType | null
    _min: ProjetoTecnologiaMinAggregateOutputType | null
    _max: ProjetoTecnologiaMaxAggregateOutputType | null
  }

  type GetProjetoTecnologiaGroupByPayload<T extends projetoTecnologiaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjetoTecnologiaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjetoTecnologiaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjetoTecnologiaGroupByOutputType[P]>
            : GetScalarType<T[P], ProjetoTecnologiaGroupByOutputType[P]>
        }
      >
    >


  export type projetoTecnologiaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projetoTecnologia_id?: boolean
    tecnologia_id?: boolean
    projeto_id?: boolean
    projeto?: boolean | projetoDefaultArgs<ExtArgs>
    tecnologia?: boolean | tecnologiaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projetoTecnologia"]>

  export type projetoTecnologiaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    projetoTecnologia_id?: boolean
    tecnologia_id?: boolean
    projeto_id?: boolean
    projeto?: boolean | projetoDefaultArgs<ExtArgs>
    tecnologia?: boolean | tecnologiaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projetoTecnologia"]>

  export type projetoTecnologiaSelectScalar = {
    projetoTecnologia_id?: boolean
    tecnologia_id?: boolean
    projeto_id?: boolean
  }

  export type projetoTecnologiaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | projetoDefaultArgs<ExtArgs>
    tecnologia?: boolean | tecnologiaDefaultArgs<ExtArgs>
  }
  export type projetoTecnologiaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | projetoDefaultArgs<ExtArgs>
    tecnologia?: boolean | tecnologiaDefaultArgs<ExtArgs>
  }

  export type $projetoTecnologiaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "projetoTecnologia"
    objects: {
      projeto: Prisma.$projetoPayload<ExtArgs>
      tecnologia: Prisma.$tecnologiaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      projetoTecnologia_id: number
      tecnologia_id: number
      projeto_id: number
    }, ExtArgs["result"]["projetoTecnologia"]>
    composites: {}
  }

  type projetoTecnologiaGetPayload<S extends boolean | null | undefined | projetoTecnologiaDefaultArgs> = $Result.GetResult<Prisma.$projetoTecnologiaPayload, S>

  type projetoTecnologiaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<projetoTecnologiaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjetoTecnologiaCountAggregateInputType | true
    }

  export interface projetoTecnologiaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['projetoTecnologia'], meta: { name: 'projetoTecnologia' } }
    /**
     * Find zero or one ProjetoTecnologia that matches the filter.
     * @param {projetoTecnologiaFindUniqueArgs} args - Arguments to find a ProjetoTecnologia
     * @example
     * // Get one ProjetoTecnologia
     * const projetoTecnologia = await prisma.projetoTecnologia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends projetoTecnologiaFindUniqueArgs>(args: SelectSubset<T, projetoTecnologiaFindUniqueArgs<ExtArgs>>): Prisma__projetoTecnologiaClient<$Result.GetResult<Prisma.$projetoTecnologiaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjetoTecnologia that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {projetoTecnologiaFindUniqueOrThrowArgs} args - Arguments to find a ProjetoTecnologia
     * @example
     * // Get one ProjetoTecnologia
     * const projetoTecnologia = await prisma.projetoTecnologia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends projetoTecnologiaFindUniqueOrThrowArgs>(args: SelectSubset<T, projetoTecnologiaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__projetoTecnologiaClient<$Result.GetResult<Prisma.$projetoTecnologiaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjetoTecnologia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoTecnologiaFindFirstArgs} args - Arguments to find a ProjetoTecnologia
     * @example
     * // Get one ProjetoTecnologia
     * const projetoTecnologia = await prisma.projetoTecnologia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends projetoTecnologiaFindFirstArgs>(args?: SelectSubset<T, projetoTecnologiaFindFirstArgs<ExtArgs>>): Prisma__projetoTecnologiaClient<$Result.GetResult<Prisma.$projetoTecnologiaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjetoTecnologia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoTecnologiaFindFirstOrThrowArgs} args - Arguments to find a ProjetoTecnologia
     * @example
     * // Get one ProjetoTecnologia
     * const projetoTecnologia = await prisma.projetoTecnologia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends projetoTecnologiaFindFirstOrThrowArgs>(args?: SelectSubset<T, projetoTecnologiaFindFirstOrThrowArgs<ExtArgs>>): Prisma__projetoTecnologiaClient<$Result.GetResult<Prisma.$projetoTecnologiaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjetoTecnologias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoTecnologiaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjetoTecnologias
     * const projetoTecnologias = await prisma.projetoTecnologia.findMany()
     * 
     * // Get first 10 ProjetoTecnologias
     * const projetoTecnologias = await prisma.projetoTecnologia.findMany({ take: 10 })
     * 
     * // Only select the `projetoTecnologia_id`
     * const projetoTecnologiaWithProjetoTecnologia_idOnly = await prisma.projetoTecnologia.findMany({ select: { projetoTecnologia_id: true } })
     * 
     */
    findMany<T extends projetoTecnologiaFindManyArgs>(args?: SelectSubset<T, projetoTecnologiaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projetoTecnologiaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjetoTecnologia.
     * @param {projetoTecnologiaCreateArgs} args - Arguments to create a ProjetoTecnologia.
     * @example
     * // Create one ProjetoTecnologia
     * const ProjetoTecnologia = await prisma.projetoTecnologia.create({
     *   data: {
     *     // ... data to create a ProjetoTecnologia
     *   }
     * })
     * 
     */
    create<T extends projetoTecnologiaCreateArgs>(args: SelectSubset<T, projetoTecnologiaCreateArgs<ExtArgs>>): Prisma__projetoTecnologiaClient<$Result.GetResult<Prisma.$projetoTecnologiaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjetoTecnologias.
     * @param {projetoTecnologiaCreateManyArgs} args - Arguments to create many ProjetoTecnologias.
     * @example
     * // Create many ProjetoTecnologias
     * const projetoTecnologia = await prisma.projetoTecnologia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends projetoTecnologiaCreateManyArgs>(args?: SelectSubset<T, projetoTecnologiaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjetoTecnologias and returns the data saved in the database.
     * @param {projetoTecnologiaCreateManyAndReturnArgs} args - Arguments to create many ProjetoTecnologias.
     * @example
     * // Create many ProjetoTecnologias
     * const projetoTecnologia = await prisma.projetoTecnologia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjetoTecnologias and only return the `projetoTecnologia_id`
     * const projetoTecnologiaWithProjetoTecnologia_idOnly = await prisma.projetoTecnologia.createManyAndReturn({ 
     *   select: { projetoTecnologia_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends projetoTecnologiaCreateManyAndReturnArgs>(args?: SelectSubset<T, projetoTecnologiaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projetoTecnologiaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProjetoTecnologia.
     * @param {projetoTecnologiaDeleteArgs} args - Arguments to delete one ProjetoTecnologia.
     * @example
     * // Delete one ProjetoTecnologia
     * const ProjetoTecnologia = await prisma.projetoTecnologia.delete({
     *   where: {
     *     // ... filter to delete one ProjetoTecnologia
     *   }
     * })
     * 
     */
    delete<T extends projetoTecnologiaDeleteArgs>(args: SelectSubset<T, projetoTecnologiaDeleteArgs<ExtArgs>>): Prisma__projetoTecnologiaClient<$Result.GetResult<Prisma.$projetoTecnologiaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjetoTecnologia.
     * @param {projetoTecnologiaUpdateArgs} args - Arguments to update one ProjetoTecnologia.
     * @example
     * // Update one ProjetoTecnologia
     * const projetoTecnologia = await prisma.projetoTecnologia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends projetoTecnologiaUpdateArgs>(args: SelectSubset<T, projetoTecnologiaUpdateArgs<ExtArgs>>): Prisma__projetoTecnologiaClient<$Result.GetResult<Prisma.$projetoTecnologiaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjetoTecnologias.
     * @param {projetoTecnologiaDeleteManyArgs} args - Arguments to filter ProjetoTecnologias to delete.
     * @example
     * // Delete a few ProjetoTecnologias
     * const { count } = await prisma.projetoTecnologia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends projetoTecnologiaDeleteManyArgs>(args?: SelectSubset<T, projetoTecnologiaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjetoTecnologias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoTecnologiaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjetoTecnologias
     * const projetoTecnologia = await prisma.projetoTecnologia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends projetoTecnologiaUpdateManyArgs>(args: SelectSubset<T, projetoTecnologiaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjetoTecnologia.
     * @param {projetoTecnologiaUpsertArgs} args - Arguments to update or create a ProjetoTecnologia.
     * @example
     * // Update or create a ProjetoTecnologia
     * const projetoTecnologia = await prisma.projetoTecnologia.upsert({
     *   create: {
     *     // ... data to create a ProjetoTecnologia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjetoTecnologia we want to update
     *   }
     * })
     */
    upsert<T extends projetoTecnologiaUpsertArgs>(args: SelectSubset<T, projetoTecnologiaUpsertArgs<ExtArgs>>): Prisma__projetoTecnologiaClient<$Result.GetResult<Prisma.$projetoTecnologiaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjetoTecnologias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoTecnologiaCountArgs} args - Arguments to filter ProjetoTecnologias to count.
     * @example
     * // Count the number of ProjetoTecnologias
     * const count = await prisma.projetoTecnologia.count({
     *   where: {
     *     // ... the filter for the ProjetoTecnologias we want to count
     *   }
     * })
    **/
    count<T extends projetoTecnologiaCountArgs>(
      args?: Subset<T, projetoTecnologiaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjetoTecnologiaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjetoTecnologia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjetoTecnologiaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjetoTecnologiaAggregateArgs>(args: Subset<T, ProjetoTecnologiaAggregateArgs>): Prisma.PrismaPromise<GetProjetoTecnologiaAggregateType<T>>

    /**
     * Group by ProjetoTecnologia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoTecnologiaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends projetoTecnologiaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: projetoTecnologiaGroupByArgs['orderBy'] }
        : { orderBy?: projetoTecnologiaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, projetoTecnologiaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjetoTecnologiaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the projetoTecnologia model
   */
  readonly fields: projetoTecnologiaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for projetoTecnologia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__projetoTecnologiaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projeto<T extends projetoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projetoDefaultArgs<ExtArgs>>): Prisma__projetoClient<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tecnologia<T extends tecnologiaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tecnologiaDefaultArgs<ExtArgs>>): Prisma__tecnologiaClient<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the projetoTecnologia model
   */ 
  interface projetoTecnologiaFieldRefs {
    readonly projetoTecnologia_id: FieldRef<"projetoTecnologia", 'Int'>
    readonly tecnologia_id: FieldRef<"projetoTecnologia", 'Int'>
    readonly projeto_id: FieldRef<"projetoTecnologia", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * projetoTecnologia findUnique
   */
  export type projetoTecnologiaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoTecnologia
     */
    select?: projetoTecnologiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoTecnologiaInclude<ExtArgs> | null
    /**
     * Filter, which projetoTecnologia to fetch.
     */
    where: projetoTecnologiaWhereUniqueInput
  }

  /**
   * projetoTecnologia findUniqueOrThrow
   */
  export type projetoTecnologiaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoTecnologia
     */
    select?: projetoTecnologiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoTecnologiaInclude<ExtArgs> | null
    /**
     * Filter, which projetoTecnologia to fetch.
     */
    where: projetoTecnologiaWhereUniqueInput
  }

  /**
   * projetoTecnologia findFirst
   */
  export type projetoTecnologiaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoTecnologia
     */
    select?: projetoTecnologiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoTecnologiaInclude<ExtArgs> | null
    /**
     * Filter, which projetoTecnologia to fetch.
     */
    where?: projetoTecnologiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projetoTecnologias to fetch.
     */
    orderBy?: projetoTecnologiaOrderByWithRelationInput | projetoTecnologiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projetoTecnologias.
     */
    cursor?: projetoTecnologiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projetoTecnologias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projetoTecnologias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projetoTecnologias.
     */
    distinct?: ProjetoTecnologiaScalarFieldEnum | ProjetoTecnologiaScalarFieldEnum[]
  }

  /**
   * projetoTecnologia findFirstOrThrow
   */
  export type projetoTecnologiaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoTecnologia
     */
    select?: projetoTecnologiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoTecnologiaInclude<ExtArgs> | null
    /**
     * Filter, which projetoTecnologia to fetch.
     */
    where?: projetoTecnologiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projetoTecnologias to fetch.
     */
    orderBy?: projetoTecnologiaOrderByWithRelationInput | projetoTecnologiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projetoTecnologias.
     */
    cursor?: projetoTecnologiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projetoTecnologias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projetoTecnologias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projetoTecnologias.
     */
    distinct?: ProjetoTecnologiaScalarFieldEnum | ProjetoTecnologiaScalarFieldEnum[]
  }

  /**
   * projetoTecnologia findMany
   */
  export type projetoTecnologiaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoTecnologia
     */
    select?: projetoTecnologiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoTecnologiaInclude<ExtArgs> | null
    /**
     * Filter, which projetoTecnologias to fetch.
     */
    where?: projetoTecnologiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projetoTecnologias to fetch.
     */
    orderBy?: projetoTecnologiaOrderByWithRelationInput | projetoTecnologiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing projetoTecnologias.
     */
    cursor?: projetoTecnologiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projetoTecnologias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projetoTecnologias.
     */
    skip?: number
    distinct?: ProjetoTecnologiaScalarFieldEnum | ProjetoTecnologiaScalarFieldEnum[]
  }

  /**
   * projetoTecnologia create
   */
  export type projetoTecnologiaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoTecnologia
     */
    select?: projetoTecnologiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoTecnologiaInclude<ExtArgs> | null
    /**
     * The data needed to create a projetoTecnologia.
     */
    data: XOR<projetoTecnologiaCreateInput, projetoTecnologiaUncheckedCreateInput>
  }

  /**
   * projetoTecnologia createMany
   */
  export type projetoTecnologiaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many projetoTecnologias.
     */
    data: projetoTecnologiaCreateManyInput | projetoTecnologiaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * projetoTecnologia createManyAndReturn
   */
  export type projetoTecnologiaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoTecnologia
     */
    select?: projetoTecnologiaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many projetoTecnologias.
     */
    data: projetoTecnologiaCreateManyInput | projetoTecnologiaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoTecnologiaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * projetoTecnologia update
   */
  export type projetoTecnologiaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoTecnologia
     */
    select?: projetoTecnologiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoTecnologiaInclude<ExtArgs> | null
    /**
     * The data needed to update a projetoTecnologia.
     */
    data: XOR<projetoTecnologiaUpdateInput, projetoTecnologiaUncheckedUpdateInput>
    /**
     * Choose, which projetoTecnologia to update.
     */
    where: projetoTecnologiaWhereUniqueInput
  }

  /**
   * projetoTecnologia updateMany
   */
  export type projetoTecnologiaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update projetoTecnologias.
     */
    data: XOR<projetoTecnologiaUpdateManyMutationInput, projetoTecnologiaUncheckedUpdateManyInput>
    /**
     * Filter which projetoTecnologias to update
     */
    where?: projetoTecnologiaWhereInput
  }

  /**
   * projetoTecnologia upsert
   */
  export type projetoTecnologiaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoTecnologia
     */
    select?: projetoTecnologiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoTecnologiaInclude<ExtArgs> | null
    /**
     * The filter to search for the projetoTecnologia to update in case it exists.
     */
    where: projetoTecnologiaWhereUniqueInput
    /**
     * In case the projetoTecnologia found by the `where` argument doesn't exist, create a new projetoTecnologia with this data.
     */
    create: XOR<projetoTecnologiaCreateInput, projetoTecnologiaUncheckedCreateInput>
    /**
     * In case the projetoTecnologia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<projetoTecnologiaUpdateInput, projetoTecnologiaUncheckedUpdateInput>
  }

  /**
   * projetoTecnologia delete
   */
  export type projetoTecnologiaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoTecnologia
     */
    select?: projetoTecnologiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoTecnologiaInclude<ExtArgs> | null
    /**
     * Filter which projetoTecnologia to delete.
     */
    where: projetoTecnologiaWhereUniqueInput
  }

  /**
   * projetoTecnologia deleteMany
   */
  export type projetoTecnologiaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projetoTecnologias to delete
     */
    where?: projetoTecnologiaWhereInput
  }

  /**
   * projetoTecnologia without action
   */
  export type projetoTecnologiaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projetoTecnologia
     */
    select?: projetoTecnologiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoTecnologiaInclude<ExtArgs> | null
  }


  /**
   * Model habilidadeUsuario
   */

  export type AggregateHabilidadeUsuario = {
    _count: HabilidadeUsuarioCountAggregateOutputType | null
    _avg: HabilidadeUsuarioAvgAggregateOutputType | null
    _sum: HabilidadeUsuarioSumAggregateOutputType | null
    _min: HabilidadeUsuarioMinAggregateOutputType | null
    _max: HabilidadeUsuarioMaxAggregateOutputType | null
  }

  export type HabilidadeUsuarioAvgAggregateOutputType = {
    habilidadeUsuario_id: number | null
    tecnologia_id: number | null
    usuario_id: number | null
  }

  export type HabilidadeUsuarioSumAggregateOutputType = {
    habilidadeUsuario_id: number | null
    tecnologia_id: number | null
    usuario_id: number | null
  }

  export type HabilidadeUsuarioMinAggregateOutputType = {
    habilidadeUsuario_id: number | null
    tecnologia_id: number | null
    usuario_id: number | null
  }

  export type HabilidadeUsuarioMaxAggregateOutputType = {
    habilidadeUsuario_id: number | null
    tecnologia_id: number | null
    usuario_id: number | null
  }

  export type HabilidadeUsuarioCountAggregateOutputType = {
    habilidadeUsuario_id: number
    tecnologia_id: number
    usuario_id: number
    _all: number
  }


  export type HabilidadeUsuarioAvgAggregateInputType = {
    habilidadeUsuario_id?: true
    tecnologia_id?: true
    usuario_id?: true
  }

  export type HabilidadeUsuarioSumAggregateInputType = {
    habilidadeUsuario_id?: true
    tecnologia_id?: true
    usuario_id?: true
  }

  export type HabilidadeUsuarioMinAggregateInputType = {
    habilidadeUsuario_id?: true
    tecnologia_id?: true
    usuario_id?: true
  }

  export type HabilidadeUsuarioMaxAggregateInputType = {
    habilidadeUsuario_id?: true
    tecnologia_id?: true
    usuario_id?: true
  }

  export type HabilidadeUsuarioCountAggregateInputType = {
    habilidadeUsuario_id?: true
    tecnologia_id?: true
    usuario_id?: true
    _all?: true
  }

  export type HabilidadeUsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which habilidadeUsuario to aggregate.
     */
    where?: habilidadeUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of habilidadeUsuarios to fetch.
     */
    orderBy?: habilidadeUsuarioOrderByWithRelationInput | habilidadeUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: habilidadeUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` habilidadeUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` habilidadeUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned habilidadeUsuarios
    **/
    _count?: true | HabilidadeUsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HabilidadeUsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HabilidadeUsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HabilidadeUsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HabilidadeUsuarioMaxAggregateInputType
  }

  export type GetHabilidadeUsuarioAggregateType<T extends HabilidadeUsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateHabilidadeUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHabilidadeUsuario[P]>
      : GetScalarType<T[P], AggregateHabilidadeUsuario[P]>
  }




  export type habilidadeUsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: habilidadeUsuarioWhereInput
    orderBy?: habilidadeUsuarioOrderByWithAggregationInput | habilidadeUsuarioOrderByWithAggregationInput[]
    by: HabilidadeUsuarioScalarFieldEnum[] | HabilidadeUsuarioScalarFieldEnum
    having?: habilidadeUsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HabilidadeUsuarioCountAggregateInputType | true
    _avg?: HabilidadeUsuarioAvgAggregateInputType
    _sum?: HabilidadeUsuarioSumAggregateInputType
    _min?: HabilidadeUsuarioMinAggregateInputType
    _max?: HabilidadeUsuarioMaxAggregateInputType
  }

  export type HabilidadeUsuarioGroupByOutputType = {
    habilidadeUsuario_id: number
    tecnologia_id: number
    usuario_id: number
    _count: HabilidadeUsuarioCountAggregateOutputType | null
    _avg: HabilidadeUsuarioAvgAggregateOutputType | null
    _sum: HabilidadeUsuarioSumAggregateOutputType | null
    _min: HabilidadeUsuarioMinAggregateOutputType | null
    _max: HabilidadeUsuarioMaxAggregateOutputType | null
  }

  type GetHabilidadeUsuarioGroupByPayload<T extends habilidadeUsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HabilidadeUsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HabilidadeUsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HabilidadeUsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], HabilidadeUsuarioGroupByOutputType[P]>
        }
      >
    >


  export type habilidadeUsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    habilidadeUsuario_id?: boolean
    tecnologia_id?: boolean
    usuario_id?: boolean
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
    tecnologia?: boolean | tecnologiaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["habilidadeUsuario"]>

  export type habilidadeUsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    habilidadeUsuario_id?: boolean
    tecnologia_id?: boolean
    usuario_id?: boolean
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
    tecnologia?: boolean | tecnologiaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["habilidadeUsuario"]>

  export type habilidadeUsuarioSelectScalar = {
    habilidadeUsuario_id?: boolean
    tecnologia_id?: boolean
    usuario_id?: boolean
  }

  export type habilidadeUsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
    tecnologia?: boolean | tecnologiaDefaultArgs<ExtArgs>
  }
  export type habilidadeUsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
    tecnologia?: boolean | tecnologiaDefaultArgs<ExtArgs>
  }

  export type $habilidadeUsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "habilidadeUsuario"
    objects: {
      usuario: Prisma.$usuarioPayload<ExtArgs>
      tecnologia: Prisma.$tecnologiaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      habilidadeUsuario_id: number
      tecnologia_id: number
      usuario_id: number
    }, ExtArgs["result"]["habilidadeUsuario"]>
    composites: {}
  }

  type habilidadeUsuarioGetPayload<S extends boolean | null | undefined | habilidadeUsuarioDefaultArgs> = $Result.GetResult<Prisma.$habilidadeUsuarioPayload, S>

  type habilidadeUsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<habilidadeUsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HabilidadeUsuarioCountAggregateInputType | true
    }

  export interface habilidadeUsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['habilidadeUsuario'], meta: { name: 'habilidadeUsuario' } }
    /**
     * Find zero or one HabilidadeUsuario that matches the filter.
     * @param {habilidadeUsuarioFindUniqueArgs} args - Arguments to find a HabilidadeUsuario
     * @example
     * // Get one HabilidadeUsuario
     * const habilidadeUsuario = await prisma.habilidadeUsuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends habilidadeUsuarioFindUniqueArgs>(args: SelectSubset<T, habilidadeUsuarioFindUniqueArgs<ExtArgs>>): Prisma__habilidadeUsuarioClient<$Result.GetResult<Prisma.$habilidadeUsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HabilidadeUsuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {habilidadeUsuarioFindUniqueOrThrowArgs} args - Arguments to find a HabilidadeUsuario
     * @example
     * // Get one HabilidadeUsuario
     * const habilidadeUsuario = await prisma.habilidadeUsuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends habilidadeUsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, habilidadeUsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__habilidadeUsuarioClient<$Result.GetResult<Prisma.$habilidadeUsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HabilidadeUsuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {habilidadeUsuarioFindFirstArgs} args - Arguments to find a HabilidadeUsuario
     * @example
     * // Get one HabilidadeUsuario
     * const habilidadeUsuario = await prisma.habilidadeUsuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends habilidadeUsuarioFindFirstArgs>(args?: SelectSubset<T, habilidadeUsuarioFindFirstArgs<ExtArgs>>): Prisma__habilidadeUsuarioClient<$Result.GetResult<Prisma.$habilidadeUsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HabilidadeUsuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {habilidadeUsuarioFindFirstOrThrowArgs} args - Arguments to find a HabilidadeUsuario
     * @example
     * // Get one HabilidadeUsuario
     * const habilidadeUsuario = await prisma.habilidadeUsuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends habilidadeUsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, habilidadeUsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__habilidadeUsuarioClient<$Result.GetResult<Prisma.$habilidadeUsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HabilidadeUsuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {habilidadeUsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HabilidadeUsuarios
     * const habilidadeUsuarios = await prisma.habilidadeUsuario.findMany()
     * 
     * // Get first 10 HabilidadeUsuarios
     * const habilidadeUsuarios = await prisma.habilidadeUsuario.findMany({ take: 10 })
     * 
     * // Only select the `habilidadeUsuario_id`
     * const habilidadeUsuarioWithHabilidadeUsuario_idOnly = await prisma.habilidadeUsuario.findMany({ select: { habilidadeUsuario_id: true } })
     * 
     */
    findMany<T extends habilidadeUsuarioFindManyArgs>(args?: SelectSubset<T, habilidadeUsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$habilidadeUsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HabilidadeUsuario.
     * @param {habilidadeUsuarioCreateArgs} args - Arguments to create a HabilidadeUsuario.
     * @example
     * // Create one HabilidadeUsuario
     * const HabilidadeUsuario = await prisma.habilidadeUsuario.create({
     *   data: {
     *     // ... data to create a HabilidadeUsuario
     *   }
     * })
     * 
     */
    create<T extends habilidadeUsuarioCreateArgs>(args: SelectSubset<T, habilidadeUsuarioCreateArgs<ExtArgs>>): Prisma__habilidadeUsuarioClient<$Result.GetResult<Prisma.$habilidadeUsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HabilidadeUsuarios.
     * @param {habilidadeUsuarioCreateManyArgs} args - Arguments to create many HabilidadeUsuarios.
     * @example
     * // Create many HabilidadeUsuarios
     * const habilidadeUsuario = await prisma.habilidadeUsuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends habilidadeUsuarioCreateManyArgs>(args?: SelectSubset<T, habilidadeUsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HabilidadeUsuarios and returns the data saved in the database.
     * @param {habilidadeUsuarioCreateManyAndReturnArgs} args - Arguments to create many HabilidadeUsuarios.
     * @example
     * // Create many HabilidadeUsuarios
     * const habilidadeUsuario = await prisma.habilidadeUsuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HabilidadeUsuarios and only return the `habilidadeUsuario_id`
     * const habilidadeUsuarioWithHabilidadeUsuario_idOnly = await prisma.habilidadeUsuario.createManyAndReturn({ 
     *   select: { habilidadeUsuario_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends habilidadeUsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, habilidadeUsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$habilidadeUsuarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HabilidadeUsuario.
     * @param {habilidadeUsuarioDeleteArgs} args - Arguments to delete one HabilidadeUsuario.
     * @example
     * // Delete one HabilidadeUsuario
     * const HabilidadeUsuario = await prisma.habilidadeUsuario.delete({
     *   where: {
     *     // ... filter to delete one HabilidadeUsuario
     *   }
     * })
     * 
     */
    delete<T extends habilidadeUsuarioDeleteArgs>(args: SelectSubset<T, habilidadeUsuarioDeleteArgs<ExtArgs>>): Prisma__habilidadeUsuarioClient<$Result.GetResult<Prisma.$habilidadeUsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HabilidadeUsuario.
     * @param {habilidadeUsuarioUpdateArgs} args - Arguments to update one HabilidadeUsuario.
     * @example
     * // Update one HabilidadeUsuario
     * const habilidadeUsuario = await prisma.habilidadeUsuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends habilidadeUsuarioUpdateArgs>(args: SelectSubset<T, habilidadeUsuarioUpdateArgs<ExtArgs>>): Prisma__habilidadeUsuarioClient<$Result.GetResult<Prisma.$habilidadeUsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HabilidadeUsuarios.
     * @param {habilidadeUsuarioDeleteManyArgs} args - Arguments to filter HabilidadeUsuarios to delete.
     * @example
     * // Delete a few HabilidadeUsuarios
     * const { count } = await prisma.habilidadeUsuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends habilidadeUsuarioDeleteManyArgs>(args?: SelectSubset<T, habilidadeUsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HabilidadeUsuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {habilidadeUsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HabilidadeUsuarios
     * const habilidadeUsuario = await prisma.habilidadeUsuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends habilidadeUsuarioUpdateManyArgs>(args: SelectSubset<T, habilidadeUsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HabilidadeUsuario.
     * @param {habilidadeUsuarioUpsertArgs} args - Arguments to update or create a HabilidadeUsuario.
     * @example
     * // Update or create a HabilidadeUsuario
     * const habilidadeUsuario = await prisma.habilidadeUsuario.upsert({
     *   create: {
     *     // ... data to create a HabilidadeUsuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HabilidadeUsuario we want to update
     *   }
     * })
     */
    upsert<T extends habilidadeUsuarioUpsertArgs>(args: SelectSubset<T, habilidadeUsuarioUpsertArgs<ExtArgs>>): Prisma__habilidadeUsuarioClient<$Result.GetResult<Prisma.$habilidadeUsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HabilidadeUsuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {habilidadeUsuarioCountArgs} args - Arguments to filter HabilidadeUsuarios to count.
     * @example
     * // Count the number of HabilidadeUsuarios
     * const count = await prisma.habilidadeUsuario.count({
     *   where: {
     *     // ... the filter for the HabilidadeUsuarios we want to count
     *   }
     * })
    **/
    count<T extends habilidadeUsuarioCountArgs>(
      args?: Subset<T, habilidadeUsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HabilidadeUsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HabilidadeUsuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HabilidadeUsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HabilidadeUsuarioAggregateArgs>(args: Subset<T, HabilidadeUsuarioAggregateArgs>): Prisma.PrismaPromise<GetHabilidadeUsuarioAggregateType<T>>

    /**
     * Group by HabilidadeUsuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {habilidadeUsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends habilidadeUsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: habilidadeUsuarioGroupByArgs['orderBy'] }
        : { orderBy?: habilidadeUsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, habilidadeUsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHabilidadeUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the habilidadeUsuario model
   */
  readonly fields: habilidadeUsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for habilidadeUsuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__habilidadeUsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends usuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuarioDefaultArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tecnologia<T extends tecnologiaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tecnologiaDefaultArgs<ExtArgs>>): Prisma__tecnologiaClient<$Result.GetResult<Prisma.$tecnologiaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the habilidadeUsuario model
   */ 
  interface habilidadeUsuarioFieldRefs {
    readonly habilidadeUsuario_id: FieldRef<"habilidadeUsuario", 'Int'>
    readonly tecnologia_id: FieldRef<"habilidadeUsuario", 'Int'>
    readonly usuario_id: FieldRef<"habilidadeUsuario", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * habilidadeUsuario findUnique
   */
  export type habilidadeUsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habilidadeUsuario
     */
    select?: habilidadeUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habilidadeUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which habilidadeUsuario to fetch.
     */
    where: habilidadeUsuarioWhereUniqueInput
  }

  /**
   * habilidadeUsuario findUniqueOrThrow
   */
  export type habilidadeUsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habilidadeUsuario
     */
    select?: habilidadeUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habilidadeUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which habilidadeUsuario to fetch.
     */
    where: habilidadeUsuarioWhereUniqueInput
  }

  /**
   * habilidadeUsuario findFirst
   */
  export type habilidadeUsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habilidadeUsuario
     */
    select?: habilidadeUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habilidadeUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which habilidadeUsuario to fetch.
     */
    where?: habilidadeUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of habilidadeUsuarios to fetch.
     */
    orderBy?: habilidadeUsuarioOrderByWithRelationInput | habilidadeUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for habilidadeUsuarios.
     */
    cursor?: habilidadeUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` habilidadeUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` habilidadeUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of habilidadeUsuarios.
     */
    distinct?: HabilidadeUsuarioScalarFieldEnum | HabilidadeUsuarioScalarFieldEnum[]
  }

  /**
   * habilidadeUsuario findFirstOrThrow
   */
  export type habilidadeUsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habilidadeUsuario
     */
    select?: habilidadeUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habilidadeUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which habilidadeUsuario to fetch.
     */
    where?: habilidadeUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of habilidadeUsuarios to fetch.
     */
    orderBy?: habilidadeUsuarioOrderByWithRelationInput | habilidadeUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for habilidadeUsuarios.
     */
    cursor?: habilidadeUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` habilidadeUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` habilidadeUsuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of habilidadeUsuarios.
     */
    distinct?: HabilidadeUsuarioScalarFieldEnum | HabilidadeUsuarioScalarFieldEnum[]
  }

  /**
   * habilidadeUsuario findMany
   */
  export type habilidadeUsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habilidadeUsuario
     */
    select?: habilidadeUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habilidadeUsuarioInclude<ExtArgs> | null
    /**
     * Filter, which habilidadeUsuarios to fetch.
     */
    where?: habilidadeUsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of habilidadeUsuarios to fetch.
     */
    orderBy?: habilidadeUsuarioOrderByWithRelationInput | habilidadeUsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing habilidadeUsuarios.
     */
    cursor?: habilidadeUsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` habilidadeUsuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` habilidadeUsuarios.
     */
    skip?: number
    distinct?: HabilidadeUsuarioScalarFieldEnum | HabilidadeUsuarioScalarFieldEnum[]
  }

  /**
   * habilidadeUsuario create
   */
  export type habilidadeUsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habilidadeUsuario
     */
    select?: habilidadeUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habilidadeUsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a habilidadeUsuario.
     */
    data: XOR<habilidadeUsuarioCreateInput, habilidadeUsuarioUncheckedCreateInput>
  }

  /**
   * habilidadeUsuario createMany
   */
  export type habilidadeUsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many habilidadeUsuarios.
     */
    data: habilidadeUsuarioCreateManyInput | habilidadeUsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * habilidadeUsuario createManyAndReturn
   */
  export type habilidadeUsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habilidadeUsuario
     */
    select?: habilidadeUsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many habilidadeUsuarios.
     */
    data: habilidadeUsuarioCreateManyInput | habilidadeUsuarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habilidadeUsuarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * habilidadeUsuario update
   */
  export type habilidadeUsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habilidadeUsuario
     */
    select?: habilidadeUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habilidadeUsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a habilidadeUsuario.
     */
    data: XOR<habilidadeUsuarioUpdateInput, habilidadeUsuarioUncheckedUpdateInput>
    /**
     * Choose, which habilidadeUsuario to update.
     */
    where: habilidadeUsuarioWhereUniqueInput
  }

  /**
   * habilidadeUsuario updateMany
   */
  export type habilidadeUsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update habilidadeUsuarios.
     */
    data: XOR<habilidadeUsuarioUpdateManyMutationInput, habilidadeUsuarioUncheckedUpdateManyInput>
    /**
     * Filter which habilidadeUsuarios to update
     */
    where?: habilidadeUsuarioWhereInput
  }

  /**
   * habilidadeUsuario upsert
   */
  export type habilidadeUsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habilidadeUsuario
     */
    select?: habilidadeUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habilidadeUsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the habilidadeUsuario to update in case it exists.
     */
    where: habilidadeUsuarioWhereUniqueInput
    /**
     * In case the habilidadeUsuario found by the `where` argument doesn't exist, create a new habilidadeUsuario with this data.
     */
    create: XOR<habilidadeUsuarioCreateInput, habilidadeUsuarioUncheckedCreateInput>
    /**
     * In case the habilidadeUsuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<habilidadeUsuarioUpdateInput, habilidadeUsuarioUncheckedUpdateInput>
  }

  /**
   * habilidadeUsuario delete
   */
  export type habilidadeUsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habilidadeUsuario
     */
    select?: habilidadeUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habilidadeUsuarioInclude<ExtArgs> | null
    /**
     * Filter which habilidadeUsuario to delete.
     */
    where: habilidadeUsuarioWhereUniqueInput
  }

  /**
   * habilidadeUsuario deleteMany
   */
  export type habilidadeUsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which habilidadeUsuarios to delete
     */
    where?: habilidadeUsuarioWhereInput
  }

  /**
   * habilidadeUsuario without action
   */
  export type habilidadeUsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the habilidadeUsuario
     */
    select?: habilidadeUsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: habilidadeUsuarioInclude<ExtArgs> | null
  }


  /**
   * Model recurso
   */

  export type AggregateRecurso = {
    _count: RecursoCountAggregateOutputType | null
    _avg: RecursoAvgAggregateOutputType | null
    _sum: RecursoSumAggregateOutputType | null
    _min: RecursoMinAggregateOutputType | null
    _max: RecursoMaxAggregateOutputType | null
  }

  export type RecursoAvgAggregateOutputType = {
    recurso_id: number | null
    projeto_id: number | null
  }

  export type RecursoSumAggregateOutputType = {
    recurso_id: number | null
    projeto_id: number | null
  }

  export type RecursoMinAggregateOutputType = {
    recurso_id: number | null
    descricao: string | null
    projeto_id: number | null
  }

  export type RecursoMaxAggregateOutputType = {
    recurso_id: number | null
    descricao: string | null
    projeto_id: number | null
  }

  export type RecursoCountAggregateOutputType = {
    recurso_id: number
    descricao: number
    projeto_id: number
    _all: number
  }


  export type RecursoAvgAggregateInputType = {
    recurso_id?: true
    projeto_id?: true
  }

  export type RecursoSumAggregateInputType = {
    recurso_id?: true
    projeto_id?: true
  }

  export type RecursoMinAggregateInputType = {
    recurso_id?: true
    descricao?: true
    projeto_id?: true
  }

  export type RecursoMaxAggregateInputType = {
    recurso_id?: true
    descricao?: true
    projeto_id?: true
  }

  export type RecursoCountAggregateInputType = {
    recurso_id?: true
    descricao?: true
    projeto_id?: true
    _all?: true
  }

  export type RecursoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which recurso to aggregate.
     */
    where?: recursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recursos to fetch.
     */
    orderBy?: recursoOrderByWithRelationInput | recursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: recursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned recursos
    **/
    _count?: true | RecursoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecursoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecursoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecursoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecursoMaxAggregateInputType
  }

  export type GetRecursoAggregateType<T extends RecursoAggregateArgs> = {
        [P in keyof T & keyof AggregateRecurso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecurso[P]>
      : GetScalarType<T[P], AggregateRecurso[P]>
  }




  export type recursoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recursoWhereInput
    orderBy?: recursoOrderByWithAggregationInput | recursoOrderByWithAggregationInput[]
    by: RecursoScalarFieldEnum[] | RecursoScalarFieldEnum
    having?: recursoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecursoCountAggregateInputType | true
    _avg?: RecursoAvgAggregateInputType
    _sum?: RecursoSumAggregateInputType
    _min?: RecursoMinAggregateInputType
    _max?: RecursoMaxAggregateInputType
  }

  export type RecursoGroupByOutputType = {
    recurso_id: number
    descricao: string
    projeto_id: number
    _count: RecursoCountAggregateOutputType | null
    _avg: RecursoAvgAggregateOutputType | null
    _sum: RecursoSumAggregateOutputType | null
    _min: RecursoMinAggregateOutputType | null
    _max: RecursoMaxAggregateOutputType | null
  }

  type GetRecursoGroupByPayload<T extends recursoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecursoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecursoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecursoGroupByOutputType[P]>
            : GetScalarType<T[P], RecursoGroupByOutputType[P]>
        }
      >
    >


  export type recursoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recurso_id?: boolean
    descricao?: boolean
    projeto_id?: boolean
    projeto?: boolean | projetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurso"]>

  export type recursoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recurso_id?: boolean
    descricao?: boolean
    projeto_id?: boolean
    projeto?: boolean | projetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurso"]>

  export type recursoSelectScalar = {
    recurso_id?: boolean
    descricao?: boolean
    projeto_id?: boolean
  }

  export type recursoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | projetoDefaultArgs<ExtArgs>
  }
  export type recursoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | projetoDefaultArgs<ExtArgs>
  }

  export type $recursoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "recurso"
    objects: {
      projeto: Prisma.$projetoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      recurso_id: number
      descricao: string
      projeto_id: number
    }, ExtArgs["result"]["recurso"]>
    composites: {}
  }

  type recursoGetPayload<S extends boolean | null | undefined | recursoDefaultArgs> = $Result.GetResult<Prisma.$recursoPayload, S>

  type recursoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<recursoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecursoCountAggregateInputType | true
    }

  export interface recursoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['recurso'], meta: { name: 'recurso' } }
    /**
     * Find zero or one Recurso that matches the filter.
     * @param {recursoFindUniqueArgs} args - Arguments to find a Recurso
     * @example
     * // Get one Recurso
     * const recurso = await prisma.recurso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends recursoFindUniqueArgs>(args: SelectSubset<T, recursoFindUniqueArgs<ExtArgs>>): Prisma__recursoClient<$Result.GetResult<Prisma.$recursoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Recurso that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {recursoFindUniqueOrThrowArgs} args - Arguments to find a Recurso
     * @example
     * // Get one Recurso
     * const recurso = await prisma.recurso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends recursoFindUniqueOrThrowArgs>(args: SelectSubset<T, recursoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__recursoClient<$Result.GetResult<Prisma.$recursoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Recurso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recursoFindFirstArgs} args - Arguments to find a Recurso
     * @example
     * // Get one Recurso
     * const recurso = await prisma.recurso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends recursoFindFirstArgs>(args?: SelectSubset<T, recursoFindFirstArgs<ExtArgs>>): Prisma__recursoClient<$Result.GetResult<Prisma.$recursoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Recurso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recursoFindFirstOrThrowArgs} args - Arguments to find a Recurso
     * @example
     * // Get one Recurso
     * const recurso = await prisma.recurso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends recursoFindFirstOrThrowArgs>(args?: SelectSubset<T, recursoFindFirstOrThrowArgs<ExtArgs>>): Prisma__recursoClient<$Result.GetResult<Prisma.$recursoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Recursos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recursoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recursos
     * const recursos = await prisma.recurso.findMany()
     * 
     * // Get first 10 Recursos
     * const recursos = await prisma.recurso.findMany({ take: 10 })
     * 
     * // Only select the `recurso_id`
     * const recursoWithRecurso_idOnly = await prisma.recurso.findMany({ select: { recurso_id: true } })
     * 
     */
    findMany<T extends recursoFindManyArgs>(args?: SelectSubset<T, recursoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recursoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Recurso.
     * @param {recursoCreateArgs} args - Arguments to create a Recurso.
     * @example
     * // Create one Recurso
     * const Recurso = await prisma.recurso.create({
     *   data: {
     *     // ... data to create a Recurso
     *   }
     * })
     * 
     */
    create<T extends recursoCreateArgs>(args: SelectSubset<T, recursoCreateArgs<ExtArgs>>): Prisma__recursoClient<$Result.GetResult<Prisma.$recursoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Recursos.
     * @param {recursoCreateManyArgs} args - Arguments to create many Recursos.
     * @example
     * // Create many Recursos
     * const recurso = await prisma.recurso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends recursoCreateManyArgs>(args?: SelectSubset<T, recursoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recursos and returns the data saved in the database.
     * @param {recursoCreateManyAndReturnArgs} args - Arguments to create many Recursos.
     * @example
     * // Create many Recursos
     * const recurso = await prisma.recurso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recursos and only return the `recurso_id`
     * const recursoWithRecurso_idOnly = await prisma.recurso.createManyAndReturn({ 
     *   select: { recurso_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends recursoCreateManyAndReturnArgs>(args?: SelectSubset<T, recursoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recursoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Recurso.
     * @param {recursoDeleteArgs} args - Arguments to delete one Recurso.
     * @example
     * // Delete one Recurso
     * const Recurso = await prisma.recurso.delete({
     *   where: {
     *     // ... filter to delete one Recurso
     *   }
     * })
     * 
     */
    delete<T extends recursoDeleteArgs>(args: SelectSubset<T, recursoDeleteArgs<ExtArgs>>): Prisma__recursoClient<$Result.GetResult<Prisma.$recursoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Recurso.
     * @param {recursoUpdateArgs} args - Arguments to update one Recurso.
     * @example
     * // Update one Recurso
     * const recurso = await prisma.recurso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends recursoUpdateArgs>(args: SelectSubset<T, recursoUpdateArgs<ExtArgs>>): Prisma__recursoClient<$Result.GetResult<Prisma.$recursoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Recursos.
     * @param {recursoDeleteManyArgs} args - Arguments to filter Recursos to delete.
     * @example
     * // Delete a few Recursos
     * const { count } = await prisma.recurso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends recursoDeleteManyArgs>(args?: SelectSubset<T, recursoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recursoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recursos
     * const recurso = await prisma.recurso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends recursoUpdateManyArgs>(args: SelectSubset<T, recursoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Recurso.
     * @param {recursoUpsertArgs} args - Arguments to update or create a Recurso.
     * @example
     * // Update or create a Recurso
     * const recurso = await prisma.recurso.upsert({
     *   create: {
     *     // ... data to create a Recurso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recurso we want to update
     *   }
     * })
     */
    upsert<T extends recursoUpsertArgs>(args: SelectSubset<T, recursoUpsertArgs<ExtArgs>>): Prisma__recursoClient<$Result.GetResult<Prisma.$recursoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Recursos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recursoCountArgs} args - Arguments to filter Recursos to count.
     * @example
     * // Count the number of Recursos
     * const count = await prisma.recurso.count({
     *   where: {
     *     // ... the filter for the Recursos we want to count
     *   }
     * })
    **/
    count<T extends recursoCountArgs>(
      args?: Subset<T, recursoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecursoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recurso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecursoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecursoAggregateArgs>(args: Subset<T, RecursoAggregateArgs>): Prisma.PrismaPromise<GetRecursoAggregateType<T>>

    /**
     * Group by Recurso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recursoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends recursoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: recursoGroupByArgs['orderBy'] }
        : { orderBy?: recursoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, recursoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecursoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the recurso model
   */
  readonly fields: recursoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for recurso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__recursoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projeto<T extends projetoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projetoDefaultArgs<ExtArgs>>): Prisma__projetoClient<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the recurso model
   */ 
  interface recursoFieldRefs {
    readonly recurso_id: FieldRef<"recurso", 'Int'>
    readonly descricao: FieldRef<"recurso", 'String'>
    readonly projeto_id: FieldRef<"recurso", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * recurso findUnique
   */
  export type recursoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null
    /**
     * Filter, which recurso to fetch.
     */
    where: recursoWhereUniqueInput
  }

  /**
   * recurso findUniqueOrThrow
   */
  export type recursoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null
    /**
     * Filter, which recurso to fetch.
     */
    where: recursoWhereUniqueInput
  }

  /**
   * recurso findFirst
   */
  export type recursoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null
    /**
     * Filter, which recurso to fetch.
     */
    where?: recursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recursos to fetch.
     */
    orderBy?: recursoOrderByWithRelationInput | recursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recursos.
     */
    cursor?: recursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recursos.
     */
    distinct?: RecursoScalarFieldEnum | RecursoScalarFieldEnum[]
  }

  /**
   * recurso findFirstOrThrow
   */
  export type recursoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null
    /**
     * Filter, which recurso to fetch.
     */
    where?: recursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recursos to fetch.
     */
    orderBy?: recursoOrderByWithRelationInput | recursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recursos.
     */
    cursor?: recursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recursos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recursos.
     */
    distinct?: RecursoScalarFieldEnum | RecursoScalarFieldEnum[]
  }

  /**
   * recurso findMany
   */
  export type recursoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null
    /**
     * Filter, which recursos to fetch.
     */
    where?: recursoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recursos to fetch.
     */
    orderBy?: recursoOrderByWithRelationInput | recursoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing recursos.
     */
    cursor?: recursoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recursos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recursos.
     */
    skip?: number
    distinct?: RecursoScalarFieldEnum | RecursoScalarFieldEnum[]
  }

  /**
   * recurso create
   */
  export type recursoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null
    /**
     * The data needed to create a recurso.
     */
    data: XOR<recursoCreateInput, recursoUncheckedCreateInput>
  }

  /**
   * recurso createMany
   */
  export type recursoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many recursos.
     */
    data: recursoCreateManyInput | recursoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * recurso createManyAndReturn
   */
  export type recursoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many recursos.
     */
    data: recursoCreateManyInput | recursoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * recurso update
   */
  export type recursoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null
    /**
     * The data needed to update a recurso.
     */
    data: XOR<recursoUpdateInput, recursoUncheckedUpdateInput>
    /**
     * Choose, which recurso to update.
     */
    where: recursoWhereUniqueInput
  }

  /**
   * recurso updateMany
   */
  export type recursoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update recursos.
     */
    data: XOR<recursoUpdateManyMutationInput, recursoUncheckedUpdateManyInput>
    /**
     * Filter which recursos to update
     */
    where?: recursoWhereInput
  }

  /**
   * recurso upsert
   */
  export type recursoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null
    /**
     * The filter to search for the recurso to update in case it exists.
     */
    where: recursoWhereUniqueInput
    /**
     * In case the recurso found by the `where` argument doesn't exist, create a new recurso with this data.
     */
    create: XOR<recursoCreateInput, recursoUncheckedCreateInput>
    /**
     * In case the recurso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<recursoUpdateInput, recursoUncheckedUpdateInput>
  }

  /**
   * recurso delete
   */
  export type recursoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null
    /**
     * Filter which recurso to delete.
     */
    where: recursoWhereUniqueInput
  }

  /**
   * recurso deleteMany
   */
  export type recursoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which recursos to delete
     */
    where?: recursoWhereInput
  }

  /**
   * recurso without action
   */
  export type recursoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recurso
     */
    select?: recursoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recursoInclude<ExtArgs> | null
  }


  /**
   * Model anexoProjeto
   */

  export type AggregateAnexoProjeto = {
    _count: AnexoProjetoCountAggregateOutputType | null
    _avg: AnexoProjetoAvgAggregateOutputType | null
    _sum: AnexoProjetoSumAggregateOutputType | null
    _min: AnexoProjetoMinAggregateOutputType | null
    _max: AnexoProjetoMaxAggregateOutputType | null
  }

  export type AnexoProjetoAvgAggregateOutputType = {
    anexo_id: number | null
    projeto_id: number | null
  }

  export type AnexoProjetoSumAggregateOutputType = {
    anexo_id: number | null
    projeto_id: number | null
  }

  export type AnexoProjetoMinAggregateOutputType = {
    anexo_id: number | null
    nome: string | null
    tipo: string | null
    conteudo: Buffer | null
    projeto_id: number | null
    created_at: Date | null
  }

  export type AnexoProjetoMaxAggregateOutputType = {
    anexo_id: number | null
    nome: string | null
    tipo: string | null
    conteudo: Buffer | null
    projeto_id: number | null
    created_at: Date | null
  }

  export type AnexoProjetoCountAggregateOutputType = {
    anexo_id: number
    nome: number
    tipo: number
    conteudo: number
    projeto_id: number
    created_at: number
    _all: number
  }


  export type AnexoProjetoAvgAggregateInputType = {
    anexo_id?: true
    projeto_id?: true
  }

  export type AnexoProjetoSumAggregateInputType = {
    anexo_id?: true
    projeto_id?: true
  }

  export type AnexoProjetoMinAggregateInputType = {
    anexo_id?: true
    nome?: true
    tipo?: true
    conteudo?: true
    projeto_id?: true
    created_at?: true
  }

  export type AnexoProjetoMaxAggregateInputType = {
    anexo_id?: true
    nome?: true
    tipo?: true
    conteudo?: true
    projeto_id?: true
    created_at?: true
  }

  export type AnexoProjetoCountAggregateInputType = {
    anexo_id?: true
    nome?: true
    tipo?: true
    conteudo?: true
    projeto_id?: true
    created_at?: true
    _all?: true
  }

  export type AnexoProjetoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which anexoProjeto to aggregate.
     */
    where?: anexoProjetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anexoProjetos to fetch.
     */
    orderBy?: anexoProjetoOrderByWithRelationInput | anexoProjetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: anexoProjetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anexoProjetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anexoProjetos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned anexoProjetos
    **/
    _count?: true | AnexoProjetoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnexoProjetoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnexoProjetoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnexoProjetoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnexoProjetoMaxAggregateInputType
  }

  export type GetAnexoProjetoAggregateType<T extends AnexoProjetoAggregateArgs> = {
        [P in keyof T & keyof AggregateAnexoProjeto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnexoProjeto[P]>
      : GetScalarType<T[P], AggregateAnexoProjeto[P]>
  }




  export type anexoProjetoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: anexoProjetoWhereInput
    orderBy?: anexoProjetoOrderByWithAggregationInput | anexoProjetoOrderByWithAggregationInput[]
    by: AnexoProjetoScalarFieldEnum[] | AnexoProjetoScalarFieldEnum
    having?: anexoProjetoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnexoProjetoCountAggregateInputType | true
    _avg?: AnexoProjetoAvgAggregateInputType
    _sum?: AnexoProjetoSumAggregateInputType
    _min?: AnexoProjetoMinAggregateInputType
    _max?: AnexoProjetoMaxAggregateInputType
  }

  export type AnexoProjetoGroupByOutputType = {
    anexo_id: number
    nome: string
    tipo: string
    conteudo: Buffer
    projeto_id: number
    created_at: Date
    _count: AnexoProjetoCountAggregateOutputType | null
    _avg: AnexoProjetoAvgAggregateOutputType | null
    _sum: AnexoProjetoSumAggregateOutputType | null
    _min: AnexoProjetoMinAggregateOutputType | null
    _max: AnexoProjetoMaxAggregateOutputType | null
  }

  type GetAnexoProjetoGroupByPayload<T extends anexoProjetoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnexoProjetoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnexoProjetoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnexoProjetoGroupByOutputType[P]>
            : GetScalarType<T[P], AnexoProjetoGroupByOutputType[P]>
        }
      >
    >


  export type anexoProjetoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    anexo_id?: boolean
    nome?: boolean
    tipo?: boolean
    conteudo?: boolean
    projeto_id?: boolean
    created_at?: boolean
    projeto?: boolean | projetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anexoProjeto"]>

  export type anexoProjetoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    anexo_id?: boolean
    nome?: boolean
    tipo?: boolean
    conteudo?: boolean
    projeto_id?: boolean
    created_at?: boolean
    projeto?: boolean | projetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anexoProjeto"]>

  export type anexoProjetoSelectScalar = {
    anexo_id?: boolean
    nome?: boolean
    tipo?: boolean
    conteudo?: boolean
    projeto_id?: boolean
    created_at?: boolean
  }

  export type anexoProjetoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | projetoDefaultArgs<ExtArgs>
  }
  export type anexoProjetoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | projetoDefaultArgs<ExtArgs>
  }

  export type $anexoProjetoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "anexoProjeto"
    objects: {
      projeto: Prisma.$projetoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      anexo_id: number
      nome: string
      tipo: string
      conteudo: Buffer
      projeto_id: number
      created_at: Date
    }, ExtArgs["result"]["anexoProjeto"]>
    composites: {}
  }

  type anexoProjetoGetPayload<S extends boolean | null | undefined | anexoProjetoDefaultArgs> = $Result.GetResult<Prisma.$anexoProjetoPayload, S>

  type anexoProjetoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<anexoProjetoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnexoProjetoCountAggregateInputType | true
    }

  export interface anexoProjetoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['anexoProjeto'], meta: { name: 'anexoProjeto' } }
    /**
     * Find zero or one AnexoProjeto that matches the filter.
     * @param {anexoProjetoFindUniqueArgs} args - Arguments to find a AnexoProjeto
     * @example
     * // Get one AnexoProjeto
     * const anexoProjeto = await prisma.anexoProjeto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends anexoProjetoFindUniqueArgs>(args: SelectSubset<T, anexoProjetoFindUniqueArgs<ExtArgs>>): Prisma__anexoProjetoClient<$Result.GetResult<Prisma.$anexoProjetoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AnexoProjeto that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {anexoProjetoFindUniqueOrThrowArgs} args - Arguments to find a AnexoProjeto
     * @example
     * // Get one AnexoProjeto
     * const anexoProjeto = await prisma.anexoProjeto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends anexoProjetoFindUniqueOrThrowArgs>(args: SelectSubset<T, anexoProjetoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__anexoProjetoClient<$Result.GetResult<Prisma.$anexoProjetoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AnexoProjeto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anexoProjetoFindFirstArgs} args - Arguments to find a AnexoProjeto
     * @example
     * // Get one AnexoProjeto
     * const anexoProjeto = await prisma.anexoProjeto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends anexoProjetoFindFirstArgs>(args?: SelectSubset<T, anexoProjetoFindFirstArgs<ExtArgs>>): Prisma__anexoProjetoClient<$Result.GetResult<Prisma.$anexoProjetoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AnexoProjeto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anexoProjetoFindFirstOrThrowArgs} args - Arguments to find a AnexoProjeto
     * @example
     * // Get one AnexoProjeto
     * const anexoProjeto = await prisma.anexoProjeto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends anexoProjetoFindFirstOrThrowArgs>(args?: SelectSubset<T, anexoProjetoFindFirstOrThrowArgs<ExtArgs>>): Prisma__anexoProjetoClient<$Result.GetResult<Prisma.$anexoProjetoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AnexoProjetos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anexoProjetoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnexoProjetos
     * const anexoProjetos = await prisma.anexoProjeto.findMany()
     * 
     * // Get first 10 AnexoProjetos
     * const anexoProjetos = await prisma.anexoProjeto.findMany({ take: 10 })
     * 
     * // Only select the `anexo_id`
     * const anexoProjetoWithAnexo_idOnly = await prisma.anexoProjeto.findMany({ select: { anexo_id: true } })
     * 
     */
    findMany<T extends anexoProjetoFindManyArgs>(args?: SelectSubset<T, anexoProjetoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$anexoProjetoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AnexoProjeto.
     * @param {anexoProjetoCreateArgs} args - Arguments to create a AnexoProjeto.
     * @example
     * // Create one AnexoProjeto
     * const AnexoProjeto = await prisma.anexoProjeto.create({
     *   data: {
     *     // ... data to create a AnexoProjeto
     *   }
     * })
     * 
     */
    create<T extends anexoProjetoCreateArgs>(args: SelectSubset<T, anexoProjetoCreateArgs<ExtArgs>>): Prisma__anexoProjetoClient<$Result.GetResult<Prisma.$anexoProjetoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AnexoProjetos.
     * @param {anexoProjetoCreateManyArgs} args - Arguments to create many AnexoProjetos.
     * @example
     * // Create many AnexoProjetos
     * const anexoProjeto = await prisma.anexoProjeto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends anexoProjetoCreateManyArgs>(args?: SelectSubset<T, anexoProjetoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnexoProjetos and returns the data saved in the database.
     * @param {anexoProjetoCreateManyAndReturnArgs} args - Arguments to create many AnexoProjetos.
     * @example
     * // Create many AnexoProjetos
     * const anexoProjeto = await prisma.anexoProjeto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnexoProjetos and only return the `anexo_id`
     * const anexoProjetoWithAnexo_idOnly = await prisma.anexoProjeto.createManyAndReturn({ 
     *   select: { anexo_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends anexoProjetoCreateManyAndReturnArgs>(args?: SelectSubset<T, anexoProjetoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$anexoProjetoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AnexoProjeto.
     * @param {anexoProjetoDeleteArgs} args - Arguments to delete one AnexoProjeto.
     * @example
     * // Delete one AnexoProjeto
     * const AnexoProjeto = await prisma.anexoProjeto.delete({
     *   where: {
     *     // ... filter to delete one AnexoProjeto
     *   }
     * })
     * 
     */
    delete<T extends anexoProjetoDeleteArgs>(args: SelectSubset<T, anexoProjetoDeleteArgs<ExtArgs>>): Prisma__anexoProjetoClient<$Result.GetResult<Prisma.$anexoProjetoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AnexoProjeto.
     * @param {anexoProjetoUpdateArgs} args - Arguments to update one AnexoProjeto.
     * @example
     * // Update one AnexoProjeto
     * const anexoProjeto = await prisma.anexoProjeto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends anexoProjetoUpdateArgs>(args: SelectSubset<T, anexoProjetoUpdateArgs<ExtArgs>>): Prisma__anexoProjetoClient<$Result.GetResult<Prisma.$anexoProjetoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AnexoProjetos.
     * @param {anexoProjetoDeleteManyArgs} args - Arguments to filter AnexoProjetos to delete.
     * @example
     * // Delete a few AnexoProjetos
     * const { count } = await prisma.anexoProjeto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends anexoProjetoDeleteManyArgs>(args?: SelectSubset<T, anexoProjetoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnexoProjetos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anexoProjetoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnexoProjetos
     * const anexoProjeto = await prisma.anexoProjeto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends anexoProjetoUpdateManyArgs>(args: SelectSubset<T, anexoProjetoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnexoProjeto.
     * @param {anexoProjetoUpsertArgs} args - Arguments to update or create a AnexoProjeto.
     * @example
     * // Update or create a AnexoProjeto
     * const anexoProjeto = await prisma.anexoProjeto.upsert({
     *   create: {
     *     // ... data to create a AnexoProjeto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnexoProjeto we want to update
     *   }
     * })
     */
    upsert<T extends anexoProjetoUpsertArgs>(args: SelectSubset<T, anexoProjetoUpsertArgs<ExtArgs>>): Prisma__anexoProjetoClient<$Result.GetResult<Prisma.$anexoProjetoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AnexoProjetos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anexoProjetoCountArgs} args - Arguments to filter AnexoProjetos to count.
     * @example
     * // Count the number of AnexoProjetos
     * const count = await prisma.anexoProjeto.count({
     *   where: {
     *     // ... the filter for the AnexoProjetos we want to count
     *   }
     * })
    **/
    count<T extends anexoProjetoCountArgs>(
      args?: Subset<T, anexoProjetoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnexoProjetoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnexoProjeto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnexoProjetoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnexoProjetoAggregateArgs>(args: Subset<T, AnexoProjetoAggregateArgs>): Prisma.PrismaPromise<GetAnexoProjetoAggregateType<T>>

    /**
     * Group by AnexoProjeto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anexoProjetoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends anexoProjetoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: anexoProjetoGroupByArgs['orderBy'] }
        : { orderBy?: anexoProjetoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, anexoProjetoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnexoProjetoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the anexoProjeto model
   */
  readonly fields: anexoProjetoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for anexoProjeto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__anexoProjetoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projeto<T extends projetoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projetoDefaultArgs<ExtArgs>>): Prisma__projetoClient<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the anexoProjeto model
   */ 
  interface anexoProjetoFieldRefs {
    readonly anexo_id: FieldRef<"anexoProjeto", 'Int'>
    readonly nome: FieldRef<"anexoProjeto", 'String'>
    readonly tipo: FieldRef<"anexoProjeto", 'String'>
    readonly conteudo: FieldRef<"anexoProjeto", 'Bytes'>
    readonly projeto_id: FieldRef<"anexoProjeto", 'Int'>
    readonly created_at: FieldRef<"anexoProjeto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * anexoProjeto findUnique
   */
  export type anexoProjetoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoProjeto
     */
    select?: anexoProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoProjetoInclude<ExtArgs> | null
    /**
     * Filter, which anexoProjeto to fetch.
     */
    where: anexoProjetoWhereUniqueInput
  }

  /**
   * anexoProjeto findUniqueOrThrow
   */
  export type anexoProjetoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoProjeto
     */
    select?: anexoProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoProjetoInclude<ExtArgs> | null
    /**
     * Filter, which anexoProjeto to fetch.
     */
    where: anexoProjetoWhereUniqueInput
  }

  /**
   * anexoProjeto findFirst
   */
  export type anexoProjetoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoProjeto
     */
    select?: anexoProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoProjetoInclude<ExtArgs> | null
    /**
     * Filter, which anexoProjeto to fetch.
     */
    where?: anexoProjetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anexoProjetos to fetch.
     */
    orderBy?: anexoProjetoOrderByWithRelationInput | anexoProjetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for anexoProjetos.
     */
    cursor?: anexoProjetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anexoProjetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anexoProjetos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of anexoProjetos.
     */
    distinct?: AnexoProjetoScalarFieldEnum | AnexoProjetoScalarFieldEnum[]
  }

  /**
   * anexoProjeto findFirstOrThrow
   */
  export type anexoProjetoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoProjeto
     */
    select?: anexoProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoProjetoInclude<ExtArgs> | null
    /**
     * Filter, which anexoProjeto to fetch.
     */
    where?: anexoProjetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anexoProjetos to fetch.
     */
    orderBy?: anexoProjetoOrderByWithRelationInput | anexoProjetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for anexoProjetos.
     */
    cursor?: anexoProjetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anexoProjetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anexoProjetos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of anexoProjetos.
     */
    distinct?: AnexoProjetoScalarFieldEnum | AnexoProjetoScalarFieldEnum[]
  }

  /**
   * anexoProjeto findMany
   */
  export type anexoProjetoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoProjeto
     */
    select?: anexoProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoProjetoInclude<ExtArgs> | null
    /**
     * Filter, which anexoProjetos to fetch.
     */
    where?: anexoProjetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anexoProjetos to fetch.
     */
    orderBy?: anexoProjetoOrderByWithRelationInput | anexoProjetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing anexoProjetos.
     */
    cursor?: anexoProjetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anexoProjetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anexoProjetos.
     */
    skip?: number
    distinct?: AnexoProjetoScalarFieldEnum | AnexoProjetoScalarFieldEnum[]
  }

  /**
   * anexoProjeto create
   */
  export type anexoProjetoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoProjeto
     */
    select?: anexoProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoProjetoInclude<ExtArgs> | null
    /**
     * The data needed to create a anexoProjeto.
     */
    data: XOR<anexoProjetoCreateInput, anexoProjetoUncheckedCreateInput>
  }

  /**
   * anexoProjeto createMany
   */
  export type anexoProjetoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many anexoProjetos.
     */
    data: anexoProjetoCreateManyInput | anexoProjetoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * anexoProjeto createManyAndReturn
   */
  export type anexoProjetoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoProjeto
     */
    select?: anexoProjetoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many anexoProjetos.
     */
    data: anexoProjetoCreateManyInput | anexoProjetoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoProjetoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * anexoProjeto update
   */
  export type anexoProjetoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoProjeto
     */
    select?: anexoProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoProjetoInclude<ExtArgs> | null
    /**
     * The data needed to update a anexoProjeto.
     */
    data: XOR<anexoProjetoUpdateInput, anexoProjetoUncheckedUpdateInput>
    /**
     * Choose, which anexoProjeto to update.
     */
    where: anexoProjetoWhereUniqueInput
  }

  /**
   * anexoProjeto updateMany
   */
  export type anexoProjetoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update anexoProjetos.
     */
    data: XOR<anexoProjetoUpdateManyMutationInput, anexoProjetoUncheckedUpdateManyInput>
    /**
     * Filter which anexoProjetos to update
     */
    where?: anexoProjetoWhereInput
  }

  /**
   * anexoProjeto upsert
   */
  export type anexoProjetoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoProjeto
     */
    select?: anexoProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoProjetoInclude<ExtArgs> | null
    /**
     * The filter to search for the anexoProjeto to update in case it exists.
     */
    where: anexoProjetoWhereUniqueInput
    /**
     * In case the anexoProjeto found by the `where` argument doesn't exist, create a new anexoProjeto with this data.
     */
    create: XOR<anexoProjetoCreateInput, anexoProjetoUncheckedCreateInput>
    /**
     * In case the anexoProjeto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<anexoProjetoUpdateInput, anexoProjetoUncheckedUpdateInput>
  }

  /**
   * anexoProjeto delete
   */
  export type anexoProjetoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoProjeto
     */
    select?: anexoProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoProjetoInclude<ExtArgs> | null
    /**
     * Filter which anexoProjeto to delete.
     */
    where: anexoProjetoWhereUniqueInput
  }

  /**
   * anexoProjeto deleteMany
   */
  export type anexoProjetoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which anexoProjetos to delete
     */
    where?: anexoProjetoWhereInput
  }

  /**
   * anexoProjeto without action
   */
  export type anexoProjetoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoProjeto
     */
    select?: anexoProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoProjetoInclude<ExtArgs> | null
  }


  /**
   * Model participacaoTarefa
   */

  export type AggregateParticipacaoTarefa = {
    _count: ParticipacaoTarefaCountAggregateOutputType | null
    _avg: ParticipacaoTarefaAvgAggregateOutputType | null
    _sum: ParticipacaoTarefaSumAggregateOutputType | null
    _min: ParticipacaoTarefaMinAggregateOutputType | null
    _max: ParticipacaoTarefaMaxAggregateOutputType | null
  }

  export type ParticipacaoTarefaAvgAggregateOutputType = {
    participacaoTarefa_id: number | null
    tarefa_id: number | null
    projetoUsuario_id: number | null
  }

  export type ParticipacaoTarefaSumAggregateOutputType = {
    participacaoTarefa_id: number | null
    tarefa_id: number | null
    projetoUsuario_id: number | null
  }

  export type ParticipacaoTarefaMinAggregateOutputType = {
    participacaoTarefa_id: number | null
    tarefa_id: number | null
    projetoUsuario_id: number | null
  }

  export type ParticipacaoTarefaMaxAggregateOutputType = {
    participacaoTarefa_id: number | null
    tarefa_id: number | null
    projetoUsuario_id: number | null
  }

  export type ParticipacaoTarefaCountAggregateOutputType = {
    participacaoTarefa_id: number
    tarefa_id: number
    projetoUsuario_id: number
    _all: number
  }


  export type ParticipacaoTarefaAvgAggregateInputType = {
    participacaoTarefa_id?: true
    tarefa_id?: true
    projetoUsuario_id?: true
  }

  export type ParticipacaoTarefaSumAggregateInputType = {
    participacaoTarefa_id?: true
    tarefa_id?: true
    projetoUsuario_id?: true
  }

  export type ParticipacaoTarefaMinAggregateInputType = {
    participacaoTarefa_id?: true
    tarefa_id?: true
    projetoUsuario_id?: true
  }

  export type ParticipacaoTarefaMaxAggregateInputType = {
    participacaoTarefa_id?: true
    tarefa_id?: true
    projetoUsuario_id?: true
  }

  export type ParticipacaoTarefaCountAggregateInputType = {
    participacaoTarefa_id?: true
    tarefa_id?: true
    projetoUsuario_id?: true
    _all?: true
  }

  export type ParticipacaoTarefaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which participacaoTarefa to aggregate.
     */
    where?: participacaoTarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of participacaoTarefas to fetch.
     */
    orderBy?: participacaoTarefaOrderByWithRelationInput | participacaoTarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: participacaoTarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` participacaoTarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` participacaoTarefas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned participacaoTarefas
    **/
    _count?: true | ParticipacaoTarefaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParticipacaoTarefaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParticipacaoTarefaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParticipacaoTarefaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParticipacaoTarefaMaxAggregateInputType
  }

  export type GetParticipacaoTarefaAggregateType<T extends ParticipacaoTarefaAggregateArgs> = {
        [P in keyof T & keyof AggregateParticipacaoTarefa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParticipacaoTarefa[P]>
      : GetScalarType<T[P], AggregateParticipacaoTarefa[P]>
  }




  export type participacaoTarefaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: participacaoTarefaWhereInput
    orderBy?: participacaoTarefaOrderByWithAggregationInput | participacaoTarefaOrderByWithAggregationInput[]
    by: ParticipacaoTarefaScalarFieldEnum[] | ParticipacaoTarefaScalarFieldEnum
    having?: participacaoTarefaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParticipacaoTarefaCountAggregateInputType | true
    _avg?: ParticipacaoTarefaAvgAggregateInputType
    _sum?: ParticipacaoTarefaSumAggregateInputType
    _min?: ParticipacaoTarefaMinAggregateInputType
    _max?: ParticipacaoTarefaMaxAggregateInputType
  }

  export type ParticipacaoTarefaGroupByOutputType = {
    participacaoTarefa_id: number
    tarefa_id: number
    projetoUsuario_id: number
    _count: ParticipacaoTarefaCountAggregateOutputType | null
    _avg: ParticipacaoTarefaAvgAggregateOutputType | null
    _sum: ParticipacaoTarefaSumAggregateOutputType | null
    _min: ParticipacaoTarefaMinAggregateOutputType | null
    _max: ParticipacaoTarefaMaxAggregateOutputType | null
  }

  type GetParticipacaoTarefaGroupByPayload<T extends participacaoTarefaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParticipacaoTarefaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParticipacaoTarefaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParticipacaoTarefaGroupByOutputType[P]>
            : GetScalarType<T[P], ParticipacaoTarefaGroupByOutputType[P]>
        }
      >
    >


  export type participacaoTarefaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    participacaoTarefa_id?: boolean
    tarefa_id?: boolean
    projetoUsuario_id?: boolean
    tarefa?: boolean | tarefaDefaultArgs<ExtArgs>
    projetoUsuario?: boolean | projetoUsuarioDefaultArgs<ExtArgs>
    comentarios?: boolean | participacaoTarefa$comentariosArgs<ExtArgs>
    usuarios?: boolean | participacaoTarefa$usuariosArgs<ExtArgs>
    _count?: boolean | ParticipacaoTarefaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["participacaoTarefa"]>

  export type participacaoTarefaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    participacaoTarefa_id?: boolean
    tarefa_id?: boolean
    projetoUsuario_id?: boolean
    tarefa?: boolean | tarefaDefaultArgs<ExtArgs>
    projetoUsuario?: boolean | projetoUsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["participacaoTarefa"]>

  export type participacaoTarefaSelectScalar = {
    participacaoTarefa_id?: boolean
    tarefa_id?: boolean
    projetoUsuario_id?: boolean
  }

  export type participacaoTarefaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tarefa?: boolean | tarefaDefaultArgs<ExtArgs>
    projetoUsuario?: boolean | projetoUsuarioDefaultArgs<ExtArgs>
    comentarios?: boolean | participacaoTarefa$comentariosArgs<ExtArgs>
    usuarios?: boolean | participacaoTarefa$usuariosArgs<ExtArgs>
    _count?: boolean | ParticipacaoTarefaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type participacaoTarefaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tarefa?: boolean | tarefaDefaultArgs<ExtArgs>
    projetoUsuario?: boolean | projetoUsuarioDefaultArgs<ExtArgs>
  }

  export type $participacaoTarefaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "participacaoTarefa"
    objects: {
      tarefa: Prisma.$tarefaPayload<ExtArgs>
      projetoUsuario: Prisma.$projetoUsuarioPayload<ExtArgs>
      comentarios: Prisma.$comentarioPayload<ExtArgs>[]
      usuarios: Prisma.$usuarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      participacaoTarefa_id: number
      tarefa_id: number
      projetoUsuario_id: number
    }, ExtArgs["result"]["participacaoTarefa"]>
    composites: {}
  }

  type participacaoTarefaGetPayload<S extends boolean | null | undefined | participacaoTarefaDefaultArgs> = $Result.GetResult<Prisma.$participacaoTarefaPayload, S>

  type participacaoTarefaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<participacaoTarefaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ParticipacaoTarefaCountAggregateInputType | true
    }

  export interface participacaoTarefaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['participacaoTarefa'], meta: { name: 'participacaoTarefa' } }
    /**
     * Find zero or one ParticipacaoTarefa that matches the filter.
     * @param {participacaoTarefaFindUniqueArgs} args - Arguments to find a ParticipacaoTarefa
     * @example
     * // Get one ParticipacaoTarefa
     * const participacaoTarefa = await prisma.participacaoTarefa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends participacaoTarefaFindUniqueArgs>(args: SelectSubset<T, participacaoTarefaFindUniqueArgs<ExtArgs>>): Prisma__participacaoTarefaClient<$Result.GetResult<Prisma.$participacaoTarefaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ParticipacaoTarefa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {participacaoTarefaFindUniqueOrThrowArgs} args - Arguments to find a ParticipacaoTarefa
     * @example
     * // Get one ParticipacaoTarefa
     * const participacaoTarefa = await prisma.participacaoTarefa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends participacaoTarefaFindUniqueOrThrowArgs>(args: SelectSubset<T, participacaoTarefaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__participacaoTarefaClient<$Result.GetResult<Prisma.$participacaoTarefaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ParticipacaoTarefa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {participacaoTarefaFindFirstArgs} args - Arguments to find a ParticipacaoTarefa
     * @example
     * // Get one ParticipacaoTarefa
     * const participacaoTarefa = await prisma.participacaoTarefa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends participacaoTarefaFindFirstArgs>(args?: SelectSubset<T, participacaoTarefaFindFirstArgs<ExtArgs>>): Prisma__participacaoTarefaClient<$Result.GetResult<Prisma.$participacaoTarefaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ParticipacaoTarefa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {participacaoTarefaFindFirstOrThrowArgs} args - Arguments to find a ParticipacaoTarefa
     * @example
     * // Get one ParticipacaoTarefa
     * const participacaoTarefa = await prisma.participacaoTarefa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends participacaoTarefaFindFirstOrThrowArgs>(args?: SelectSubset<T, participacaoTarefaFindFirstOrThrowArgs<ExtArgs>>): Prisma__participacaoTarefaClient<$Result.GetResult<Prisma.$participacaoTarefaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ParticipacaoTarefas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {participacaoTarefaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParticipacaoTarefas
     * const participacaoTarefas = await prisma.participacaoTarefa.findMany()
     * 
     * // Get first 10 ParticipacaoTarefas
     * const participacaoTarefas = await prisma.participacaoTarefa.findMany({ take: 10 })
     * 
     * // Only select the `participacaoTarefa_id`
     * const participacaoTarefaWithParticipacaoTarefa_idOnly = await prisma.participacaoTarefa.findMany({ select: { participacaoTarefa_id: true } })
     * 
     */
    findMany<T extends participacaoTarefaFindManyArgs>(args?: SelectSubset<T, participacaoTarefaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$participacaoTarefaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ParticipacaoTarefa.
     * @param {participacaoTarefaCreateArgs} args - Arguments to create a ParticipacaoTarefa.
     * @example
     * // Create one ParticipacaoTarefa
     * const ParticipacaoTarefa = await prisma.participacaoTarefa.create({
     *   data: {
     *     // ... data to create a ParticipacaoTarefa
     *   }
     * })
     * 
     */
    create<T extends participacaoTarefaCreateArgs>(args: SelectSubset<T, participacaoTarefaCreateArgs<ExtArgs>>): Prisma__participacaoTarefaClient<$Result.GetResult<Prisma.$participacaoTarefaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ParticipacaoTarefas.
     * @param {participacaoTarefaCreateManyArgs} args - Arguments to create many ParticipacaoTarefas.
     * @example
     * // Create many ParticipacaoTarefas
     * const participacaoTarefa = await prisma.participacaoTarefa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends participacaoTarefaCreateManyArgs>(args?: SelectSubset<T, participacaoTarefaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParticipacaoTarefas and returns the data saved in the database.
     * @param {participacaoTarefaCreateManyAndReturnArgs} args - Arguments to create many ParticipacaoTarefas.
     * @example
     * // Create many ParticipacaoTarefas
     * const participacaoTarefa = await prisma.participacaoTarefa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParticipacaoTarefas and only return the `participacaoTarefa_id`
     * const participacaoTarefaWithParticipacaoTarefa_idOnly = await prisma.participacaoTarefa.createManyAndReturn({ 
     *   select: { participacaoTarefa_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends participacaoTarefaCreateManyAndReturnArgs>(args?: SelectSubset<T, participacaoTarefaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$participacaoTarefaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ParticipacaoTarefa.
     * @param {participacaoTarefaDeleteArgs} args - Arguments to delete one ParticipacaoTarefa.
     * @example
     * // Delete one ParticipacaoTarefa
     * const ParticipacaoTarefa = await prisma.participacaoTarefa.delete({
     *   where: {
     *     // ... filter to delete one ParticipacaoTarefa
     *   }
     * })
     * 
     */
    delete<T extends participacaoTarefaDeleteArgs>(args: SelectSubset<T, participacaoTarefaDeleteArgs<ExtArgs>>): Prisma__participacaoTarefaClient<$Result.GetResult<Prisma.$participacaoTarefaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ParticipacaoTarefa.
     * @param {participacaoTarefaUpdateArgs} args - Arguments to update one ParticipacaoTarefa.
     * @example
     * // Update one ParticipacaoTarefa
     * const participacaoTarefa = await prisma.participacaoTarefa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends participacaoTarefaUpdateArgs>(args: SelectSubset<T, participacaoTarefaUpdateArgs<ExtArgs>>): Prisma__participacaoTarefaClient<$Result.GetResult<Prisma.$participacaoTarefaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ParticipacaoTarefas.
     * @param {participacaoTarefaDeleteManyArgs} args - Arguments to filter ParticipacaoTarefas to delete.
     * @example
     * // Delete a few ParticipacaoTarefas
     * const { count } = await prisma.participacaoTarefa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends participacaoTarefaDeleteManyArgs>(args?: SelectSubset<T, participacaoTarefaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParticipacaoTarefas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {participacaoTarefaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParticipacaoTarefas
     * const participacaoTarefa = await prisma.participacaoTarefa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends participacaoTarefaUpdateManyArgs>(args: SelectSubset<T, participacaoTarefaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ParticipacaoTarefa.
     * @param {participacaoTarefaUpsertArgs} args - Arguments to update or create a ParticipacaoTarefa.
     * @example
     * // Update or create a ParticipacaoTarefa
     * const participacaoTarefa = await prisma.participacaoTarefa.upsert({
     *   create: {
     *     // ... data to create a ParticipacaoTarefa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParticipacaoTarefa we want to update
     *   }
     * })
     */
    upsert<T extends participacaoTarefaUpsertArgs>(args: SelectSubset<T, participacaoTarefaUpsertArgs<ExtArgs>>): Prisma__participacaoTarefaClient<$Result.GetResult<Prisma.$participacaoTarefaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ParticipacaoTarefas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {participacaoTarefaCountArgs} args - Arguments to filter ParticipacaoTarefas to count.
     * @example
     * // Count the number of ParticipacaoTarefas
     * const count = await prisma.participacaoTarefa.count({
     *   where: {
     *     // ... the filter for the ParticipacaoTarefas we want to count
     *   }
     * })
    **/
    count<T extends participacaoTarefaCountArgs>(
      args?: Subset<T, participacaoTarefaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParticipacaoTarefaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParticipacaoTarefa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipacaoTarefaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParticipacaoTarefaAggregateArgs>(args: Subset<T, ParticipacaoTarefaAggregateArgs>): Prisma.PrismaPromise<GetParticipacaoTarefaAggregateType<T>>

    /**
     * Group by ParticipacaoTarefa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {participacaoTarefaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends participacaoTarefaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: participacaoTarefaGroupByArgs['orderBy'] }
        : { orderBy?: participacaoTarefaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, participacaoTarefaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParticipacaoTarefaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the participacaoTarefa model
   */
  readonly fields: participacaoTarefaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for participacaoTarefa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__participacaoTarefaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tarefa<T extends tarefaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tarefaDefaultArgs<ExtArgs>>): Prisma__tarefaClient<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    projetoUsuario<T extends projetoUsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projetoUsuarioDefaultArgs<ExtArgs>>): Prisma__projetoUsuarioClient<$Result.GetResult<Prisma.$projetoUsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    comentarios<T extends participacaoTarefa$comentariosArgs<ExtArgs> = {}>(args?: Subset<T, participacaoTarefa$comentariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "findMany"> | Null>
    usuarios<T extends participacaoTarefa$usuariosArgs<ExtArgs> = {}>(args?: Subset<T, participacaoTarefa$usuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the participacaoTarefa model
   */ 
  interface participacaoTarefaFieldRefs {
    readonly participacaoTarefa_id: FieldRef<"participacaoTarefa", 'Int'>
    readonly tarefa_id: FieldRef<"participacaoTarefa", 'Int'>
    readonly projetoUsuario_id: FieldRef<"participacaoTarefa", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * participacaoTarefa findUnique
   */
  export type participacaoTarefaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the participacaoTarefa
     */
    select?: participacaoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: participacaoTarefaInclude<ExtArgs> | null
    /**
     * Filter, which participacaoTarefa to fetch.
     */
    where: participacaoTarefaWhereUniqueInput
  }

  /**
   * participacaoTarefa findUniqueOrThrow
   */
  export type participacaoTarefaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the participacaoTarefa
     */
    select?: participacaoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: participacaoTarefaInclude<ExtArgs> | null
    /**
     * Filter, which participacaoTarefa to fetch.
     */
    where: participacaoTarefaWhereUniqueInput
  }

  /**
   * participacaoTarefa findFirst
   */
  export type participacaoTarefaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the participacaoTarefa
     */
    select?: participacaoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: participacaoTarefaInclude<ExtArgs> | null
    /**
     * Filter, which participacaoTarefa to fetch.
     */
    where?: participacaoTarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of participacaoTarefas to fetch.
     */
    orderBy?: participacaoTarefaOrderByWithRelationInput | participacaoTarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for participacaoTarefas.
     */
    cursor?: participacaoTarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` participacaoTarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` participacaoTarefas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of participacaoTarefas.
     */
    distinct?: ParticipacaoTarefaScalarFieldEnum | ParticipacaoTarefaScalarFieldEnum[]
  }

  /**
   * participacaoTarefa findFirstOrThrow
   */
  export type participacaoTarefaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the participacaoTarefa
     */
    select?: participacaoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: participacaoTarefaInclude<ExtArgs> | null
    /**
     * Filter, which participacaoTarefa to fetch.
     */
    where?: participacaoTarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of participacaoTarefas to fetch.
     */
    orderBy?: participacaoTarefaOrderByWithRelationInput | participacaoTarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for participacaoTarefas.
     */
    cursor?: participacaoTarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` participacaoTarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` participacaoTarefas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of participacaoTarefas.
     */
    distinct?: ParticipacaoTarefaScalarFieldEnum | ParticipacaoTarefaScalarFieldEnum[]
  }

  /**
   * participacaoTarefa findMany
   */
  export type participacaoTarefaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the participacaoTarefa
     */
    select?: participacaoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: participacaoTarefaInclude<ExtArgs> | null
    /**
     * Filter, which participacaoTarefas to fetch.
     */
    where?: participacaoTarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of participacaoTarefas to fetch.
     */
    orderBy?: participacaoTarefaOrderByWithRelationInput | participacaoTarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing participacaoTarefas.
     */
    cursor?: participacaoTarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` participacaoTarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` participacaoTarefas.
     */
    skip?: number
    distinct?: ParticipacaoTarefaScalarFieldEnum | ParticipacaoTarefaScalarFieldEnum[]
  }

  /**
   * participacaoTarefa create
   */
  export type participacaoTarefaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the participacaoTarefa
     */
    select?: participacaoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: participacaoTarefaInclude<ExtArgs> | null
    /**
     * The data needed to create a participacaoTarefa.
     */
    data: XOR<participacaoTarefaCreateInput, participacaoTarefaUncheckedCreateInput>
  }

  /**
   * participacaoTarefa createMany
   */
  export type participacaoTarefaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many participacaoTarefas.
     */
    data: participacaoTarefaCreateManyInput | participacaoTarefaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * participacaoTarefa createManyAndReturn
   */
  export type participacaoTarefaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the participacaoTarefa
     */
    select?: participacaoTarefaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many participacaoTarefas.
     */
    data: participacaoTarefaCreateManyInput | participacaoTarefaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: participacaoTarefaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * participacaoTarefa update
   */
  export type participacaoTarefaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the participacaoTarefa
     */
    select?: participacaoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: participacaoTarefaInclude<ExtArgs> | null
    /**
     * The data needed to update a participacaoTarefa.
     */
    data: XOR<participacaoTarefaUpdateInput, participacaoTarefaUncheckedUpdateInput>
    /**
     * Choose, which participacaoTarefa to update.
     */
    where: participacaoTarefaWhereUniqueInput
  }

  /**
   * participacaoTarefa updateMany
   */
  export type participacaoTarefaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update participacaoTarefas.
     */
    data: XOR<participacaoTarefaUpdateManyMutationInput, participacaoTarefaUncheckedUpdateManyInput>
    /**
     * Filter which participacaoTarefas to update
     */
    where?: participacaoTarefaWhereInput
  }

  /**
   * participacaoTarefa upsert
   */
  export type participacaoTarefaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the participacaoTarefa
     */
    select?: participacaoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: participacaoTarefaInclude<ExtArgs> | null
    /**
     * The filter to search for the participacaoTarefa to update in case it exists.
     */
    where: participacaoTarefaWhereUniqueInput
    /**
     * In case the participacaoTarefa found by the `where` argument doesn't exist, create a new participacaoTarefa with this data.
     */
    create: XOR<participacaoTarefaCreateInput, participacaoTarefaUncheckedCreateInput>
    /**
     * In case the participacaoTarefa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<participacaoTarefaUpdateInput, participacaoTarefaUncheckedUpdateInput>
  }

  /**
   * participacaoTarefa delete
   */
  export type participacaoTarefaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the participacaoTarefa
     */
    select?: participacaoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: participacaoTarefaInclude<ExtArgs> | null
    /**
     * Filter which participacaoTarefa to delete.
     */
    where: participacaoTarefaWhereUniqueInput
  }

  /**
   * participacaoTarefa deleteMany
   */
  export type participacaoTarefaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which participacaoTarefas to delete
     */
    where?: participacaoTarefaWhereInput
  }

  /**
   * participacaoTarefa.comentarios
   */
  export type participacaoTarefa$comentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
    where?: comentarioWhereInput
    orderBy?: comentarioOrderByWithRelationInput | comentarioOrderByWithRelationInput[]
    cursor?: comentarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * participacaoTarefa.usuarios
   */
  export type participacaoTarefa$usuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    where?: usuarioWhereInput
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    cursor?: usuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * participacaoTarefa without action
   */
  export type participacaoTarefaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the participacaoTarefa
     */
    select?: participacaoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: participacaoTarefaInclude<ExtArgs> | null
  }


  /**
   * Model comentario
   */

  export type AggregateComentario = {
    _count: ComentarioCountAggregateOutputType | null
    _avg: ComentarioAvgAggregateOutputType | null
    _sum: ComentarioSumAggregateOutputType | null
    _min: ComentarioMinAggregateOutputType | null
    _max: ComentarioMaxAggregateOutputType | null
  }

  export type ComentarioAvgAggregateOutputType = {
    comentario_id: number | null
    participacaoTarefa_id: number | null
    usuario_id: number | null
  }

  export type ComentarioSumAggregateOutputType = {
    comentario_id: number | null
    participacaoTarefa_id: number | null
    usuario_id: number | null
  }

  export type ComentarioMinAggregateOutputType = {
    comentario_id: number | null
    comentario: string | null
    data_hora: Date | null
    participacaoTarefa_id: number | null
    usuario_id: number | null
  }

  export type ComentarioMaxAggregateOutputType = {
    comentario_id: number | null
    comentario: string | null
    data_hora: Date | null
    participacaoTarefa_id: number | null
    usuario_id: number | null
  }

  export type ComentarioCountAggregateOutputType = {
    comentario_id: number
    comentario: number
    data_hora: number
    participacaoTarefa_id: number
    usuario_id: number
    _all: number
  }


  export type ComentarioAvgAggregateInputType = {
    comentario_id?: true
    participacaoTarefa_id?: true
    usuario_id?: true
  }

  export type ComentarioSumAggregateInputType = {
    comentario_id?: true
    participacaoTarefa_id?: true
    usuario_id?: true
  }

  export type ComentarioMinAggregateInputType = {
    comentario_id?: true
    comentario?: true
    data_hora?: true
    participacaoTarefa_id?: true
    usuario_id?: true
  }

  export type ComentarioMaxAggregateInputType = {
    comentario_id?: true
    comentario?: true
    data_hora?: true
    participacaoTarefa_id?: true
    usuario_id?: true
  }

  export type ComentarioCountAggregateInputType = {
    comentario_id?: true
    comentario?: true
    data_hora?: true
    participacaoTarefa_id?: true
    usuario_id?: true
    _all?: true
  }

  export type ComentarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comentario to aggregate.
     */
    where?: comentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentarios to fetch.
     */
    orderBy?: comentarioOrderByWithRelationInput | comentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: comentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comentarios
    **/
    _count?: true | ComentarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComentarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComentarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComentarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComentarioMaxAggregateInputType
  }

  export type GetComentarioAggregateType<T extends ComentarioAggregateArgs> = {
        [P in keyof T & keyof AggregateComentario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComentario[P]>
      : GetScalarType<T[P], AggregateComentario[P]>
  }




  export type comentarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comentarioWhereInput
    orderBy?: comentarioOrderByWithAggregationInput | comentarioOrderByWithAggregationInput[]
    by: ComentarioScalarFieldEnum[] | ComentarioScalarFieldEnum
    having?: comentarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComentarioCountAggregateInputType | true
    _avg?: ComentarioAvgAggregateInputType
    _sum?: ComentarioSumAggregateInputType
    _min?: ComentarioMinAggregateInputType
    _max?: ComentarioMaxAggregateInputType
  }

  export type ComentarioGroupByOutputType = {
    comentario_id: number
    comentario: string
    data_hora: Date
    participacaoTarefa_id: number
    usuario_id: number
    _count: ComentarioCountAggregateOutputType | null
    _avg: ComentarioAvgAggregateOutputType | null
    _sum: ComentarioSumAggregateOutputType | null
    _min: ComentarioMinAggregateOutputType | null
    _max: ComentarioMaxAggregateOutputType | null
  }

  type GetComentarioGroupByPayload<T extends comentarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComentarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComentarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComentarioGroupByOutputType[P]>
            : GetScalarType<T[P], ComentarioGroupByOutputType[P]>
        }
      >
    >


  export type comentarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    comentario_id?: boolean
    comentario?: boolean
    data_hora?: boolean
    participacaoTarefa_id?: boolean
    usuario_id?: boolean
    participacaoTarefa?: boolean | participacaoTarefaDefaultArgs<ExtArgs>
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
    anexos?: boolean | comentario$anexosArgs<ExtArgs>
    _count?: boolean | ComentarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comentario"]>

  export type comentarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    comentario_id?: boolean
    comentario?: boolean
    data_hora?: boolean
    participacaoTarefa_id?: boolean
    usuario_id?: boolean
    participacaoTarefa?: boolean | participacaoTarefaDefaultArgs<ExtArgs>
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comentario"]>

  export type comentarioSelectScalar = {
    comentario_id?: boolean
    comentario?: boolean
    data_hora?: boolean
    participacaoTarefa_id?: boolean
    usuario_id?: boolean
  }

  export type comentarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participacaoTarefa?: boolean | participacaoTarefaDefaultArgs<ExtArgs>
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
    anexos?: boolean | comentario$anexosArgs<ExtArgs>
    _count?: boolean | ComentarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type comentarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participacaoTarefa?: boolean | participacaoTarefaDefaultArgs<ExtArgs>
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
  }

  export type $comentarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "comentario"
    objects: {
      participacaoTarefa: Prisma.$participacaoTarefaPayload<ExtArgs>
      usuario: Prisma.$usuarioPayload<ExtArgs>
      anexos: Prisma.$anexoComentarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      comentario_id: number
      comentario: string
      data_hora: Date
      participacaoTarefa_id: number
      usuario_id: number
    }, ExtArgs["result"]["comentario"]>
    composites: {}
  }

  type comentarioGetPayload<S extends boolean | null | undefined | comentarioDefaultArgs> = $Result.GetResult<Prisma.$comentarioPayload, S>

  type comentarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<comentarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComentarioCountAggregateInputType | true
    }

  export interface comentarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comentario'], meta: { name: 'comentario' } }
    /**
     * Find zero or one Comentario that matches the filter.
     * @param {comentarioFindUniqueArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends comentarioFindUniqueArgs>(args: SelectSubset<T, comentarioFindUniqueArgs<ExtArgs>>): Prisma__comentarioClient<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comentario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {comentarioFindUniqueOrThrowArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends comentarioFindUniqueOrThrowArgs>(args: SelectSubset<T, comentarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__comentarioClient<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comentario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentarioFindFirstArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends comentarioFindFirstArgs>(args?: SelectSubset<T, comentarioFindFirstArgs<ExtArgs>>): Prisma__comentarioClient<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comentario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentarioFindFirstOrThrowArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends comentarioFindFirstOrThrowArgs>(args?: SelectSubset<T, comentarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__comentarioClient<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comentarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comentarios
     * const comentarios = await prisma.comentario.findMany()
     * 
     * // Get first 10 Comentarios
     * const comentarios = await prisma.comentario.findMany({ take: 10 })
     * 
     * // Only select the `comentario_id`
     * const comentarioWithComentario_idOnly = await prisma.comentario.findMany({ select: { comentario_id: true } })
     * 
     */
    findMany<T extends comentarioFindManyArgs>(args?: SelectSubset<T, comentarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comentario.
     * @param {comentarioCreateArgs} args - Arguments to create a Comentario.
     * @example
     * // Create one Comentario
     * const Comentario = await prisma.comentario.create({
     *   data: {
     *     // ... data to create a Comentario
     *   }
     * })
     * 
     */
    create<T extends comentarioCreateArgs>(args: SelectSubset<T, comentarioCreateArgs<ExtArgs>>): Prisma__comentarioClient<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comentarios.
     * @param {comentarioCreateManyArgs} args - Arguments to create many Comentarios.
     * @example
     * // Create many Comentarios
     * const comentario = await prisma.comentario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends comentarioCreateManyArgs>(args?: SelectSubset<T, comentarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comentarios and returns the data saved in the database.
     * @param {comentarioCreateManyAndReturnArgs} args - Arguments to create many Comentarios.
     * @example
     * // Create many Comentarios
     * const comentario = await prisma.comentario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comentarios and only return the `comentario_id`
     * const comentarioWithComentario_idOnly = await prisma.comentario.createManyAndReturn({ 
     *   select: { comentario_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends comentarioCreateManyAndReturnArgs>(args?: SelectSubset<T, comentarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comentario.
     * @param {comentarioDeleteArgs} args - Arguments to delete one Comentario.
     * @example
     * // Delete one Comentario
     * const Comentario = await prisma.comentario.delete({
     *   where: {
     *     // ... filter to delete one Comentario
     *   }
     * })
     * 
     */
    delete<T extends comentarioDeleteArgs>(args: SelectSubset<T, comentarioDeleteArgs<ExtArgs>>): Prisma__comentarioClient<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comentario.
     * @param {comentarioUpdateArgs} args - Arguments to update one Comentario.
     * @example
     * // Update one Comentario
     * const comentario = await prisma.comentario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends comentarioUpdateArgs>(args: SelectSubset<T, comentarioUpdateArgs<ExtArgs>>): Prisma__comentarioClient<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comentarios.
     * @param {comentarioDeleteManyArgs} args - Arguments to filter Comentarios to delete.
     * @example
     * // Delete a few Comentarios
     * const { count } = await prisma.comentario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends comentarioDeleteManyArgs>(args?: SelectSubset<T, comentarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comentarios
     * const comentario = await prisma.comentario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends comentarioUpdateManyArgs>(args: SelectSubset<T, comentarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comentario.
     * @param {comentarioUpsertArgs} args - Arguments to update or create a Comentario.
     * @example
     * // Update or create a Comentario
     * const comentario = await prisma.comentario.upsert({
     *   create: {
     *     // ... data to create a Comentario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comentario we want to update
     *   }
     * })
     */
    upsert<T extends comentarioUpsertArgs>(args: SelectSubset<T, comentarioUpsertArgs<ExtArgs>>): Prisma__comentarioClient<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentarioCountArgs} args - Arguments to filter Comentarios to count.
     * @example
     * // Count the number of Comentarios
     * const count = await prisma.comentario.count({
     *   where: {
     *     // ... the filter for the Comentarios we want to count
     *   }
     * })
    **/
    count<T extends comentarioCountArgs>(
      args?: Subset<T, comentarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComentarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comentario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComentarioAggregateArgs>(args: Subset<T, ComentarioAggregateArgs>): Prisma.PrismaPromise<GetComentarioAggregateType<T>>

    /**
     * Group by Comentario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends comentarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: comentarioGroupByArgs['orderBy'] }
        : { orderBy?: comentarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, comentarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComentarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the comentario model
   */
  readonly fields: comentarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for comentario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__comentarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participacaoTarefa<T extends participacaoTarefaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, participacaoTarefaDefaultArgs<ExtArgs>>): Prisma__participacaoTarefaClient<$Result.GetResult<Prisma.$participacaoTarefaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    usuario<T extends usuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuarioDefaultArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    anexos<T extends comentario$anexosArgs<ExtArgs> = {}>(args?: Subset<T, comentario$anexosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$anexoComentarioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the comentario model
   */ 
  interface comentarioFieldRefs {
    readonly comentario_id: FieldRef<"comentario", 'Int'>
    readonly comentario: FieldRef<"comentario", 'String'>
    readonly data_hora: FieldRef<"comentario", 'DateTime'>
    readonly participacaoTarefa_id: FieldRef<"comentario", 'Int'>
    readonly usuario_id: FieldRef<"comentario", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * comentario findUnique
   */
  export type comentarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
    /**
     * Filter, which comentario to fetch.
     */
    where: comentarioWhereUniqueInput
  }

  /**
   * comentario findUniqueOrThrow
   */
  export type comentarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
    /**
     * Filter, which comentario to fetch.
     */
    where: comentarioWhereUniqueInput
  }

  /**
   * comentario findFirst
   */
  export type comentarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
    /**
     * Filter, which comentario to fetch.
     */
    where?: comentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentarios to fetch.
     */
    orderBy?: comentarioOrderByWithRelationInput | comentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comentarios.
     */
    cursor?: comentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comentarios.
     */
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * comentario findFirstOrThrow
   */
  export type comentarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
    /**
     * Filter, which comentario to fetch.
     */
    where?: comentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentarios to fetch.
     */
    orderBy?: comentarioOrderByWithRelationInput | comentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comentarios.
     */
    cursor?: comentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comentarios.
     */
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * comentario findMany
   */
  export type comentarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
    /**
     * Filter, which comentarios to fetch.
     */
    where?: comentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentarios to fetch.
     */
    orderBy?: comentarioOrderByWithRelationInput | comentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comentarios.
     */
    cursor?: comentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentarios.
     */
    skip?: number
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * comentario create
   */
  export type comentarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
    /**
     * The data needed to create a comentario.
     */
    data: XOR<comentarioCreateInput, comentarioUncheckedCreateInput>
  }

  /**
   * comentario createMany
   */
  export type comentarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comentarios.
     */
    data: comentarioCreateManyInput | comentarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * comentario createManyAndReturn
   */
  export type comentarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many comentarios.
     */
    data: comentarioCreateManyInput | comentarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * comentario update
   */
  export type comentarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
    /**
     * The data needed to update a comentario.
     */
    data: XOR<comentarioUpdateInput, comentarioUncheckedUpdateInput>
    /**
     * Choose, which comentario to update.
     */
    where: comentarioWhereUniqueInput
  }

  /**
   * comentario updateMany
   */
  export type comentarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comentarios.
     */
    data: XOR<comentarioUpdateManyMutationInput, comentarioUncheckedUpdateManyInput>
    /**
     * Filter which comentarios to update
     */
    where?: comentarioWhereInput
  }

  /**
   * comentario upsert
   */
  export type comentarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
    /**
     * The filter to search for the comentario to update in case it exists.
     */
    where: comentarioWhereUniqueInput
    /**
     * In case the comentario found by the `where` argument doesn't exist, create a new comentario with this data.
     */
    create: XOR<comentarioCreateInput, comentarioUncheckedCreateInput>
    /**
     * In case the comentario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<comentarioUpdateInput, comentarioUncheckedUpdateInput>
  }

  /**
   * comentario delete
   */
  export type comentarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
    /**
     * Filter which comentario to delete.
     */
    where: comentarioWhereUniqueInput
  }

  /**
   * comentario deleteMany
   */
  export type comentarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comentarios to delete
     */
    where?: comentarioWhereInput
  }

  /**
   * comentario.anexos
   */
  export type comentario$anexosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoComentario
     */
    select?: anexoComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoComentarioInclude<ExtArgs> | null
    where?: anexoComentarioWhereInput
    orderBy?: anexoComentarioOrderByWithRelationInput | anexoComentarioOrderByWithRelationInput[]
    cursor?: anexoComentarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnexoComentarioScalarFieldEnum | AnexoComentarioScalarFieldEnum[]
  }

  /**
   * comentario without action
   */
  export type comentarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
  }


  /**
   * Model anexoTarefa
   */

  export type AggregateAnexoTarefa = {
    _count: AnexoTarefaCountAggregateOutputType | null
    _avg: AnexoTarefaAvgAggregateOutputType | null
    _sum: AnexoTarefaSumAggregateOutputType | null
    _min: AnexoTarefaMinAggregateOutputType | null
    _max: AnexoTarefaMaxAggregateOutputType | null
  }

  export type AnexoTarefaAvgAggregateOutputType = {
    anexoTarefa_id: number | null
    tarefa_id: number | null
  }

  export type AnexoTarefaSumAggregateOutputType = {
    anexoTarefa_id: number | null
    tarefa_id: number | null
  }

  export type AnexoTarefaMinAggregateOutputType = {
    anexoTarefa_id: number | null
    nome: string | null
    tipo: string | null
    conteudo: Buffer | null
    created_at: Date | null
    tarefa_id: number | null
  }

  export type AnexoTarefaMaxAggregateOutputType = {
    anexoTarefa_id: number | null
    nome: string | null
    tipo: string | null
    conteudo: Buffer | null
    created_at: Date | null
    tarefa_id: number | null
  }

  export type AnexoTarefaCountAggregateOutputType = {
    anexoTarefa_id: number
    nome: number
    tipo: number
    conteudo: number
    created_at: number
    tarefa_id: number
    _all: number
  }


  export type AnexoTarefaAvgAggregateInputType = {
    anexoTarefa_id?: true
    tarefa_id?: true
  }

  export type AnexoTarefaSumAggregateInputType = {
    anexoTarefa_id?: true
    tarefa_id?: true
  }

  export type AnexoTarefaMinAggregateInputType = {
    anexoTarefa_id?: true
    nome?: true
    tipo?: true
    conteudo?: true
    created_at?: true
    tarefa_id?: true
  }

  export type AnexoTarefaMaxAggregateInputType = {
    anexoTarefa_id?: true
    nome?: true
    tipo?: true
    conteudo?: true
    created_at?: true
    tarefa_id?: true
  }

  export type AnexoTarefaCountAggregateInputType = {
    anexoTarefa_id?: true
    nome?: true
    tipo?: true
    conteudo?: true
    created_at?: true
    tarefa_id?: true
    _all?: true
  }

  export type AnexoTarefaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which anexoTarefa to aggregate.
     */
    where?: anexoTarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anexoTarefas to fetch.
     */
    orderBy?: anexoTarefaOrderByWithRelationInput | anexoTarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: anexoTarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anexoTarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anexoTarefas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned anexoTarefas
    **/
    _count?: true | AnexoTarefaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnexoTarefaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnexoTarefaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnexoTarefaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnexoTarefaMaxAggregateInputType
  }

  export type GetAnexoTarefaAggregateType<T extends AnexoTarefaAggregateArgs> = {
        [P in keyof T & keyof AggregateAnexoTarefa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnexoTarefa[P]>
      : GetScalarType<T[P], AggregateAnexoTarefa[P]>
  }




  export type anexoTarefaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: anexoTarefaWhereInput
    orderBy?: anexoTarefaOrderByWithAggregationInput | anexoTarefaOrderByWithAggregationInput[]
    by: AnexoTarefaScalarFieldEnum[] | AnexoTarefaScalarFieldEnum
    having?: anexoTarefaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnexoTarefaCountAggregateInputType | true
    _avg?: AnexoTarefaAvgAggregateInputType
    _sum?: AnexoTarefaSumAggregateInputType
    _min?: AnexoTarefaMinAggregateInputType
    _max?: AnexoTarefaMaxAggregateInputType
  }

  export type AnexoTarefaGroupByOutputType = {
    anexoTarefa_id: number
    nome: string
    tipo: string
    conteudo: Buffer
    created_at: Date
    tarefa_id: number
    _count: AnexoTarefaCountAggregateOutputType | null
    _avg: AnexoTarefaAvgAggregateOutputType | null
    _sum: AnexoTarefaSumAggregateOutputType | null
    _min: AnexoTarefaMinAggregateOutputType | null
    _max: AnexoTarefaMaxAggregateOutputType | null
  }

  type GetAnexoTarefaGroupByPayload<T extends anexoTarefaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnexoTarefaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnexoTarefaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnexoTarefaGroupByOutputType[P]>
            : GetScalarType<T[P], AnexoTarefaGroupByOutputType[P]>
        }
      >
    >


  export type anexoTarefaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    anexoTarefa_id?: boolean
    nome?: boolean
    tipo?: boolean
    conteudo?: boolean
    created_at?: boolean
    tarefa_id?: boolean
    tarefa?: boolean | tarefaDefaultArgs<ExtArgs>
    anexosComentario?: boolean | anexoTarefa$anexosComentarioArgs<ExtArgs>
    _count?: boolean | AnexoTarefaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anexoTarefa"]>

  export type anexoTarefaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    anexoTarefa_id?: boolean
    nome?: boolean
    tipo?: boolean
    conteudo?: boolean
    created_at?: boolean
    tarefa_id?: boolean
    tarefa?: boolean | tarefaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anexoTarefa"]>

  export type anexoTarefaSelectScalar = {
    anexoTarefa_id?: boolean
    nome?: boolean
    tipo?: boolean
    conteudo?: boolean
    created_at?: boolean
    tarefa_id?: boolean
  }

  export type anexoTarefaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tarefa?: boolean | tarefaDefaultArgs<ExtArgs>
    anexosComentario?: boolean | anexoTarefa$anexosComentarioArgs<ExtArgs>
    _count?: boolean | AnexoTarefaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type anexoTarefaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tarefa?: boolean | tarefaDefaultArgs<ExtArgs>
  }

  export type $anexoTarefaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "anexoTarefa"
    objects: {
      tarefa: Prisma.$tarefaPayload<ExtArgs>
      anexosComentario: Prisma.$anexoComentarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      anexoTarefa_id: number
      nome: string
      tipo: string
      conteudo: Buffer
      created_at: Date
      tarefa_id: number
    }, ExtArgs["result"]["anexoTarefa"]>
    composites: {}
  }

  type anexoTarefaGetPayload<S extends boolean | null | undefined | anexoTarefaDefaultArgs> = $Result.GetResult<Prisma.$anexoTarefaPayload, S>

  type anexoTarefaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<anexoTarefaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnexoTarefaCountAggregateInputType | true
    }

  export interface anexoTarefaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['anexoTarefa'], meta: { name: 'anexoTarefa' } }
    /**
     * Find zero or one AnexoTarefa that matches the filter.
     * @param {anexoTarefaFindUniqueArgs} args - Arguments to find a AnexoTarefa
     * @example
     * // Get one AnexoTarefa
     * const anexoTarefa = await prisma.anexoTarefa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends anexoTarefaFindUniqueArgs>(args: SelectSubset<T, anexoTarefaFindUniqueArgs<ExtArgs>>): Prisma__anexoTarefaClient<$Result.GetResult<Prisma.$anexoTarefaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AnexoTarefa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {anexoTarefaFindUniqueOrThrowArgs} args - Arguments to find a AnexoTarefa
     * @example
     * // Get one AnexoTarefa
     * const anexoTarefa = await prisma.anexoTarefa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends anexoTarefaFindUniqueOrThrowArgs>(args: SelectSubset<T, anexoTarefaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__anexoTarefaClient<$Result.GetResult<Prisma.$anexoTarefaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AnexoTarefa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anexoTarefaFindFirstArgs} args - Arguments to find a AnexoTarefa
     * @example
     * // Get one AnexoTarefa
     * const anexoTarefa = await prisma.anexoTarefa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends anexoTarefaFindFirstArgs>(args?: SelectSubset<T, anexoTarefaFindFirstArgs<ExtArgs>>): Prisma__anexoTarefaClient<$Result.GetResult<Prisma.$anexoTarefaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AnexoTarefa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anexoTarefaFindFirstOrThrowArgs} args - Arguments to find a AnexoTarefa
     * @example
     * // Get one AnexoTarefa
     * const anexoTarefa = await prisma.anexoTarefa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends anexoTarefaFindFirstOrThrowArgs>(args?: SelectSubset<T, anexoTarefaFindFirstOrThrowArgs<ExtArgs>>): Prisma__anexoTarefaClient<$Result.GetResult<Prisma.$anexoTarefaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AnexoTarefas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anexoTarefaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnexoTarefas
     * const anexoTarefas = await prisma.anexoTarefa.findMany()
     * 
     * // Get first 10 AnexoTarefas
     * const anexoTarefas = await prisma.anexoTarefa.findMany({ take: 10 })
     * 
     * // Only select the `anexoTarefa_id`
     * const anexoTarefaWithAnexoTarefa_idOnly = await prisma.anexoTarefa.findMany({ select: { anexoTarefa_id: true } })
     * 
     */
    findMany<T extends anexoTarefaFindManyArgs>(args?: SelectSubset<T, anexoTarefaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$anexoTarefaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AnexoTarefa.
     * @param {anexoTarefaCreateArgs} args - Arguments to create a AnexoTarefa.
     * @example
     * // Create one AnexoTarefa
     * const AnexoTarefa = await prisma.anexoTarefa.create({
     *   data: {
     *     // ... data to create a AnexoTarefa
     *   }
     * })
     * 
     */
    create<T extends anexoTarefaCreateArgs>(args: SelectSubset<T, anexoTarefaCreateArgs<ExtArgs>>): Prisma__anexoTarefaClient<$Result.GetResult<Prisma.$anexoTarefaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AnexoTarefas.
     * @param {anexoTarefaCreateManyArgs} args - Arguments to create many AnexoTarefas.
     * @example
     * // Create many AnexoTarefas
     * const anexoTarefa = await prisma.anexoTarefa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends anexoTarefaCreateManyArgs>(args?: SelectSubset<T, anexoTarefaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnexoTarefas and returns the data saved in the database.
     * @param {anexoTarefaCreateManyAndReturnArgs} args - Arguments to create many AnexoTarefas.
     * @example
     * // Create many AnexoTarefas
     * const anexoTarefa = await prisma.anexoTarefa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnexoTarefas and only return the `anexoTarefa_id`
     * const anexoTarefaWithAnexoTarefa_idOnly = await prisma.anexoTarefa.createManyAndReturn({ 
     *   select: { anexoTarefa_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends anexoTarefaCreateManyAndReturnArgs>(args?: SelectSubset<T, anexoTarefaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$anexoTarefaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AnexoTarefa.
     * @param {anexoTarefaDeleteArgs} args - Arguments to delete one AnexoTarefa.
     * @example
     * // Delete one AnexoTarefa
     * const AnexoTarefa = await prisma.anexoTarefa.delete({
     *   where: {
     *     // ... filter to delete one AnexoTarefa
     *   }
     * })
     * 
     */
    delete<T extends anexoTarefaDeleteArgs>(args: SelectSubset<T, anexoTarefaDeleteArgs<ExtArgs>>): Prisma__anexoTarefaClient<$Result.GetResult<Prisma.$anexoTarefaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AnexoTarefa.
     * @param {anexoTarefaUpdateArgs} args - Arguments to update one AnexoTarefa.
     * @example
     * // Update one AnexoTarefa
     * const anexoTarefa = await prisma.anexoTarefa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends anexoTarefaUpdateArgs>(args: SelectSubset<T, anexoTarefaUpdateArgs<ExtArgs>>): Prisma__anexoTarefaClient<$Result.GetResult<Prisma.$anexoTarefaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AnexoTarefas.
     * @param {anexoTarefaDeleteManyArgs} args - Arguments to filter AnexoTarefas to delete.
     * @example
     * // Delete a few AnexoTarefas
     * const { count } = await prisma.anexoTarefa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends anexoTarefaDeleteManyArgs>(args?: SelectSubset<T, anexoTarefaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnexoTarefas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anexoTarefaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnexoTarefas
     * const anexoTarefa = await prisma.anexoTarefa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends anexoTarefaUpdateManyArgs>(args: SelectSubset<T, anexoTarefaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnexoTarefa.
     * @param {anexoTarefaUpsertArgs} args - Arguments to update or create a AnexoTarefa.
     * @example
     * // Update or create a AnexoTarefa
     * const anexoTarefa = await prisma.anexoTarefa.upsert({
     *   create: {
     *     // ... data to create a AnexoTarefa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnexoTarefa we want to update
     *   }
     * })
     */
    upsert<T extends anexoTarefaUpsertArgs>(args: SelectSubset<T, anexoTarefaUpsertArgs<ExtArgs>>): Prisma__anexoTarefaClient<$Result.GetResult<Prisma.$anexoTarefaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AnexoTarefas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anexoTarefaCountArgs} args - Arguments to filter AnexoTarefas to count.
     * @example
     * // Count the number of AnexoTarefas
     * const count = await prisma.anexoTarefa.count({
     *   where: {
     *     // ... the filter for the AnexoTarefas we want to count
     *   }
     * })
    **/
    count<T extends anexoTarefaCountArgs>(
      args?: Subset<T, anexoTarefaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnexoTarefaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnexoTarefa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnexoTarefaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnexoTarefaAggregateArgs>(args: Subset<T, AnexoTarefaAggregateArgs>): Prisma.PrismaPromise<GetAnexoTarefaAggregateType<T>>

    /**
     * Group by AnexoTarefa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anexoTarefaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends anexoTarefaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: anexoTarefaGroupByArgs['orderBy'] }
        : { orderBy?: anexoTarefaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, anexoTarefaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnexoTarefaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the anexoTarefa model
   */
  readonly fields: anexoTarefaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for anexoTarefa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__anexoTarefaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tarefa<T extends tarefaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tarefaDefaultArgs<ExtArgs>>): Prisma__tarefaClient<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    anexosComentario<T extends anexoTarefa$anexosComentarioArgs<ExtArgs> = {}>(args?: Subset<T, anexoTarefa$anexosComentarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$anexoComentarioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the anexoTarefa model
   */ 
  interface anexoTarefaFieldRefs {
    readonly anexoTarefa_id: FieldRef<"anexoTarefa", 'Int'>
    readonly nome: FieldRef<"anexoTarefa", 'String'>
    readonly tipo: FieldRef<"anexoTarefa", 'String'>
    readonly conteudo: FieldRef<"anexoTarefa", 'Bytes'>
    readonly created_at: FieldRef<"anexoTarefa", 'DateTime'>
    readonly tarefa_id: FieldRef<"anexoTarefa", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * anexoTarefa findUnique
   */
  export type anexoTarefaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoTarefa
     */
    select?: anexoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoTarefaInclude<ExtArgs> | null
    /**
     * Filter, which anexoTarefa to fetch.
     */
    where: anexoTarefaWhereUniqueInput
  }

  /**
   * anexoTarefa findUniqueOrThrow
   */
  export type anexoTarefaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoTarefa
     */
    select?: anexoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoTarefaInclude<ExtArgs> | null
    /**
     * Filter, which anexoTarefa to fetch.
     */
    where: anexoTarefaWhereUniqueInput
  }

  /**
   * anexoTarefa findFirst
   */
  export type anexoTarefaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoTarefa
     */
    select?: anexoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoTarefaInclude<ExtArgs> | null
    /**
     * Filter, which anexoTarefa to fetch.
     */
    where?: anexoTarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anexoTarefas to fetch.
     */
    orderBy?: anexoTarefaOrderByWithRelationInput | anexoTarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for anexoTarefas.
     */
    cursor?: anexoTarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anexoTarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anexoTarefas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of anexoTarefas.
     */
    distinct?: AnexoTarefaScalarFieldEnum | AnexoTarefaScalarFieldEnum[]
  }

  /**
   * anexoTarefa findFirstOrThrow
   */
  export type anexoTarefaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoTarefa
     */
    select?: anexoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoTarefaInclude<ExtArgs> | null
    /**
     * Filter, which anexoTarefa to fetch.
     */
    where?: anexoTarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anexoTarefas to fetch.
     */
    orderBy?: anexoTarefaOrderByWithRelationInput | anexoTarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for anexoTarefas.
     */
    cursor?: anexoTarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anexoTarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anexoTarefas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of anexoTarefas.
     */
    distinct?: AnexoTarefaScalarFieldEnum | AnexoTarefaScalarFieldEnum[]
  }

  /**
   * anexoTarefa findMany
   */
  export type anexoTarefaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoTarefa
     */
    select?: anexoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoTarefaInclude<ExtArgs> | null
    /**
     * Filter, which anexoTarefas to fetch.
     */
    where?: anexoTarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anexoTarefas to fetch.
     */
    orderBy?: anexoTarefaOrderByWithRelationInput | anexoTarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing anexoTarefas.
     */
    cursor?: anexoTarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anexoTarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anexoTarefas.
     */
    skip?: number
    distinct?: AnexoTarefaScalarFieldEnum | AnexoTarefaScalarFieldEnum[]
  }

  /**
   * anexoTarefa create
   */
  export type anexoTarefaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoTarefa
     */
    select?: anexoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoTarefaInclude<ExtArgs> | null
    /**
     * The data needed to create a anexoTarefa.
     */
    data: XOR<anexoTarefaCreateInput, anexoTarefaUncheckedCreateInput>
  }

  /**
   * anexoTarefa createMany
   */
  export type anexoTarefaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many anexoTarefas.
     */
    data: anexoTarefaCreateManyInput | anexoTarefaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * anexoTarefa createManyAndReturn
   */
  export type anexoTarefaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoTarefa
     */
    select?: anexoTarefaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many anexoTarefas.
     */
    data: anexoTarefaCreateManyInput | anexoTarefaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoTarefaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * anexoTarefa update
   */
  export type anexoTarefaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoTarefa
     */
    select?: anexoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoTarefaInclude<ExtArgs> | null
    /**
     * The data needed to update a anexoTarefa.
     */
    data: XOR<anexoTarefaUpdateInput, anexoTarefaUncheckedUpdateInput>
    /**
     * Choose, which anexoTarefa to update.
     */
    where: anexoTarefaWhereUniqueInput
  }

  /**
   * anexoTarefa updateMany
   */
  export type anexoTarefaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update anexoTarefas.
     */
    data: XOR<anexoTarefaUpdateManyMutationInput, anexoTarefaUncheckedUpdateManyInput>
    /**
     * Filter which anexoTarefas to update
     */
    where?: anexoTarefaWhereInput
  }

  /**
   * anexoTarefa upsert
   */
  export type anexoTarefaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoTarefa
     */
    select?: anexoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoTarefaInclude<ExtArgs> | null
    /**
     * The filter to search for the anexoTarefa to update in case it exists.
     */
    where: anexoTarefaWhereUniqueInput
    /**
     * In case the anexoTarefa found by the `where` argument doesn't exist, create a new anexoTarefa with this data.
     */
    create: XOR<anexoTarefaCreateInput, anexoTarefaUncheckedCreateInput>
    /**
     * In case the anexoTarefa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<anexoTarefaUpdateInput, anexoTarefaUncheckedUpdateInput>
  }

  /**
   * anexoTarefa delete
   */
  export type anexoTarefaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoTarefa
     */
    select?: anexoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoTarefaInclude<ExtArgs> | null
    /**
     * Filter which anexoTarefa to delete.
     */
    where: anexoTarefaWhereUniqueInput
  }

  /**
   * anexoTarefa deleteMany
   */
  export type anexoTarefaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which anexoTarefas to delete
     */
    where?: anexoTarefaWhereInput
  }

  /**
   * anexoTarefa.anexosComentario
   */
  export type anexoTarefa$anexosComentarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoComentario
     */
    select?: anexoComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoComentarioInclude<ExtArgs> | null
    where?: anexoComentarioWhereInput
    orderBy?: anexoComentarioOrderByWithRelationInput | anexoComentarioOrderByWithRelationInput[]
    cursor?: anexoComentarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnexoComentarioScalarFieldEnum | AnexoComentarioScalarFieldEnum[]
  }

  /**
   * anexoTarefa without action
   */
  export type anexoTarefaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoTarefa
     */
    select?: anexoTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoTarefaInclude<ExtArgs> | null
  }


  /**
   * Model anexoComentario
   */

  export type AggregateAnexoComentario = {
    _count: AnexoComentarioCountAggregateOutputType | null
    _avg: AnexoComentarioAvgAggregateOutputType | null
    _sum: AnexoComentarioSumAggregateOutputType | null
    _min: AnexoComentarioMinAggregateOutputType | null
    _max: AnexoComentarioMaxAggregateOutputType | null
  }

  export type AnexoComentarioAvgAggregateOutputType = {
    anexoComentario_id: number | null
    comentario_id: number | null
    anexoTarefa_id: number | null
  }

  export type AnexoComentarioSumAggregateOutputType = {
    anexoComentario_id: number | null
    comentario_id: number | null
    anexoTarefa_id: number | null
  }

  export type AnexoComentarioMinAggregateOutputType = {
    anexoComentario_id: number | null
    comentario_id: number | null
    anexoTarefa_id: number | null
  }

  export type AnexoComentarioMaxAggregateOutputType = {
    anexoComentario_id: number | null
    comentario_id: number | null
    anexoTarefa_id: number | null
  }

  export type AnexoComentarioCountAggregateOutputType = {
    anexoComentario_id: number
    comentario_id: number
    anexoTarefa_id: number
    _all: number
  }


  export type AnexoComentarioAvgAggregateInputType = {
    anexoComentario_id?: true
    comentario_id?: true
    anexoTarefa_id?: true
  }

  export type AnexoComentarioSumAggregateInputType = {
    anexoComentario_id?: true
    comentario_id?: true
    anexoTarefa_id?: true
  }

  export type AnexoComentarioMinAggregateInputType = {
    anexoComentario_id?: true
    comentario_id?: true
    anexoTarefa_id?: true
  }

  export type AnexoComentarioMaxAggregateInputType = {
    anexoComentario_id?: true
    comentario_id?: true
    anexoTarefa_id?: true
  }

  export type AnexoComentarioCountAggregateInputType = {
    anexoComentario_id?: true
    comentario_id?: true
    anexoTarefa_id?: true
    _all?: true
  }

  export type AnexoComentarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which anexoComentario to aggregate.
     */
    where?: anexoComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anexoComentarios to fetch.
     */
    orderBy?: anexoComentarioOrderByWithRelationInput | anexoComentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: anexoComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anexoComentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anexoComentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned anexoComentarios
    **/
    _count?: true | AnexoComentarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnexoComentarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnexoComentarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnexoComentarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnexoComentarioMaxAggregateInputType
  }

  export type GetAnexoComentarioAggregateType<T extends AnexoComentarioAggregateArgs> = {
        [P in keyof T & keyof AggregateAnexoComentario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnexoComentario[P]>
      : GetScalarType<T[P], AggregateAnexoComentario[P]>
  }




  export type anexoComentarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: anexoComentarioWhereInput
    orderBy?: anexoComentarioOrderByWithAggregationInput | anexoComentarioOrderByWithAggregationInput[]
    by: AnexoComentarioScalarFieldEnum[] | AnexoComentarioScalarFieldEnum
    having?: anexoComentarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnexoComentarioCountAggregateInputType | true
    _avg?: AnexoComentarioAvgAggregateInputType
    _sum?: AnexoComentarioSumAggregateInputType
    _min?: AnexoComentarioMinAggregateInputType
    _max?: AnexoComentarioMaxAggregateInputType
  }

  export type AnexoComentarioGroupByOutputType = {
    anexoComentario_id: number
    comentario_id: number
    anexoTarefa_id: number
    _count: AnexoComentarioCountAggregateOutputType | null
    _avg: AnexoComentarioAvgAggregateOutputType | null
    _sum: AnexoComentarioSumAggregateOutputType | null
    _min: AnexoComentarioMinAggregateOutputType | null
    _max: AnexoComentarioMaxAggregateOutputType | null
  }

  type GetAnexoComentarioGroupByPayload<T extends anexoComentarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnexoComentarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnexoComentarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnexoComentarioGroupByOutputType[P]>
            : GetScalarType<T[P], AnexoComentarioGroupByOutputType[P]>
        }
      >
    >


  export type anexoComentarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    anexoComentario_id?: boolean
    comentario_id?: boolean
    anexoTarefa_id?: boolean
    comentario?: boolean | comentarioDefaultArgs<ExtArgs>
    anexoTarefa?: boolean | anexoTarefaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anexoComentario"]>

  export type anexoComentarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    anexoComentario_id?: boolean
    comentario_id?: boolean
    anexoTarefa_id?: boolean
    comentario?: boolean | comentarioDefaultArgs<ExtArgs>
    anexoTarefa?: boolean | anexoTarefaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anexoComentario"]>

  export type anexoComentarioSelectScalar = {
    anexoComentario_id?: boolean
    comentario_id?: boolean
    anexoTarefa_id?: boolean
  }

  export type anexoComentarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comentario?: boolean | comentarioDefaultArgs<ExtArgs>
    anexoTarefa?: boolean | anexoTarefaDefaultArgs<ExtArgs>
  }
  export type anexoComentarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comentario?: boolean | comentarioDefaultArgs<ExtArgs>
    anexoTarefa?: boolean | anexoTarefaDefaultArgs<ExtArgs>
  }

  export type $anexoComentarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "anexoComentario"
    objects: {
      comentario: Prisma.$comentarioPayload<ExtArgs>
      anexoTarefa: Prisma.$anexoTarefaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      anexoComentario_id: number
      comentario_id: number
      anexoTarefa_id: number
    }, ExtArgs["result"]["anexoComentario"]>
    composites: {}
  }

  type anexoComentarioGetPayload<S extends boolean | null | undefined | anexoComentarioDefaultArgs> = $Result.GetResult<Prisma.$anexoComentarioPayload, S>

  type anexoComentarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<anexoComentarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnexoComentarioCountAggregateInputType | true
    }

  export interface anexoComentarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['anexoComentario'], meta: { name: 'anexoComentario' } }
    /**
     * Find zero or one AnexoComentario that matches the filter.
     * @param {anexoComentarioFindUniqueArgs} args - Arguments to find a AnexoComentario
     * @example
     * // Get one AnexoComentario
     * const anexoComentario = await prisma.anexoComentario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends anexoComentarioFindUniqueArgs>(args: SelectSubset<T, anexoComentarioFindUniqueArgs<ExtArgs>>): Prisma__anexoComentarioClient<$Result.GetResult<Prisma.$anexoComentarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AnexoComentario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {anexoComentarioFindUniqueOrThrowArgs} args - Arguments to find a AnexoComentario
     * @example
     * // Get one AnexoComentario
     * const anexoComentario = await prisma.anexoComentario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends anexoComentarioFindUniqueOrThrowArgs>(args: SelectSubset<T, anexoComentarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__anexoComentarioClient<$Result.GetResult<Prisma.$anexoComentarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AnexoComentario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anexoComentarioFindFirstArgs} args - Arguments to find a AnexoComentario
     * @example
     * // Get one AnexoComentario
     * const anexoComentario = await prisma.anexoComentario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends anexoComentarioFindFirstArgs>(args?: SelectSubset<T, anexoComentarioFindFirstArgs<ExtArgs>>): Prisma__anexoComentarioClient<$Result.GetResult<Prisma.$anexoComentarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AnexoComentario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anexoComentarioFindFirstOrThrowArgs} args - Arguments to find a AnexoComentario
     * @example
     * // Get one AnexoComentario
     * const anexoComentario = await prisma.anexoComentario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends anexoComentarioFindFirstOrThrowArgs>(args?: SelectSubset<T, anexoComentarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__anexoComentarioClient<$Result.GetResult<Prisma.$anexoComentarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AnexoComentarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anexoComentarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnexoComentarios
     * const anexoComentarios = await prisma.anexoComentario.findMany()
     * 
     * // Get first 10 AnexoComentarios
     * const anexoComentarios = await prisma.anexoComentario.findMany({ take: 10 })
     * 
     * // Only select the `anexoComentario_id`
     * const anexoComentarioWithAnexoComentario_idOnly = await prisma.anexoComentario.findMany({ select: { anexoComentario_id: true } })
     * 
     */
    findMany<T extends anexoComentarioFindManyArgs>(args?: SelectSubset<T, anexoComentarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$anexoComentarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AnexoComentario.
     * @param {anexoComentarioCreateArgs} args - Arguments to create a AnexoComentario.
     * @example
     * // Create one AnexoComentario
     * const AnexoComentario = await prisma.anexoComentario.create({
     *   data: {
     *     // ... data to create a AnexoComentario
     *   }
     * })
     * 
     */
    create<T extends anexoComentarioCreateArgs>(args: SelectSubset<T, anexoComentarioCreateArgs<ExtArgs>>): Prisma__anexoComentarioClient<$Result.GetResult<Prisma.$anexoComentarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AnexoComentarios.
     * @param {anexoComentarioCreateManyArgs} args - Arguments to create many AnexoComentarios.
     * @example
     * // Create many AnexoComentarios
     * const anexoComentario = await prisma.anexoComentario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends anexoComentarioCreateManyArgs>(args?: SelectSubset<T, anexoComentarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnexoComentarios and returns the data saved in the database.
     * @param {anexoComentarioCreateManyAndReturnArgs} args - Arguments to create many AnexoComentarios.
     * @example
     * // Create many AnexoComentarios
     * const anexoComentario = await prisma.anexoComentario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnexoComentarios and only return the `anexoComentario_id`
     * const anexoComentarioWithAnexoComentario_idOnly = await prisma.anexoComentario.createManyAndReturn({ 
     *   select: { anexoComentario_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends anexoComentarioCreateManyAndReturnArgs>(args?: SelectSubset<T, anexoComentarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$anexoComentarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AnexoComentario.
     * @param {anexoComentarioDeleteArgs} args - Arguments to delete one AnexoComentario.
     * @example
     * // Delete one AnexoComentario
     * const AnexoComentario = await prisma.anexoComentario.delete({
     *   where: {
     *     // ... filter to delete one AnexoComentario
     *   }
     * })
     * 
     */
    delete<T extends anexoComentarioDeleteArgs>(args: SelectSubset<T, anexoComentarioDeleteArgs<ExtArgs>>): Prisma__anexoComentarioClient<$Result.GetResult<Prisma.$anexoComentarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AnexoComentario.
     * @param {anexoComentarioUpdateArgs} args - Arguments to update one AnexoComentario.
     * @example
     * // Update one AnexoComentario
     * const anexoComentario = await prisma.anexoComentario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends anexoComentarioUpdateArgs>(args: SelectSubset<T, anexoComentarioUpdateArgs<ExtArgs>>): Prisma__anexoComentarioClient<$Result.GetResult<Prisma.$anexoComentarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AnexoComentarios.
     * @param {anexoComentarioDeleteManyArgs} args - Arguments to filter AnexoComentarios to delete.
     * @example
     * // Delete a few AnexoComentarios
     * const { count } = await prisma.anexoComentario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends anexoComentarioDeleteManyArgs>(args?: SelectSubset<T, anexoComentarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnexoComentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anexoComentarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnexoComentarios
     * const anexoComentario = await prisma.anexoComentario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends anexoComentarioUpdateManyArgs>(args: SelectSubset<T, anexoComentarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnexoComentario.
     * @param {anexoComentarioUpsertArgs} args - Arguments to update or create a AnexoComentario.
     * @example
     * // Update or create a AnexoComentario
     * const anexoComentario = await prisma.anexoComentario.upsert({
     *   create: {
     *     // ... data to create a AnexoComentario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnexoComentario we want to update
     *   }
     * })
     */
    upsert<T extends anexoComentarioUpsertArgs>(args: SelectSubset<T, anexoComentarioUpsertArgs<ExtArgs>>): Prisma__anexoComentarioClient<$Result.GetResult<Prisma.$anexoComentarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AnexoComentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anexoComentarioCountArgs} args - Arguments to filter AnexoComentarios to count.
     * @example
     * // Count the number of AnexoComentarios
     * const count = await prisma.anexoComentario.count({
     *   where: {
     *     // ... the filter for the AnexoComentarios we want to count
     *   }
     * })
    **/
    count<T extends anexoComentarioCountArgs>(
      args?: Subset<T, anexoComentarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnexoComentarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnexoComentario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnexoComentarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnexoComentarioAggregateArgs>(args: Subset<T, AnexoComentarioAggregateArgs>): Prisma.PrismaPromise<GetAnexoComentarioAggregateType<T>>

    /**
     * Group by AnexoComentario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {anexoComentarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends anexoComentarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: anexoComentarioGroupByArgs['orderBy'] }
        : { orderBy?: anexoComentarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, anexoComentarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnexoComentarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the anexoComentario model
   */
  readonly fields: anexoComentarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for anexoComentario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__anexoComentarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comentario<T extends comentarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, comentarioDefaultArgs<ExtArgs>>): Prisma__comentarioClient<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    anexoTarefa<T extends anexoTarefaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, anexoTarefaDefaultArgs<ExtArgs>>): Prisma__anexoTarefaClient<$Result.GetResult<Prisma.$anexoTarefaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the anexoComentario model
   */ 
  interface anexoComentarioFieldRefs {
    readonly anexoComentario_id: FieldRef<"anexoComentario", 'Int'>
    readonly comentario_id: FieldRef<"anexoComentario", 'Int'>
    readonly anexoTarefa_id: FieldRef<"anexoComentario", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * anexoComentario findUnique
   */
  export type anexoComentarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoComentario
     */
    select?: anexoComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoComentarioInclude<ExtArgs> | null
    /**
     * Filter, which anexoComentario to fetch.
     */
    where: anexoComentarioWhereUniqueInput
  }

  /**
   * anexoComentario findUniqueOrThrow
   */
  export type anexoComentarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoComentario
     */
    select?: anexoComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoComentarioInclude<ExtArgs> | null
    /**
     * Filter, which anexoComentario to fetch.
     */
    where: anexoComentarioWhereUniqueInput
  }

  /**
   * anexoComentario findFirst
   */
  export type anexoComentarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoComentario
     */
    select?: anexoComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoComentarioInclude<ExtArgs> | null
    /**
     * Filter, which anexoComentario to fetch.
     */
    where?: anexoComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anexoComentarios to fetch.
     */
    orderBy?: anexoComentarioOrderByWithRelationInput | anexoComentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for anexoComentarios.
     */
    cursor?: anexoComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anexoComentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anexoComentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of anexoComentarios.
     */
    distinct?: AnexoComentarioScalarFieldEnum | AnexoComentarioScalarFieldEnum[]
  }

  /**
   * anexoComentario findFirstOrThrow
   */
  export type anexoComentarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoComentario
     */
    select?: anexoComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoComentarioInclude<ExtArgs> | null
    /**
     * Filter, which anexoComentario to fetch.
     */
    where?: anexoComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anexoComentarios to fetch.
     */
    orderBy?: anexoComentarioOrderByWithRelationInput | anexoComentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for anexoComentarios.
     */
    cursor?: anexoComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anexoComentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anexoComentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of anexoComentarios.
     */
    distinct?: AnexoComentarioScalarFieldEnum | AnexoComentarioScalarFieldEnum[]
  }

  /**
   * anexoComentario findMany
   */
  export type anexoComentarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoComentario
     */
    select?: anexoComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoComentarioInclude<ExtArgs> | null
    /**
     * Filter, which anexoComentarios to fetch.
     */
    where?: anexoComentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of anexoComentarios to fetch.
     */
    orderBy?: anexoComentarioOrderByWithRelationInput | anexoComentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing anexoComentarios.
     */
    cursor?: anexoComentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` anexoComentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` anexoComentarios.
     */
    skip?: number
    distinct?: AnexoComentarioScalarFieldEnum | AnexoComentarioScalarFieldEnum[]
  }

  /**
   * anexoComentario create
   */
  export type anexoComentarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoComentario
     */
    select?: anexoComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoComentarioInclude<ExtArgs> | null
    /**
     * The data needed to create a anexoComentario.
     */
    data: XOR<anexoComentarioCreateInput, anexoComentarioUncheckedCreateInput>
  }

  /**
   * anexoComentario createMany
   */
  export type anexoComentarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many anexoComentarios.
     */
    data: anexoComentarioCreateManyInput | anexoComentarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * anexoComentario createManyAndReturn
   */
  export type anexoComentarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoComentario
     */
    select?: anexoComentarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many anexoComentarios.
     */
    data: anexoComentarioCreateManyInput | anexoComentarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoComentarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * anexoComentario update
   */
  export type anexoComentarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoComentario
     */
    select?: anexoComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoComentarioInclude<ExtArgs> | null
    /**
     * The data needed to update a anexoComentario.
     */
    data: XOR<anexoComentarioUpdateInput, anexoComentarioUncheckedUpdateInput>
    /**
     * Choose, which anexoComentario to update.
     */
    where: anexoComentarioWhereUniqueInput
  }

  /**
   * anexoComentario updateMany
   */
  export type anexoComentarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update anexoComentarios.
     */
    data: XOR<anexoComentarioUpdateManyMutationInput, anexoComentarioUncheckedUpdateManyInput>
    /**
     * Filter which anexoComentarios to update
     */
    where?: anexoComentarioWhereInput
  }

  /**
   * anexoComentario upsert
   */
  export type anexoComentarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoComentario
     */
    select?: anexoComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoComentarioInclude<ExtArgs> | null
    /**
     * The filter to search for the anexoComentario to update in case it exists.
     */
    where: anexoComentarioWhereUniqueInput
    /**
     * In case the anexoComentario found by the `where` argument doesn't exist, create a new anexoComentario with this data.
     */
    create: XOR<anexoComentarioCreateInput, anexoComentarioUncheckedCreateInput>
    /**
     * In case the anexoComentario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<anexoComentarioUpdateInput, anexoComentarioUncheckedUpdateInput>
  }

  /**
   * anexoComentario delete
   */
  export type anexoComentarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoComentario
     */
    select?: anexoComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoComentarioInclude<ExtArgs> | null
    /**
     * Filter which anexoComentario to delete.
     */
    where: anexoComentarioWhereUniqueInput
  }

  /**
   * anexoComentario deleteMany
   */
  export type anexoComentarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which anexoComentarios to delete
     */
    where?: anexoComentarioWhereInput
  }

  /**
   * anexoComentario without action
   */
  export type anexoComentarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the anexoComentario
     */
    select?: anexoComentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: anexoComentarioInclude<ExtArgs> | null
  }


  /**
   * Model permissao
   */

  export type AggregatePermissao = {
    _count: PermissaoCountAggregateOutputType | null
    _avg: PermissaoAvgAggregateOutputType | null
    _sum: PermissaoSumAggregateOutputType | null
    _min: PermissaoMinAggregateOutputType | null
    _max: PermissaoMaxAggregateOutputType | null
  }

  export type PermissaoAvgAggregateOutputType = {
    permissao_id: number | null
    usuario_id: number | null
  }

  export type PermissaoSumAggregateOutputType = {
    permissao_id: number | null
    usuario_id: number | null
  }

  export type PermissaoMinAggregateOutputType = {
    permissao_id: number | null
    tipo: string | null
    usuario_id: number | null
  }

  export type PermissaoMaxAggregateOutputType = {
    permissao_id: number | null
    tipo: string | null
    usuario_id: number | null
  }

  export type PermissaoCountAggregateOutputType = {
    permissao_id: number
    tipo: number
    usuario_id: number
    _all: number
  }


  export type PermissaoAvgAggregateInputType = {
    permissao_id?: true
    usuario_id?: true
  }

  export type PermissaoSumAggregateInputType = {
    permissao_id?: true
    usuario_id?: true
  }

  export type PermissaoMinAggregateInputType = {
    permissao_id?: true
    tipo?: true
    usuario_id?: true
  }

  export type PermissaoMaxAggregateInputType = {
    permissao_id?: true
    tipo?: true
    usuario_id?: true
  }

  export type PermissaoCountAggregateInputType = {
    permissao_id?: true
    tipo?: true
    usuario_id?: true
    _all?: true
  }

  export type PermissaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissao to aggregate.
     */
    where?: permissaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissaos to fetch.
     */
    orderBy?: permissaoOrderByWithRelationInput | permissaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: permissaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned permissaos
    **/
    _count?: true | PermissaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissaoMaxAggregateInputType
  }

  export type GetPermissaoAggregateType<T extends PermissaoAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermissao[P]>
      : GetScalarType<T[P], AggregatePermissao[P]>
  }




  export type permissaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permissaoWhereInput
    orderBy?: permissaoOrderByWithAggregationInput | permissaoOrderByWithAggregationInput[]
    by: PermissaoScalarFieldEnum[] | PermissaoScalarFieldEnum
    having?: permissaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissaoCountAggregateInputType | true
    _avg?: PermissaoAvgAggregateInputType
    _sum?: PermissaoSumAggregateInputType
    _min?: PermissaoMinAggregateInputType
    _max?: PermissaoMaxAggregateInputType
  }

  export type PermissaoGroupByOutputType = {
    permissao_id: number
    tipo: string
    usuario_id: number
    _count: PermissaoCountAggregateOutputType | null
    _avg: PermissaoAvgAggregateOutputType | null
    _sum: PermissaoSumAggregateOutputType | null
    _min: PermissaoMinAggregateOutputType | null
    _max: PermissaoMaxAggregateOutputType | null
  }

  type GetPermissaoGroupByPayload<T extends permissaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissaoGroupByOutputType[P]>
            : GetScalarType<T[P], PermissaoGroupByOutputType[P]>
        }
      >
    >


  export type permissaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permissao_id?: boolean
    tipo?: boolean
    usuario_id?: boolean
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissao"]>

  export type permissaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permissao_id?: boolean
    tipo?: boolean
    usuario_id?: boolean
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissao"]>

  export type permissaoSelectScalar = {
    permissao_id?: boolean
    tipo?: boolean
    usuario_id?: boolean
  }

  export type permissaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
  }
  export type permissaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
  }

  export type $permissaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "permissao"
    objects: {
      usuario: Prisma.$usuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      permissao_id: number
      tipo: string
      usuario_id: number
    }, ExtArgs["result"]["permissao"]>
    composites: {}
  }

  type permissaoGetPayload<S extends boolean | null | undefined | permissaoDefaultArgs> = $Result.GetResult<Prisma.$permissaoPayload, S>

  type permissaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<permissaoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissaoCountAggregateInputType | true
    }

  export interface permissaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['permissao'], meta: { name: 'permissao' } }
    /**
     * Find zero or one Permissao that matches the filter.
     * @param {permissaoFindUniqueArgs} args - Arguments to find a Permissao
     * @example
     * // Get one Permissao
     * const permissao = await prisma.permissao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends permissaoFindUniqueArgs>(args: SelectSubset<T, permissaoFindUniqueArgs<ExtArgs>>): Prisma__permissaoClient<$Result.GetResult<Prisma.$permissaoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Permissao that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {permissaoFindUniqueOrThrowArgs} args - Arguments to find a Permissao
     * @example
     * // Get one Permissao
     * const permissao = await prisma.permissao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends permissaoFindUniqueOrThrowArgs>(args: SelectSubset<T, permissaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__permissaoClient<$Result.GetResult<Prisma.$permissaoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Permissao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissaoFindFirstArgs} args - Arguments to find a Permissao
     * @example
     * // Get one Permissao
     * const permissao = await prisma.permissao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends permissaoFindFirstArgs>(args?: SelectSubset<T, permissaoFindFirstArgs<ExtArgs>>): Prisma__permissaoClient<$Result.GetResult<Prisma.$permissaoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Permissao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissaoFindFirstOrThrowArgs} args - Arguments to find a Permissao
     * @example
     * // Get one Permissao
     * const permissao = await prisma.permissao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends permissaoFindFirstOrThrowArgs>(args?: SelectSubset<T, permissaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__permissaoClient<$Result.GetResult<Prisma.$permissaoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Permissaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissaos
     * const permissaos = await prisma.permissao.findMany()
     * 
     * // Get first 10 Permissaos
     * const permissaos = await prisma.permissao.findMany({ take: 10 })
     * 
     * // Only select the `permissao_id`
     * const permissaoWithPermissao_idOnly = await prisma.permissao.findMany({ select: { permissao_id: true } })
     * 
     */
    findMany<T extends permissaoFindManyArgs>(args?: SelectSubset<T, permissaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissaoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Permissao.
     * @param {permissaoCreateArgs} args - Arguments to create a Permissao.
     * @example
     * // Create one Permissao
     * const Permissao = await prisma.permissao.create({
     *   data: {
     *     // ... data to create a Permissao
     *   }
     * })
     * 
     */
    create<T extends permissaoCreateArgs>(args: SelectSubset<T, permissaoCreateArgs<ExtArgs>>): Prisma__permissaoClient<$Result.GetResult<Prisma.$permissaoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Permissaos.
     * @param {permissaoCreateManyArgs} args - Arguments to create many Permissaos.
     * @example
     * // Create many Permissaos
     * const permissao = await prisma.permissao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends permissaoCreateManyArgs>(args?: SelectSubset<T, permissaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissaos and returns the data saved in the database.
     * @param {permissaoCreateManyAndReturnArgs} args - Arguments to create many Permissaos.
     * @example
     * // Create many Permissaos
     * const permissao = await prisma.permissao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissaos and only return the `permissao_id`
     * const permissaoWithPermissao_idOnly = await prisma.permissao.createManyAndReturn({ 
     *   select: { permissao_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends permissaoCreateManyAndReturnArgs>(args?: SelectSubset<T, permissaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissaoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Permissao.
     * @param {permissaoDeleteArgs} args - Arguments to delete one Permissao.
     * @example
     * // Delete one Permissao
     * const Permissao = await prisma.permissao.delete({
     *   where: {
     *     // ... filter to delete one Permissao
     *   }
     * })
     * 
     */
    delete<T extends permissaoDeleteArgs>(args: SelectSubset<T, permissaoDeleteArgs<ExtArgs>>): Prisma__permissaoClient<$Result.GetResult<Prisma.$permissaoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Permissao.
     * @param {permissaoUpdateArgs} args - Arguments to update one Permissao.
     * @example
     * // Update one Permissao
     * const permissao = await prisma.permissao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends permissaoUpdateArgs>(args: SelectSubset<T, permissaoUpdateArgs<ExtArgs>>): Prisma__permissaoClient<$Result.GetResult<Prisma.$permissaoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Permissaos.
     * @param {permissaoDeleteManyArgs} args - Arguments to filter Permissaos to delete.
     * @example
     * // Delete a few Permissaos
     * const { count } = await prisma.permissao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends permissaoDeleteManyArgs>(args?: SelectSubset<T, permissaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissaos
     * const permissao = await prisma.permissao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends permissaoUpdateManyArgs>(args: SelectSubset<T, permissaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permissao.
     * @param {permissaoUpsertArgs} args - Arguments to update or create a Permissao.
     * @example
     * // Update or create a Permissao
     * const permissao = await prisma.permissao.upsert({
     *   create: {
     *     // ... data to create a Permissao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permissao we want to update
     *   }
     * })
     */
    upsert<T extends permissaoUpsertArgs>(args: SelectSubset<T, permissaoUpsertArgs<ExtArgs>>): Prisma__permissaoClient<$Result.GetResult<Prisma.$permissaoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Permissaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissaoCountArgs} args - Arguments to filter Permissaos to count.
     * @example
     * // Count the number of Permissaos
     * const count = await prisma.permissao.count({
     *   where: {
     *     // ... the filter for the Permissaos we want to count
     *   }
     * })
    **/
    count<T extends permissaoCountArgs>(
      args?: Subset<T, permissaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permissao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissaoAggregateArgs>(args: Subset<T, PermissaoAggregateArgs>): Prisma.PrismaPromise<GetPermissaoAggregateType<T>>

    /**
     * Group by Permissao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends permissaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: permissaoGroupByArgs['orderBy'] }
        : { orderBy?: permissaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, permissaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the permissao model
   */
  readonly fields: permissaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for permissao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__permissaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends usuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuarioDefaultArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the permissao model
   */ 
  interface permissaoFieldRefs {
    readonly permissao_id: FieldRef<"permissao", 'Int'>
    readonly tipo: FieldRef<"permissao", 'String'>
    readonly usuario_id: FieldRef<"permissao", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * permissao findUnique
   */
  export type permissaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissao
     */
    select?: permissaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoInclude<ExtArgs> | null
    /**
     * Filter, which permissao to fetch.
     */
    where: permissaoWhereUniqueInput
  }

  /**
   * permissao findUniqueOrThrow
   */
  export type permissaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissao
     */
    select?: permissaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoInclude<ExtArgs> | null
    /**
     * Filter, which permissao to fetch.
     */
    where: permissaoWhereUniqueInput
  }

  /**
   * permissao findFirst
   */
  export type permissaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissao
     */
    select?: permissaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoInclude<ExtArgs> | null
    /**
     * Filter, which permissao to fetch.
     */
    where?: permissaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissaos to fetch.
     */
    orderBy?: permissaoOrderByWithRelationInput | permissaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissaos.
     */
    cursor?: permissaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissaos.
     */
    distinct?: PermissaoScalarFieldEnum | PermissaoScalarFieldEnum[]
  }

  /**
   * permissao findFirstOrThrow
   */
  export type permissaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissao
     */
    select?: permissaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoInclude<ExtArgs> | null
    /**
     * Filter, which permissao to fetch.
     */
    where?: permissaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissaos to fetch.
     */
    orderBy?: permissaoOrderByWithRelationInput | permissaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissaos.
     */
    cursor?: permissaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissaos.
     */
    distinct?: PermissaoScalarFieldEnum | PermissaoScalarFieldEnum[]
  }

  /**
   * permissao findMany
   */
  export type permissaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissao
     */
    select?: permissaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoInclude<ExtArgs> | null
    /**
     * Filter, which permissaos to fetch.
     */
    where?: permissaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissaos to fetch.
     */
    orderBy?: permissaoOrderByWithRelationInput | permissaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing permissaos.
     */
    cursor?: permissaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissaos.
     */
    skip?: number
    distinct?: PermissaoScalarFieldEnum | PermissaoScalarFieldEnum[]
  }

  /**
   * permissao create
   */
  export type permissaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissao
     */
    select?: permissaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoInclude<ExtArgs> | null
    /**
     * The data needed to create a permissao.
     */
    data: XOR<permissaoCreateInput, permissaoUncheckedCreateInput>
  }

  /**
   * permissao createMany
   */
  export type permissaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many permissaos.
     */
    data: permissaoCreateManyInput | permissaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * permissao createManyAndReturn
   */
  export type permissaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissao
     */
    select?: permissaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many permissaos.
     */
    data: permissaoCreateManyInput | permissaoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * permissao update
   */
  export type permissaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissao
     */
    select?: permissaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoInclude<ExtArgs> | null
    /**
     * The data needed to update a permissao.
     */
    data: XOR<permissaoUpdateInput, permissaoUncheckedUpdateInput>
    /**
     * Choose, which permissao to update.
     */
    where: permissaoWhereUniqueInput
  }

  /**
   * permissao updateMany
   */
  export type permissaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update permissaos.
     */
    data: XOR<permissaoUpdateManyMutationInput, permissaoUncheckedUpdateManyInput>
    /**
     * Filter which permissaos to update
     */
    where?: permissaoWhereInput
  }

  /**
   * permissao upsert
   */
  export type permissaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissao
     */
    select?: permissaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoInclude<ExtArgs> | null
    /**
     * The filter to search for the permissao to update in case it exists.
     */
    where: permissaoWhereUniqueInput
    /**
     * In case the permissao found by the `where` argument doesn't exist, create a new permissao with this data.
     */
    create: XOR<permissaoCreateInput, permissaoUncheckedCreateInput>
    /**
     * In case the permissao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<permissaoUpdateInput, permissaoUncheckedUpdateInput>
  }

  /**
   * permissao delete
   */
  export type permissaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissao
     */
    select?: permissaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoInclude<ExtArgs> | null
    /**
     * Filter which permissao to delete.
     */
    where: permissaoWhereUniqueInput
  }

  /**
   * permissao deleteMany
   */
  export type permissaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissaos to delete
     */
    where?: permissaoWhereInput
  }

  /**
   * permissao without action
   */
  export type permissaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissao
     */
    select?: permissaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoInclude<ExtArgs> | null
  }


  /**
   * Model permissaoProjeto
   */

  export type AggregatePermissaoProjeto = {
    _count: PermissaoProjetoCountAggregateOutputType | null
    _avg: PermissaoProjetoAvgAggregateOutputType | null
    _sum: PermissaoProjetoSumAggregateOutputType | null
    _min: PermissaoProjetoMinAggregateOutputType | null
    _max: PermissaoProjetoMaxAggregateOutputType | null
  }

  export type PermissaoProjetoAvgAggregateOutputType = {
    permissaoProjeto_id: number | null
    usuario_id: number | null
    projeto_id: number | null
  }

  export type PermissaoProjetoSumAggregateOutputType = {
    permissaoProjeto_id: number | null
    usuario_id: number | null
    projeto_id: number | null
  }

  export type PermissaoProjetoMinAggregateOutputType = {
    permissaoProjeto_id: number | null
    tipo: string | null
    usuario_id: number | null
    projeto_id: number | null
  }

  export type PermissaoProjetoMaxAggregateOutputType = {
    permissaoProjeto_id: number | null
    tipo: string | null
    usuario_id: number | null
    projeto_id: number | null
  }

  export type PermissaoProjetoCountAggregateOutputType = {
    permissaoProjeto_id: number
    tipo: number
    usuario_id: number
    projeto_id: number
    _all: number
  }


  export type PermissaoProjetoAvgAggregateInputType = {
    permissaoProjeto_id?: true
    usuario_id?: true
    projeto_id?: true
  }

  export type PermissaoProjetoSumAggregateInputType = {
    permissaoProjeto_id?: true
    usuario_id?: true
    projeto_id?: true
  }

  export type PermissaoProjetoMinAggregateInputType = {
    permissaoProjeto_id?: true
    tipo?: true
    usuario_id?: true
    projeto_id?: true
  }

  export type PermissaoProjetoMaxAggregateInputType = {
    permissaoProjeto_id?: true
    tipo?: true
    usuario_id?: true
    projeto_id?: true
  }

  export type PermissaoProjetoCountAggregateInputType = {
    permissaoProjeto_id?: true
    tipo?: true
    usuario_id?: true
    projeto_id?: true
    _all?: true
  }

  export type PermissaoProjetoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissaoProjeto to aggregate.
     */
    where?: permissaoProjetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissaoProjetos to fetch.
     */
    orderBy?: permissaoProjetoOrderByWithRelationInput | permissaoProjetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: permissaoProjetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissaoProjetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissaoProjetos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned permissaoProjetos
    **/
    _count?: true | PermissaoProjetoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissaoProjetoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissaoProjetoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissaoProjetoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissaoProjetoMaxAggregateInputType
  }

  export type GetPermissaoProjetoAggregateType<T extends PermissaoProjetoAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissaoProjeto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermissaoProjeto[P]>
      : GetScalarType<T[P], AggregatePermissaoProjeto[P]>
  }




  export type permissaoProjetoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permissaoProjetoWhereInput
    orderBy?: permissaoProjetoOrderByWithAggregationInput | permissaoProjetoOrderByWithAggregationInput[]
    by: PermissaoProjetoScalarFieldEnum[] | PermissaoProjetoScalarFieldEnum
    having?: permissaoProjetoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissaoProjetoCountAggregateInputType | true
    _avg?: PermissaoProjetoAvgAggregateInputType
    _sum?: PermissaoProjetoSumAggregateInputType
    _min?: PermissaoProjetoMinAggregateInputType
    _max?: PermissaoProjetoMaxAggregateInputType
  }

  export type PermissaoProjetoGroupByOutputType = {
    permissaoProjeto_id: number
    tipo: string
    usuario_id: number
    projeto_id: number
    _count: PermissaoProjetoCountAggregateOutputType | null
    _avg: PermissaoProjetoAvgAggregateOutputType | null
    _sum: PermissaoProjetoSumAggregateOutputType | null
    _min: PermissaoProjetoMinAggregateOutputType | null
    _max: PermissaoProjetoMaxAggregateOutputType | null
  }

  type GetPermissaoProjetoGroupByPayload<T extends permissaoProjetoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissaoProjetoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissaoProjetoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissaoProjetoGroupByOutputType[P]>
            : GetScalarType<T[P], PermissaoProjetoGroupByOutputType[P]>
        }
      >
    >


  export type permissaoProjetoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permissaoProjeto_id?: boolean
    tipo?: boolean
    usuario_id?: boolean
    projeto_id?: boolean
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
    projeto?: boolean | projetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissaoProjeto"]>

  export type permissaoProjetoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permissaoProjeto_id?: boolean
    tipo?: boolean
    usuario_id?: boolean
    projeto_id?: boolean
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
    projeto?: boolean | projetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissaoProjeto"]>

  export type permissaoProjetoSelectScalar = {
    permissaoProjeto_id?: boolean
    tipo?: boolean
    usuario_id?: boolean
    projeto_id?: boolean
  }

  export type permissaoProjetoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
    projeto?: boolean | projetoDefaultArgs<ExtArgs>
  }
  export type permissaoProjetoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
    projeto?: boolean | projetoDefaultArgs<ExtArgs>
  }

  export type $permissaoProjetoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "permissaoProjeto"
    objects: {
      usuario: Prisma.$usuarioPayload<ExtArgs>
      projeto: Prisma.$projetoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      permissaoProjeto_id: number
      tipo: string
      usuario_id: number
      projeto_id: number
    }, ExtArgs["result"]["permissaoProjeto"]>
    composites: {}
  }

  type permissaoProjetoGetPayload<S extends boolean | null | undefined | permissaoProjetoDefaultArgs> = $Result.GetResult<Prisma.$permissaoProjetoPayload, S>

  type permissaoProjetoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<permissaoProjetoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissaoProjetoCountAggregateInputType | true
    }

  export interface permissaoProjetoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['permissaoProjeto'], meta: { name: 'permissaoProjeto' } }
    /**
     * Find zero or one PermissaoProjeto that matches the filter.
     * @param {permissaoProjetoFindUniqueArgs} args - Arguments to find a PermissaoProjeto
     * @example
     * // Get one PermissaoProjeto
     * const permissaoProjeto = await prisma.permissaoProjeto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends permissaoProjetoFindUniqueArgs>(args: SelectSubset<T, permissaoProjetoFindUniqueArgs<ExtArgs>>): Prisma__permissaoProjetoClient<$Result.GetResult<Prisma.$permissaoProjetoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PermissaoProjeto that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {permissaoProjetoFindUniqueOrThrowArgs} args - Arguments to find a PermissaoProjeto
     * @example
     * // Get one PermissaoProjeto
     * const permissaoProjeto = await prisma.permissaoProjeto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends permissaoProjetoFindUniqueOrThrowArgs>(args: SelectSubset<T, permissaoProjetoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__permissaoProjetoClient<$Result.GetResult<Prisma.$permissaoProjetoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PermissaoProjeto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissaoProjetoFindFirstArgs} args - Arguments to find a PermissaoProjeto
     * @example
     * // Get one PermissaoProjeto
     * const permissaoProjeto = await prisma.permissaoProjeto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends permissaoProjetoFindFirstArgs>(args?: SelectSubset<T, permissaoProjetoFindFirstArgs<ExtArgs>>): Prisma__permissaoProjetoClient<$Result.GetResult<Prisma.$permissaoProjetoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PermissaoProjeto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissaoProjetoFindFirstOrThrowArgs} args - Arguments to find a PermissaoProjeto
     * @example
     * // Get one PermissaoProjeto
     * const permissaoProjeto = await prisma.permissaoProjeto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends permissaoProjetoFindFirstOrThrowArgs>(args?: SelectSubset<T, permissaoProjetoFindFirstOrThrowArgs<ExtArgs>>): Prisma__permissaoProjetoClient<$Result.GetResult<Prisma.$permissaoProjetoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PermissaoProjetos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissaoProjetoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PermissaoProjetos
     * const permissaoProjetos = await prisma.permissaoProjeto.findMany()
     * 
     * // Get first 10 PermissaoProjetos
     * const permissaoProjetos = await prisma.permissaoProjeto.findMany({ take: 10 })
     * 
     * // Only select the `permissaoProjeto_id`
     * const permissaoProjetoWithPermissaoProjeto_idOnly = await prisma.permissaoProjeto.findMany({ select: { permissaoProjeto_id: true } })
     * 
     */
    findMany<T extends permissaoProjetoFindManyArgs>(args?: SelectSubset<T, permissaoProjetoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissaoProjetoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PermissaoProjeto.
     * @param {permissaoProjetoCreateArgs} args - Arguments to create a PermissaoProjeto.
     * @example
     * // Create one PermissaoProjeto
     * const PermissaoProjeto = await prisma.permissaoProjeto.create({
     *   data: {
     *     // ... data to create a PermissaoProjeto
     *   }
     * })
     * 
     */
    create<T extends permissaoProjetoCreateArgs>(args: SelectSubset<T, permissaoProjetoCreateArgs<ExtArgs>>): Prisma__permissaoProjetoClient<$Result.GetResult<Prisma.$permissaoProjetoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PermissaoProjetos.
     * @param {permissaoProjetoCreateManyArgs} args - Arguments to create many PermissaoProjetos.
     * @example
     * // Create many PermissaoProjetos
     * const permissaoProjeto = await prisma.permissaoProjeto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends permissaoProjetoCreateManyArgs>(args?: SelectSubset<T, permissaoProjetoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PermissaoProjetos and returns the data saved in the database.
     * @param {permissaoProjetoCreateManyAndReturnArgs} args - Arguments to create many PermissaoProjetos.
     * @example
     * // Create many PermissaoProjetos
     * const permissaoProjeto = await prisma.permissaoProjeto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PermissaoProjetos and only return the `permissaoProjeto_id`
     * const permissaoProjetoWithPermissaoProjeto_idOnly = await prisma.permissaoProjeto.createManyAndReturn({ 
     *   select: { permissaoProjeto_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends permissaoProjetoCreateManyAndReturnArgs>(args?: SelectSubset<T, permissaoProjetoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissaoProjetoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PermissaoProjeto.
     * @param {permissaoProjetoDeleteArgs} args - Arguments to delete one PermissaoProjeto.
     * @example
     * // Delete one PermissaoProjeto
     * const PermissaoProjeto = await prisma.permissaoProjeto.delete({
     *   where: {
     *     // ... filter to delete one PermissaoProjeto
     *   }
     * })
     * 
     */
    delete<T extends permissaoProjetoDeleteArgs>(args: SelectSubset<T, permissaoProjetoDeleteArgs<ExtArgs>>): Prisma__permissaoProjetoClient<$Result.GetResult<Prisma.$permissaoProjetoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PermissaoProjeto.
     * @param {permissaoProjetoUpdateArgs} args - Arguments to update one PermissaoProjeto.
     * @example
     * // Update one PermissaoProjeto
     * const permissaoProjeto = await prisma.permissaoProjeto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends permissaoProjetoUpdateArgs>(args: SelectSubset<T, permissaoProjetoUpdateArgs<ExtArgs>>): Prisma__permissaoProjetoClient<$Result.GetResult<Prisma.$permissaoProjetoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PermissaoProjetos.
     * @param {permissaoProjetoDeleteManyArgs} args - Arguments to filter PermissaoProjetos to delete.
     * @example
     * // Delete a few PermissaoProjetos
     * const { count } = await prisma.permissaoProjeto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends permissaoProjetoDeleteManyArgs>(args?: SelectSubset<T, permissaoProjetoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PermissaoProjetos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissaoProjetoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PermissaoProjetos
     * const permissaoProjeto = await prisma.permissaoProjeto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends permissaoProjetoUpdateManyArgs>(args: SelectSubset<T, permissaoProjetoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PermissaoProjeto.
     * @param {permissaoProjetoUpsertArgs} args - Arguments to update or create a PermissaoProjeto.
     * @example
     * // Update or create a PermissaoProjeto
     * const permissaoProjeto = await prisma.permissaoProjeto.upsert({
     *   create: {
     *     // ... data to create a PermissaoProjeto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PermissaoProjeto we want to update
     *   }
     * })
     */
    upsert<T extends permissaoProjetoUpsertArgs>(args: SelectSubset<T, permissaoProjetoUpsertArgs<ExtArgs>>): Prisma__permissaoProjetoClient<$Result.GetResult<Prisma.$permissaoProjetoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PermissaoProjetos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissaoProjetoCountArgs} args - Arguments to filter PermissaoProjetos to count.
     * @example
     * // Count the number of PermissaoProjetos
     * const count = await prisma.permissaoProjeto.count({
     *   where: {
     *     // ... the filter for the PermissaoProjetos we want to count
     *   }
     * })
    **/
    count<T extends permissaoProjetoCountArgs>(
      args?: Subset<T, permissaoProjetoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissaoProjetoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PermissaoProjeto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissaoProjetoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissaoProjetoAggregateArgs>(args: Subset<T, PermissaoProjetoAggregateArgs>): Prisma.PrismaPromise<GetPermissaoProjetoAggregateType<T>>

    /**
     * Group by PermissaoProjeto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissaoProjetoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends permissaoProjetoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: permissaoProjetoGroupByArgs['orderBy'] }
        : { orderBy?: permissaoProjetoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, permissaoProjetoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissaoProjetoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the permissaoProjeto model
   */
  readonly fields: permissaoProjetoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for permissaoProjeto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__permissaoProjetoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends usuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuarioDefaultArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    projeto<T extends projetoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projetoDefaultArgs<ExtArgs>>): Prisma__projetoClient<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the permissaoProjeto model
   */ 
  interface permissaoProjetoFieldRefs {
    readonly permissaoProjeto_id: FieldRef<"permissaoProjeto", 'Int'>
    readonly tipo: FieldRef<"permissaoProjeto", 'String'>
    readonly usuario_id: FieldRef<"permissaoProjeto", 'Int'>
    readonly projeto_id: FieldRef<"permissaoProjeto", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * permissaoProjeto findUnique
   */
  export type permissaoProjetoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissaoProjeto
     */
    select?: permissaoProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoProjetoInclude<ExtArgs> | null
    /**
     * Filter, which permissaoProjeto to fetch.
     */
    where: permissaoProjetoWhereUniqueInput
  }

  /**
   * permissaoProjeto findUniqueOrThrow
   */
  export type permissaoProjetoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissaoProjeto
     */
    select?: permissaoProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoProjetoInclude<ExtArgs> | null
    /**
     * Filter, which permissaoProjeto to fetch.
     */
    where: permissaoProjetoWhereUniqueInput
  }

  /**
   * permissaoProjeto findFirst
   */
  export type permissaoProjetoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissaoProjeto
     */
    select?: permissaoProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoProjetoInclude<ExtArgs> | null
    /**
     * Filter, which permissaoProjeto to fetch.
     */
    where?: permissaoProjetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissaoProjetos to fetch.
     */
    orderBy?: permissaoProjetoOrderByWithRelationInput | permissaoProjetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissaoProjetos.
     */
    cursor?: permissaoProjetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissaoProjetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissaoProjetos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissaoProjetos.
     */
    distinct?: PermissaoProjetoScalarFieldEnum | PermissaoProjetoScalarFieldEnum[]
  }

  /**
   * permissaoProjeto findFirstOrThrow
   */
  export type permissaoProjetoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissaoProjeto
     */
    select?: permissaoProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoProjetoInclude<ExtArgs> | null
    /**
     * Filter, which permissaoProjeto to fetch.
     */
    where?: permissaoProjetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissaoProjetos to fetch.
     */
    orderBy?: permissaoProjetoOrderByWithRelationInput | permissaoProjetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissaoProjetos.
     */
    cursor?: permissaoProjetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissaoProjetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissaoProjetos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissaoProjetos.
     */
    distinct?: PermissaoProjetoScalarFieldEnum | PermissaoProjetoScalarFieldEnum[]
  }

  /**
   * permissaoProjeto findMany
   */
  export type permissaoProjetoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissaoProjeto
     */
    select?: permissaoProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoProjetoInclude<ExtArgs> | null
    /**
     * Filter, which permissaoProjetos to fetch.
     */
    where?: permissaoProjetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissaoProjetos to fetch.
     */
    orderBy?: permissaoProjetoOrderByWithRelationInput | permissaoProjetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing permissaoProjetos.
     */
    cursor?: permissaoProjetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissaoProjetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissaoProjetos.
     */
    skip?: number
    distinct?: PermissaoProjetoScalarFieldEnum | PermissaoProjetoScalarFieldEnum[]
  }

  /**
   * permissaoProjeto create
   */
  export type permissaoProjetoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissaoProjeto
     */
    select?: permissaoProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoProjetoInclude<ExtArgs> | null
    /**
     * The data needed to create a permissaoProjeto.
     */
    data: XOR<permissaoProjetoCreateInput, permissaoProjetoUncheckedCreateInput>
  }

  /**
   * permissaoProjeto createMany
   */
  export type permissaoProjetoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many permissaoProjetos.
     */
    data: permissaoProjetoCreateManyInput | permissaoProjetoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * permissaoProjeto createManyAndReturn
   */
  export type permissaoProjetoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissaoProjeto
     */
    select?: permissaoProjetoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many permissaoProjetos.
     */
    data: permissaoProjetoCreateManyInput | permissaoProjetoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoProjetoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * permissaoProjeto update
   */
  export type permissaoProjetoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissaoProjeto
     */
    select?: permissaoProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoProjetoInclude<ExtArgs> | null
    /**
     * The data needed to update a permissaoProjeto.
     */
    data: XOR<permissaoProjetoUpdateInput, permissaoProjetoUncheckedUpdateInput>
    /**
     * Choose, which permissaoProjeto to update.
     */
    where: permissaoProjetoWhereUniqueInput
  }

  /**
   * permissaoProjeto updateMany
   */
  export type permissaoProjetoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update permissaoProjetos.
     */
    data: XOR<permissaoProjetoUpdateManyMutationInput, permissaoProjetoUncheckedUpdateManyInput>
    /**
     * Filter which permissaoProjetos to update
     */
    where?: permissaoProjetoWhereInput
  }

  /**
   * permissaoProjeto upsert
   */
  export type permissaoProjetoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissaoProjeto
     */
    select?: permissaoProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoProjetoInclude<ExtArgs> | null
    /**
     * The filter to search for the permissaoProjeto to update in case it exists.
     */
    where: permissaoProjetoWhereUniqueInput
    /**
     * In case the permissaoProjeto found by the `where` argument doesn't exist, create a new permissaoProjeto with this data.
     */
    create: XOR<permissaoProjetoCreateInput, permissaoProjetoUncheckedCreateInput>
    /**
     * In case the permissaoProjeto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<permissaoProjetoUpdateInput, permissaoProjetoUncheckedUpdateInput>
  }

  /**
   * permissaoProjeto delete
   */
  export type permissaoProjetoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissaoProjeto
     */
    select?: permissaoProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoProjetoInclude<ExtArgs> | null
    /**
     * Filter which permissaoProjeto to delete.
     */
    where: permissaoProjetoWhereUniqueInput
  }

  /**
   * permissaoProjeto deleteMany
   */
  export type permissaoProjetoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissaoProjetos to delete
     */
    where?: permissaoProjetoWhereInput
  }

  /**
   * permissaoProjeto without action
   */
  export type permissaoProjetoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissaoProjeto
     */
    select?: permissaoProjetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissaoProjetoInclude<ExtArgs> | null
  }


  /**
   * Model pausaTarefa
   */

  export type AggregatePausaTarefa = {
    _count: PausaTarefaCountAggregateOutputType | null
    _avg: PausaTarefaAvgAggregateOutputType | null
    _sum: PausaTarefaSumAggregateOutputType | null
    _min: PausaTarefaMinAggregateOutputType | null
    _max: PausaTarefaMaxAggregateOutputType | null
  }

  export type PausaTarefaAvgAggregateOutputType = {
    pausa_id: number | null
    tarefa_id: number | null
  }

  export type PausaTarefaSumAggregateOutputType = {
    pausa_id: number | null
    tarefa_id: number | null
  }

  export type PausaTarefaMinAggregateOutputType = {
    pausa_id: number | null
    tarefa_id: number | null
    inicioPausa: Date | null
    fimPausa: Date | null
  }

  export type PausaTarefaMaxAggregateOutputType = {
    pausa_id: number | null
    tarefa_id: number | null
    inicioPausa: Date | null
    fimPausa: Date | null
  }

  export type PausaTarefaCountAggregateOutputType = {
    pausa_id: number
    tarefa_id: number
    inicioPausa: number
    fimPausa: number
    _all: number
  }


  export type PausaTarefaAvgAggregateInputType = {
    pausa_id?: true
    tarefa_id?: true
  }

  export type PausaTarefaSumAggregateInputType = {
    pausa_id?: true
    tarefa_id?: true
  }

  export type PausaTarefaMinAggregateInputType = {
    pausa_id?: true
    tarefa_id?: true
    inicioPausa?: true
    fimPausa?: true
  }

  export type PausaTarefaMaxAggregateInputType = {
    pausa_id?: true
    tarefa_id?: true
    inicioPausa?: true
    fimPausa?: true
  }

  export type PausaTarefaCountAggregateInputType = {
    pausa_id?: true
    tarefa_id?: true
    inicioPausa?: true
    fimPausa?: true
    _all?: true
  }

  export type PausaTarefaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pausaTarefa to aggregate.
     */
    where?: pausaTarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pausaTarefas to fetch.
     */
    orderBy?: pausaTarefaOrderByWithRelationInput | pausaTarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pausaTarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pausaTarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pausaTarefas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pausaTarefas
    **/
    _count?: true | PausaTarefaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PausaTarefaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PausaTarefaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PausaTarefaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PausaTarefaMaxAggregateInputType
  }

  export type GetPausaTarefaAggregateType<T extends PausaTarefaAggregateArgs> = {
        [P in keyof T & keyof AggregatePausaTarefa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePausaTarefa[P]>
      : GetScalarType<T[P], AggregatePausaTarefa[P]>
  }




  export type pausaTarefaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pausaTarefaWhereInput
    orderBy?: pausaTarefaOrderByWithAggregationInput | pausaTarefaOrderByWithAggregationInput[]
    by: PausaTarefaScalarFieldEnum[] | PausaTarefaScalarFieldEnum
    having?: pausaTarefaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PausaTarefaCountAggregateInputType | true
    _avg?: PausaTarefaAvgAggregateInputType
    _sum?: PausaTarefaSumAggregateInputType
    _min?: PausaTarefaMinAggregateInputType
    _max?: PausaTarefaMaxAggregateInputType
  }

  export type PausaTarefaGroupByOutputType = {
    pausa_id: number
    tarefa_id: number
    inicioPausa: Date
    fimPausa: Date | null
    _count: PausaTarefaCountAggregateOutputType | null
    _avg: PausaTarefaAvgAggregateOutputType | null
    _sum: PausaTarefaSumAggregateOutputType | null
    _min: PausaTarefaMinAggregateOutputType | null
    _max: PausaTarefaMaxAggregateOutputType | null
  }

  type GetPausaTarefaGroupByPayload<T extends pausaTarefaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PausaTarefaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PausaTarefaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PausaTarefaGroupByOutputType[P]>
            : GetScalarType<T[P], PausaTarefaGroupByOutputType[P]>
        }
      >
    >


  export type pausaTarefaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pausa_id?: boolean
    tarefa_id?: boolean
    inicioPausa?: boolean
    fimPausa?: boolean
    tarefa?: boolean | tarefaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pausaTarefa"]>

  export type pausaTarefaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pausa_id?: boolean
    tarefa_id?: boolean
    inicioPausa?: boolean
    fimPausa?: boolean
    tarefa?: boolean | tarefaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pausaTarefa"]>

  export type pausaTarefaSelectScalar = {
    pausa_id?: boolean
    tarefa_id?: boolean
    inicioPausa?: boolean
    fimPausa?: boolean
  }

  export type pausaTarefaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tarefa?: boolean | tarefaDefaultArgs<ExtArgs>
  }
  export type pausaTarefaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tarefa?: boolean | tarefaDefaultArgs<ExtArgs>
  }

  export type $pausaTarefaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pausaTarefa"
    objects: {
      tarefa: Prisma.$tarefaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      pausa_id: number
      tarefa_id: number
      inicioPausa: Date
      fimPausa: Date | null
    }, ExtArgs["result"]["pausaTarefa"]>
    composites: {}
  }

  type pausaTarefaGetPayload<S extends boolean | null | undefined | pausaTarefaDefaultArgs> = $Result.GetResult<Prisma.$pausaTarefaPayload, S>

  type pausaTarefaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<pausaTarefaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PausaTarefaCountAggregateInputType | true
    }

  export interface pausaTarefaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pausaTarefa'], meta: { name: 'pausaTarefa' } }
    /**
     * Find zero or one PausaTarefa that matches the filter.
     * @param {pausaTarefaFindUniqueArgs} args - Arguments to find a PausaTarefa
     * @example
     * // Get one PausaTarefa
     * const pausaTarefa = await prisma.pausaTarefa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pausaTarefaFindUniqueArgs>(args: SelectSubset<T, pausaTarefaFindUniqueArgs<ExtArgs>>): Prisma__pausaTarefaClient<$Result.GetResult<Prisma.$pausaTarefaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PausaTarefa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {pausaTarefaFindUniqueOrThrowArgs} args - Arguments to find a PausaTarefa
     * @example
     * // Get one PausaTarefa
     * const pausaTarefa = await prisma.pausaTarefa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pausaTarefaFindUniqueOrThrowArgs>(args: SelectSubset<T, pausaTarefaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pausaTarefaClient<$Result.GetResult<Prisma.$pausaTarefaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PausaTarefa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pausaTarefaFindFirstArgs} args - Arguments to find a PausaTarefa
     * @example
     * // Get one PausaTarefa
     * const pausaTarefa = await prisma.pausaTarefa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pausaTarefaFindFirstArgs>(args?: SelectSubset<T, pausaTarefaFindFirstArgs<ExtArgs>>): Prisma__pausaTarefaClient<$Result.GetResult<Prisma.$pausaTarefaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PausaTarefa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pausaTarefaFindFirstOrThrowArgs} args - Arguments to find a PausaTarefa
     * @example
     * // Get one PausaTarefa
     * const pausaTarefa = await prisma.pausaTarefa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pausaTarefaFindFirstOrThrowArgs>(args?: SelectSubset<T, pausaTarefaFindFirstOrThrowArgs<ExtArgs>>): Prisma__pausaTarefaClient<$Result.GetResult<Prisma.$pausaTarefaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PausaTarefas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pausaTarefaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PausaTarefas
     * const pausaTarefas = await prisma.pausaTarefa.findMany()
     * 
     * // Get first 10 PausaTarefas
     * const pausaTarefas = await prisma.pausaTarefa.findMany({ take: 10 })
     * 
     * // Only select the `pausa_id`
     * const pausaTarefaWithPausa_idOnly = await prisma.pausaTarefa.findMany({ select: { pausa_id: true } })
     * 
     */
    findMany<T extends pausaTarefaFindManyArgs>(args?: SelectSubset<T, pausaTarefaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pausaTarefaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PausaTarefa.
     * @param {pausaTarefaCreateArgs} args - Arguments to create a PausaTarefa.
     * @example
     * // Create one PausaTarefa
     * const PausaTarefa = await prisma.pausaTarefa.create({
     *   data: {
     *     // ... data to create a PausaTarefa
     *   }
     * })
     * 
     */
    create<T extends pausaTarefaCreateArgs>(args: SelectSubset<T, pausaTarefaCreateArgs<ExtArgs>>): Prisma__pausaTarefaClient<$Result.GetResult<Prisma.$pausaTarefaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PausaTarefas.
     * @param {pausaTarefaCreateManyArgs} args - Arguments to create many PausaTarefas.
     * @example
     * // Create many PausaTarefas
     * const pausaTarefa = await prisma.pausaTarefa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pausaTarefaCreateManyArgs>(args?: SelectSubset<T, pausaTarefaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PausaTarefas and returns the data saved in the database.
     * @param {pausaTarefaCreateManyAndReturnArgs} args - Arguments to create many PausaTarefas.
     * @example
     * // Create many PausaTarefas
     * const pausaTarefa = await prisma.pausaTarefa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PausaTarefas and only return the `pausa_id`
     * const pausaTarefaWithPausa_idOnly = await prisma.pausaTarefa.createManyAndReturn({ 
     *   select: { pausa_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pausaTarefaCreateManyAndReturnArgs>(args?: SelectSubset<T, pausaTarefaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pausaTarefaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PausaTarefa.
     * @param {pausaTarefaDeleteArgs} args - Arguments to delete one PausaTarefa.
     * @example
     * // Delete one PausaTarefa
     * const PausaTarefa = await prisma.pausaTarefa.delete({
     *   where: {
     *     // ... filter to delete one PausaTarefa
     *   }
     * })
     * 
     */
    delete<T extends pausaTarefaDeleteArgs>(args: SelectSubset<T, pausaTarefaDeleteArgs<ExtArgs>>): Prisma__pausaTarefaClient<$Result.GetResult<Prisma.$pausaTarefaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PausaTarefa.
     * @param {pausaTarefaUpdateArgs} args - Arguments to update one PausaTarefa.
     * @example
     * // Update one PausaTarefa
     * const pausaTarefa = await prisma.pausaTarefa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pausaTarefaUpdateArgs>(args: SelectSubset<T, pausaTarefaUpdateArgs<ExtArgs>>): Prisma__pausaTarefaClient<$Result.GetResult<Prisma.$pausaTarefaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PausaTarefas.
     * @param {pausaTarefaDeleteManyArgs} args - Arguments to filter PausaTarefas to delete.
     * @example
     * // Delete a few PausaTarefas
     * const { count } = await prisma.pausaTarefa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pausaTarefaDeleteManyArgs>(args?: SelectSubset<T, pausaTarefaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PausaTarefas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pausaTarefaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PausaTarefas
     * const pausaTarefa = await prisma.pausaTarefa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pausaTarefaUpdateManyArgs>(args: SelectSubset<T, pausaTarefaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PausaTarefa.
     * @param {pausaTarefaUpsertArgs} args - Arguments to update or create a PausaTarefa.
     * @example
     * // Update or create a PausaTarefa
     * const pausaTarefa = await prisma.pausaTarefa.upsert({
     *   create: {
     *     // ... data to create a PausaTarefa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PausaTarefa we want to update
     *   }
     * })
     */
    upsert<T extends pausaTarefaUpsertArgs>(args: SelectSubset<T, pausaTarefaUpsertArgs<ExtArgs>>): Prisma__pausaTarefaClient<$Result.GetResult<Prisma.$pausaTarefaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PausaTarefas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pausaTarefaCountArgs} args - Arguments to filter PausaTarefas to count.
     * @example
     * // Count the number of PausaTarefas
     * const count = await prisma.pausaTarefa.count({
     *   where: {
     *     // ... the filter for the PausaTarefas we want to count
     *   }
     * })
    **/
    count<T extends pausaTarefaCountArgs>(
      args?: Subset<T, pausaTarefaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PausaTarefaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PausaTarefa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PausaTarefaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PausaTarefaAggregateArgs>(args: Subset<T, PausaTarefaAggregateArgs>): Prisma.PrismaPromise<GetPausaTarefaAggregateType<T>>

    /**
     * Group by PausaTarefa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pausaTarefaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pausaTarefaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pausaTarefaGroupByArgs['orderBy'] }
        : { orderBy?: pausaTarefaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pausaTarefaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPausaTarefaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pausaTarefa model
   */
  readonly fields: pausaTarefaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pausaTarefa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pausaTarefaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tarefa<T extends tarefaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tarefaDefaultArgs<ExtArgs>>): Prisma__tarefaClient<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pausaTarefa model
   */ 
  interface pausaTarefaFieldRefs {
    readonly pausa_id: FieldRef<"pausaTarefa", 'Int'>
    readonly tarefa_id: FieldRef<"pausaTarefa", 'Int'>
    readonly inicioPausa: FieldRef<"pausaTarefa", 'DateTime'>
    readonly fimPausa: FieldRef<"pausaTarefa", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * pausaTarefa findUnique
   */
  export type pausaTarefaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pausaTarefa
     */
    select?: pausaTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pausaTarefaInclude<ExtArgs> | null
    /**
     * Filter, which pausaTarefa to fetch.
     */
    where: pausaTarefaWhereUniqueInput
  }

  /**
   * pausaTarefa findUniqueOrThrow
   */
  export type pausaTarefaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pausaTarefa
     */
    select?: pausaTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pausaTarefaInclude<ExtArgs> | null
    /**
     * Filter, which pausaTarefa to fetch.
     */
    where: pausaTarefaWhereUniqueInput
  }

  /**
   * pausaTarefa findFirst
   */
  export type pausaTarefaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pausaTarefa
     */
    select?: pausaTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pausaTarefaInclude<ExtArgs> | null
    /**
     * Filter, which pausaTarefa to fetch.
     */
    where?: pausaTarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pausaTarefas to fetch.
     */
    orderBy?: pausaTarefaOrderByWithRelationInput | pausaTarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pausaTarefas.
     */
    cursor?: pausaTarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pausaTarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pausaTarefas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pausaTarefas.
     */
    distinct?: PausaTarefaScalarFieldEnum | PausaTarefaScalarFieldEnum[]
  }

  /**
   * pausaTarefa findFirstOrThrow
   */
  export type pausaTarefaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pausaTarefa
     */
    select?: pausaTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pausaTarefaInclude<ExtArgs> | null
    /**
     * Filter, which pausaTarefa to fetch.
     */
    where?: pausaTarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pausaTarefas to fetch.
     */
    orderBy?: pausaTarefaOrderByWithRelationInput | pausaTarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pausaTarefas.
     */
    cursor?: pausaTarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pausaTarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pausaTarefas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pausaTarefas.
     */
    distinct?: PausaTarefaScalarFieldEnum | PausaTarefaScalarFieldEnum[]
  }

  /**
   * pausaTarefa findMany
   */
  export type pausaTarefaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pausaTarefa
     */
    select?: pausaTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pausaTarefaInclude<ExtArgs> | null
    /**
     * Filter, which pausaTarefas to fetch.
     */
    where?: pausaTarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pausaTarefas to fetch.
     */
    orderBy?: pausaTarefaOrderByWithRelationInput | pausaTarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pausaTarefas.
     */
    cursor?: pausaTarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pausaTarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pausaTarefas.
     */
    skip?: number
    distinct?: PausaTarefaScalarFieldEnum | PausaTarefaScalarFieldEnum[]
  }

  /**
   * pausaTarefa create
   */
  export type pausaTarefaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pausaTarefa
     */
    select?: pausaTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pausaTarefaInclude<ExtArgs> | null
    /**
     * The data needed to create a pausaTarefa.
     */
    data: XOR<pausaTarefaCreateInput, pausaTarefaUncheckedCreateInput>
  }

  /**
   * pausaTarefa createMany
   */
  export type pausaTarefaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pausaTarefas.
     */
    data: pausaTarefaCreateManyInput | pausaTarefaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pausaTarefa createManyAndReturn
   */
  export type pausaTarefaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pausaTarefa
     */
    select?: pausaTarefaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many pausaTarefas.
     */
    data: pausaTarefaCreateManyInput | pausaTarefaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pausaTarefaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * pausaTarefa update
   */
  export type pausaTarefaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pausaTarefa
     */
    select?: pausaTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pausaTarefaInclude<ExtArgs> | null
    /**
     * The data needed to update a pausaTarefa.
     */
    data: XOR<pausaTarefaUpdateInput, pausaTarefaUncheckedUpdateInput>
    /**
     * Choose, which pausaTarefa to update.
     */
    where: pausaTarefaWhereUniqueInput
  }

  /**
   * pausaTarefa updateMany
   */
  export type pausaTarefaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pausaTarefas.
     */
    data: XOR<pausaTarefaUpdateManyMutationInput, pausaTarefaUncheckedUpdateManyInput>
    /**
     * Filter which pausaTarefas to update
     */
    where?: pausaTarefaWhereInput
  }

  /**
   * pausaTarefa upsert
   */
  export type pausaTarefaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pausaTarefa
     */
    select?: pausaTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pausaTarefaInclude<ExtArgs> | null
    /**
     * The filter to search for the pausaTarefa to update in case it exists.
     */
    where: pausaTarefaWhereUniqueInput
    /**
     * In case the pausaTarefa found by the `where` argument doesn't exist, create a new pausaTarefa with this data.
     */
    create: XOR<pausaTarefaCreateInput, pausaTarefaUncheckedCreateInput>
    /**
     * In case the pausaTarefa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pausaTarefaUpdateInput, pausaTarefaUncheckedUpdateInput>
  }

  /**
   * pausaTarefa delete
   */
  export type pausaTarefaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pausaTarefa
     */
    select?: pausaTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pausaTarefaInclude<ExtArgs> | null
    /**
     * Filter which pausaTarefa to delete.
     */
    where: pausaTarefaWhereUniqueInput
  }

  /**
   * pausaTarefa deleteMany
   */
  export type pausaTarefaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pausaTarefas to delete
     */
    where?: pausaTarefaWhereInput
  }

  /**
   * pausaTarefa without action
   */
  export type pausaTarefaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pausaTarefa
     */
    select?: pausaTarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pausaTarefaInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const LoginScalarFieldEnum: {
    login_id: 'login_id',
    email: 'email',
    password: 'password',
    is_verified: 'is_verified',
    provider: 'provider',
    provider_id: 'provider_id',
    profile_image: 'profile_image',
    ativo: 'ativo'
  };

  export type LoginScalarFieldEnum = (typeof LoginScalarFieldEnum)[keyof typeof LoginScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    usuario_id: 'usuario_id',
    nome: 'nome',
    created_at: 'created_at',
    roule: 'roule',
    login_id: 'login_id'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const ProjetoScalarFieldEnum: {
    projeto_id: 'projeto_id',
    nome: 'nome',
    descricao: 'descricao',
    created_at: 'created_at',
    conclude_at: 'conclude_at'
  };

  export type ProjetoScalarFieldEnum = (typeof ProjetoScalarFieldEnum)[keyof typeof ProjetoScalarFieldEnum]


  export const TecnologiaScalarFieldEnum: {
    tecnologia_id: 'tecnologia_id',
    descricao: 'descricao'
  };

  export type TecnologiaScalarFieldEnum = (typeof TecnologiaScalarFieldEnum)[keyof typeof TecnologiaScalarFieldEnum]


  export const TarefaScalarFieldEnum: {
    tarefa_id: 'tarefa_id',
    titulo: 'titulo',
    descricao: 'descricao',
    createdAt: 'createdAt',
    doing: 'doing',
    concludeAt: 'concludeAt',
    colorBar: 'colorBar'
  };

  export type TarefaScalarFieldEnum = (typeof TarefaScalarFieldEnum)[keyof typeof TarefaScalarFieldEnum]


  export const ProjetoUsuarioScalarFieldEnum: {
    projetoUsuario_id: 'projetoUsuario_id',
    projeto_id: 'projeto_id',
    usuario_id: 'usuario_id',
    owner: 'owner'
  };

  export type ProjetoUsuarioScalarFieldEnum = (typeof ProjetoUsuarioScalarFieldEnum)[keyof typeof ProjetoUsuarioScalarFieldEnum]


  export const ProjetoTecnologiaScalarFieldEnum: {
    projetoTecnologia_id: 'projetoTecnologia_id',
    tecnologia_id: 'tecnologia_id',
    projeto_id: 'projeto_id'
  };

  export type ProjetoTecnologiaScalarFieldEnum = (typeof ProjetoTecnologiaScalarFieldEnum)[keyof typeof ProjetoTecnologiaScalarFieldEnum]


  export const HabilidadeUsuarioScalarFieldEnum: {
    habilidadeUsuario_id: 'habilidadeUsuario_id',
    tecnologia_id: 'tecnologia_id',
    usuario_id: 'usuario_id'
  };

  export type HabilidadeUsuarioScalarFieldEnum = (typeof HabilidadeUsuarioScalarFieldEnum)[keyof typeof HabilidadeUsuarioScalarFieldEnum]


  export const RecursoScalarFieldEnum: {
    recurso_id: 'recurso_id',
    descricao: 'descricao',
    projeto_id: 'projeto_id'
  };

  export type RecursoScalarFieldEnum = (typeof RecursoScalarFieldEnum)[keyof typeof RecursoScalarFieldEnum]


  export const AnexoProjetoScalarFieldEnum: {
    anexo_id: 'anexo_id',
    nome: 'nome',
    tipo: 'tipo',
    conteudo: 'conteudo',
    projeto_id: 'projeto_id',
    created_at: 'created_at'
  };

  export type AnexoProjetoScalarFieldEnum = (typeof AnexoProjetoScalarFieldEnum)[keyof typeof AnexoProjetoScalarFieldEnum]


  export const ParticipacaoTarefaScalarFieldEnum: {
    participacaoTarefa_id: 'participacaoTarefa_id',
    tarefa_id: 'tarefa_id',
    projetoUsuario_id: 'projetoUsuario_id'
  };

  export type ParticipacaoTarefaScalarFieldEnum = (typeof ParticipacaoTarefaScalarFieldEnum)[keyof typeof ParticipacaoTarefaScalarFieldEnum]


  export const ComentarioScalarFieldEnum: {
    comentario_id: 'comentario_id',
    comentario: 'comentario',
    data_hora: 'data_hora',
    participacaoTarefa_id: 'participacaoTarefa_id',
    usuario_id: 'usuario_id'
  };

  export type ComentarioScalarFieldEnum = (typeof ComentarioScalarFieldEnum)[keyof typeof ComentarioScalarFieldEnum]


  export const AnexoTarefaScalarFieldEnum: {
    anexoTarefa_id: 'anexoTarefa_id',
    nome: 'nome',
    tipo: 'tipo',
    conteudo: 'conteudo',
    created_at: 'created_at',
    tarefa_id: 'tarefa_id'
  };

  export type AnexoTarefaScalarFieldEnum = (typeof AnexoTarefaScalarFieldEnum)[keyof typeof AnexoTarefaScalarFieldEnum]


  export const AnexoComentarioScalarFieldEnum: {
    anexoComentario_id: 'anexoComentario_id',
    comentario_id: 'comentario_id',
    anexoTarefa_id: 'anexoTarefa_id'
  };

  export type AnexoComentarioScalarFieldEnum = (typeof AnexoComentarioScalarFieldEnum)[keyof typeof AnexoComentarioScalarFieldEnum]


  export const PermissaoScalarFieldEnum: {
    permissao_id: 'permissao_id',
    tipo: 'tipo',
    usuario_id: 'usuario_id'
  };

  export type PermissaoScalarFieldEnum = (typeof PermissaoScalarFieldEnum)[keyof typeof PermissaoScalarFieldEnum]


  export const PermissaoProjetoScalarFieldEnum: {
    permissaoProjeto_id: 'permissaoProjeto_id',
    tipo: 'tipo',
    usuario_id: 'usuario_id',
    projeto_id: 'projeto_id'
  };

  export type PermissaoProjetoScalarFieldEnum = (typeof PermissaoProjetoScalarFieldEnum)[keyof typeof PermissaoProjetoScalarFieldEnum]


  export const PausaTarefaScalarFieldEnum: {
    pausa_id: 'pausa_id',
    tarefa_id: 'tarefa_id',
    inicioPausa: 'inicioPausa',
    fimPausa: 'fimPausa'
  };

  export type PausaTarefaScalarFieldEnum = (typeof PausaTarefaScalarFieldEnum)[keyof typeof PausaTarefaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type loginWhereInput = {
    AND?: loginWhereInput | loginWhereInput[]
    OR?: loginWhereInput[]
    NOT?: loginWhereInput | loginWhereInput[]
    login_id?: IntFilter<"login"> | number
    email?: StringFilter<"login"> | string
    password?: StringNullableFilter<"login"> | string | null
    is_verified?: BoolFilter<"login"> | boolean
    provider?: StringFilter<"login"> | string
    provider_id?: StringNullableFilter<"login"> | string | null
    profile_image?: StringNullableFilter<"login"> | string | null
    ativo?: BoolFilter<"login"> | boolean
    usuario?: XOR<UsuarioNullableRelationFilter, usuarioWhereInput> | null
  }

  export type loginOrderByWithRelationInput = {
    login_id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    is_verified?: SortOrder
    provider?: SortOrder
    provider_id?: SortOrderInput | SortOrder
    profile_image?: SortOrderInput | SortOrder
    ativo?: SortOrder
    usuario?: usuarioOrderByWithRelationInput
  }

  export type loginWhereUniqueInput = Prisma.AtLeast<{
    login_id?: number
    email?: string
    AND?: loginWhereInput | loginWhereInput[]
    OR?: loginWhereInput[]
    NOT?: loginWhereInput | loginWhereInput[]
    password?: StringNullableFilter<"login"> | string | null
    is_verified?: BoolFilter<"login"> | boolean
    provider?: StringFilter<"login"> | string
    provider_id?: StringNullableFilter<"login"> | string | null
    profile_image?: StringNullableFilter<"login"> | string | null
    ativo?: BoolFilter<"login"> | boolean
    usuario?: XOR<UsuarioNullableRelationFilter, usuarioWhereInput> | null
  }, "login_id" | "email">

  export type loginOrderByWithAggregationInput = {
    login_id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    is_verified?: SortOrder
    provider?: SortOrder
    provider_id?: SortOrderInput | SortOrder
    profile_image?: SortOrderInput | SortOrder
    ativo?: SortOrder
    _count?: loginCountOrderByAggregateInput
    _avg?: loginAvgOrderByAggregateInput
    _max?: loginMaxOrderByAggregateInput
    _min?: loginMinOrderByAggregateInput
    _sum?: loginSumOrderByAggregateInput
  }

  export type loginScalarWhereWithAggregatesInput = {
    AND?: loginScalarWhereWithAggregatesInput | loginScalarWhereWithAggregatesInput[]
    OR?: loginScalarWhereWithAggregatesInput[]
    NOT?: loginScalarWhereWithAggregatesInput | loginScalarWhereWithAggregatesInput[]
    login_id?: IntWithAggregatesFilter<"login"> | number
    email?: StringWithAggregatesFilter<"login"> | string
    password?: StringNullableWithAggregatesFilter<"login"> | string | null
    is_verified?: BoolWithAggregatesFilter<"login"> | boolean
    provider?: StringWithAggregatesFilter<"login"> | string
    provider_id?: StringNullableWithAggregatesFilter<"login"> | string | null
    profile_image?: StringNullableWithAggregatesFilter<"login"> | string | null
    ativo?: BoolWithAggregatesFilter<"login"> | boolean
  }

  export type usuarioWhereInput = {
    AND?: usuarioWhereInput | usuarioWhereInput[]
    OR?: usuarioWhereInput[]
    NOT?: usuarioWhereInput | usuarioWhereInput[]
    usuario_id?: IntFilter<"usuario"> | number
    nome?: StringFilter<"usuario"> | string
    created_at?: DateTimeFilter<"usuario"> | Date | string
    roule?: StringNullableFilter<"usuario"> | string | null
    login_id?: IntFilter<"usuario"> | number
    login?: XOR<LoginRelationFilter, loginWhereInput>
    projetoUsuarios?: ProjetoUsuarioListRelationFilter
    habilidades?: HabilidadeUsuarioListRelationFilter
    permissoes?: PermissaoListRelationFilter
    permissoesProjeto?: PermissaoProjetoListRelationFilter
    participacoes?: ParticipacaoTarefaListRelationFilter
    comentarios?: ComentarioListRelationFilter
  }

  export type usuarioOrderByWithRelationInput = {
    usuario_id?: SortOrder
    nome?: SortOrder
    created_at?: SortOrder
    roule?: SortOrderInput | SortOrder
    login_id?: SortOrder
    login?: loginOrderByWithRelationInput
    projetoUsuarios?: projetoUsuarioOrderByRelationAggregateInput
    habilidades?: habilidadeUsuarioOrderByRelationAggregateInput
    permissoes?: permissaoOrderByRelationAggregateInput
    permissoesProjeto?: permissaoProjetoOrderByRelationAggregateInput
    participacoes?: participacaoTarefaOrderByRelationAggregateInput
    comentarios?: comentarioOrderByRelationAggregateInput
  }

  export type usuarioWhereUniqueInput = Prisma.AtLeast<{
    usuario_id?: number
    login_id?: number
    AND?: usuarioWhereInput | usuarioWhereInput[]
    OR?: usuarioWhereInput[]
    NOT?: usuarioWhereInput | usuarioWhereInput[]
    nome?: StringFilter<"usuario"> | string
    created_at?: DateTimeFilter<"usuario"> | Date | string
    roule?: StringNullableFilter<"usuario"> | string | null
    login?: XOR<LoginRelationFilter, loginWhereInput>
    projetoUsuarios?: ProjetoUsuarioListRelationFilter
    habilidades?: HabilidadeUsuarioListRelationFilter
    permissoes?: PermissaoListRelationFilter
    permissoesProjeto?: PermissaoProjetoListRelationFilter
    participacoes?: ParticipacaoTarefaListRelationFilter
    comentarios?: ComentarioListRelationFilter
  }, "usuario_id" | "login_id">

  export type usuarioOrderByWithAggregationInput = {
    usuario_id?: SortOrder
    nome?: SortOrder
    created_at?: SortOrder
    roule?: SortOrderInput | SortOrder
    login_id?: SortOrder
    _count?: usuarioCountOrderByAggregateInput
    _avg?: usuarioAvgOrderByAggregateInput
    _max?: usuarioMaxOrderByAggregateInput
    _min?: usuarioMinOrderByAggregateInput
    _sum?: usuarioSumOrderByAggregateInput
  }

  export type usuarioScalarWhereWithAggregatesInput = {
    AND?: usuarioScalarWhereWithAggregatesInput | usuarioScalarWhereWithAggregatesInput[]
    OR?: usuarioScalarWhereWithAggregatesInput[]
    NOT?: usuarioScalarWhereWithAggregatesInput | usuarioScalarWhereWithAggregatesInput[]
    usuario_id?: IntWithAggregatesFilter<"usuario"> | number
    nome?: StringWithAggregatesFilter<"usuario"> | string
    created_at?: DateTimeWithAggregatesFilter<"usuario"> | Date | string
    roule?: StringNullableWithAggregatesFilter<"usuario"> | string | null
    login_id?: IntWithAggregatesFilter<"usuario"> | number
  }

  export type projetoWhereInput = {
    AND?: projetoWhereInput | projetoWhereInput[]
    OR?: projetoWhereInput[]
    NOT?: projetoWhereInput | projetoWhereInput[]
    projeto_id?: IntFilter<"projeto"> | number
    nome?: StringFilter<"projeto"> | string
    descricao?: StringFilter<"projeto"> | string
    created_at?: DateTimeFilter<"projeto"> | Date | string
    conclude_at?: DateTimeNullableFilter<"projeto"> | Date | string | null
    projetoUsuarios?: ProjetoUsuarioListRelationFilter
    tecnologias?: ProjetoTecnologiaListRelationFilter
    recursos?: RecursoListRelationFilter
    anexos?: AnexoProjetoListRelationFilter
    permissoes?: PermissaoProjetoListRelationFilter
  }

  export type projetoOrderByWithRelationInput = {
    projeto_id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    created_at?: SortOrder
    conclude_at?: SortOrderInput | SortOrder
    projetoUsuarios?: projetoUsuarioOrderByRelationAggregateInput
    tecnologias?: projetoTecnologiaOrderByRelationAggregateInput
    recursos?: recursoOrderByRelationAggregateInput
    anexos?: anexoProjetoOrderByRelationAggregateInput
    permissoes?: permissaoProjetoOrderByRelationAggregateInput
  }

  export type projetoWhereUniqueInput = Prisma.AtLeast<{
    projeto_id?: number
    AND?: projetoWhereInput | projetoWhereInput[]
    OR?: projetoWhereInput[]
    NOT?: projetoWhereInput | projetoWhereInput[]
    nome?: StringFilter<"projeto"> | string
    descricao?: StringFilter<"projeto"> | string
    created_at?: DateTimeFilter<"projeto"> | Date | string
    conclude_at?: DateTimeNullableFilter<"projeto"> | Date | string | null
    projetoUsuarios?: ProjetoUsuarioListRelationFilter
    tecnologias?: ProjetoTecnologiaListRelationFilter
    recursos?: RecursoListRelationFilter
    anexos?: AnexoProjetoListRelationFilter
    permissoes?: PermissaoProjetoListRelationFilter
  }, "projeto_id">

  export type projetoOrderByWithAggregationInput = {
    projeto_id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    created_at?: SortOrder
    conclude_at?: SortOrderInput | SortOrder
    _count?: projetoCountOrderByAggregateInput
    _avg?: projetoAvgOrderByAggregateInput
    _max?: projetoMaxOrderByAggregateInput
    _min?: projetoMinOrderByAggregateInput
    _sum?: projetoSumOrderByAggregateInput
  }

  export type projetoScalarWhereWithAggregatesInput = {
    AND?: projetoScalarWhereWithAggregatesInput | projetoScalarWhereWithAggregatesInput[]
    OR?: projetoScalarWhereWithAggregatesInput[]
    NOT?: projetoScalarWhereWithAggregatesInput | projetoScalarWhereWithAggregatesInput[]
    projeto_id?: IntWithAggregatesFilter<"projeto"> | number
    nome?: StringWithAggregatesFilter<"projeto"> | string
    descricao?: StringWithAggregatesFilter<"projeto"> | string
    created_at?: DateTimeWithAggregatesFilter<"projeto"> | Date | string
    conclude_at?: DateTimeNullableWithAggregatesFilter<"projeto"> | Date | string | null
  }

  export type tecnologiaWhereInput = {
    AND?: tecnologiaWhereInput | tecnologiaWhereInput[]
    OR?: tecnologiaWhereInput[]
    NOT?: tecnologiaWhereInput | tecnologiaWhereInput[]
    tecnologia_id?: IntFilter<"tecnologia"> | number
    descricao?: StringFilter<"tecnologia"> | string
    habilidades?: HabilidadeUsuarioListRelationFilter
    projetos?: ProjetoTecnologiaListRelationFilter
  }

  export type tecnologiaOrderByWithRelationInput = {
    tecnologia_id?: SortOrder
    descricao?: SortOrder
    habilidades?: habilidadeUsuarioOrderByRelationAggregateInput
    projetos?: projetoTecnologiaOrderByRelationAggregateInput
  }

  export type tecnologiaWhereUniqueInput = Prisma.AtLeast<{
    tecnologia_id?: number
    AND?: tecnologiaWhereInput | tecnologiaWhereInput[]
    OR?: tecnologiaWhereInput[]
    NOT?: tecnologiaWhereInput | tecnologiaWhereInput[]
    descricao?: StringFilter<"tecnologia"> | string
    habilidades?: HabilidadeUsuarioListRelationFilter
    projetos?: ProjetoTecnologiaListRelationFilter
  }, "tecnologia_id">

  export type tecnologiaOrderByWithAggregationInput = {
    tecnologia_id?: SortOrder
    descricao?: SortOrder
    _count?: tecnologiaCountOrderByAggregateInput
    _avg?: tecnologiaAvgOrderByAggregateInput
    _max?: tecnologiaMaxOrderByAggregateInput
    _min?: tecnologiaMinOrderByAggregateInput
    _sum?: tecnologiaSumOrderByAggregateInput
  }

  export type tecnologiaScalarWhereWithAggregatesInput = {
    AND?: tecnologiaScalarWhereWithAggregatesInput | tecnologiaScalarWhereWithAggregatesInput[]
    OR?: tecnologiaScalarWhereWithAggregatesInput[]
    NOT?: tecnologiaScalarWhereWithAggregatesInput | tecnologiaScalarWhereWithAggregatesInput[]
    tecnologia_id?: IntWithAggregatesFilter<"tecnologia"> | number
    descricao?: StringWithAggregatesFilter<"tecnologia"> | string
  }

  export type tarefaWhereInput = {
    AND?: tarefaWhereInput | tarefaWhereInput[]
    OR?: tarefaWhereInput[]
    NOT?: tarefaWhereInput | tarefaWhereInput[]
    tarefa_id?: IntFilter<"tarefa"> | number
    titulo?: StringFilter<"tarefa"> | string
    descricao?: StringFilter<"tarefa"> | string
    createdAt?: DateTimeFilter<"tarefa"> | Date | string
    doing?: DateTimeNullableFilter<"tarefa"> | Date | string | null
    concludeAt?: DateTimeNullableFilter<"tarefa"> | Date | string | null
    colorBar?: StringFilter<"tarefa"> | string
    participacoes?: ParticipacaoTarefaListRelationFilter
    anexos?: AnexoTarefaListRelationFilter
    pausas?: PausaTarefaListRelationFilter
  }

  export type tarefaOrderByWithRelationInput = {
    tarefa_id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
    doing?: SortOrderInput | SortOrder
    concludeAt?: SortOrderInput | SortOrder
    colorBar?: SortOrder
    participacoes?: participacaoTarefaOrderByRelationAggregateInput
    anexos?: anexoTarefaOrderByRelationAggregateInput
    pausas?: pausaTarefaOrderByRelationAggregateInput
  }

  export type tarefaWhereUniqueInput = Prisma.AtLeast<{
    tarefa_id?: number
    AND?: tarefaWhereInput | tarefaWhereInput[]
    OR?: tarefaWhereInput[]
    NOT?: tarefaWhereInput | tarefaWhereInput[]
    titulo?: StringFilter<"tarefa"> | string
    descricao?: StringFilter<"tarefa"> | string
    createdAt?: DateTimeFilter<"tarefa"> | Date | string
    doing?: DateTimeNullableFilter<"tarefa"> | Date | string | null
    concludeAt?: DateTimeNullableFilter<"tarefa"> | Date | string | null
    colorBar?: StringFilter<"tarefa"> | string
    participacoes?: ParticipacaoTarefaListRelationFilter
    anexos?: AnexoTarefaListRelationFilter
    pausas?: PausaTarefaListRelationFilter
  }, "tarefa_id">

  export type tarefaOrderByWithAggregationInput = {
    tarefa_id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
    doing?: SortOrderInput | SortOrder
    concludeAt?: SortOrderInput | SortOrder
    colorBar?: SortOrder
    _count?: tarefaCountOrderByAggregateInput
    _avg?: tarefaAvgOrderByAggregateInput
    _max?: tarefaMaxOrderByAggregateInput
    _min?: tarefaMinOrderByAggregateInput
    _sum?: tarefaSumOrderByAggregateInput
  }

  export type tarefaScalarWhereWithAggregatesInput = {
    AND?: tarefaScalarWhereWithAggregatesInput | tarefaScalarWhereWithAggregatesInput[]
    OR?: tarefaScalarWhereWithAggregatesInput[]
    NOT?: tarefaScalarWhereWithAggregatesInput | tarefaScalarWhereWithAggregatesInput[]
    tarefa_id?: IntWithAggregatesFilter<"tarefa"> | number
    titulo?: StringWithAggregatesFilter<"tarefa"> | string
    descricao?: StringWithAggregatesFilter<"tarefa"> | string
    createdAt?: DateTimeWithAggregatesFilter<"tarefa"> | Date | string
    doing?: DateTimeNullableWithAggregatesFilter<"tarefa"> | Date | string | null
    concludeAt?: DateTimeNullableWithAggregatesFilter<"tarefa"> | Date | string | null
    colorBar?: StringWithAggregatesFilter<"tarefa"> | string
  }

  export type projetoUsuarioWhereInput = {
    AND?: projetoUsuarioWhereInput | projetoUsuarioWhereInput[]
    OR?: projetoUsuarioWhereInput[]
    NOT?: projetoUsuarioWhereInput | projetoUsuarioWhereInput[]
    projetoUsuario_id?: IntFilter<"projetoUsuario"> | number
    projeto_id?: IntFilter<"projetoUsuario"> | number
    usuario_id?: IntFilter<"projetoUsuario"> | number
    owner?: BoolFilter<"projetoUsuario"> | boolean
    projeto?: XOR<ProjetoRelationFilter, projetoWhereInput>
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
    participacoes?: ParticipacaoTarefaListRelationFilter
  }

  export type projetoUsuarioOrderByWithRelationInput = {
    projetoUsuario_id?: SortOrder
    projeto_id?: SortOrder
    usuario_id?: SortOrder
    owner?: SortOrder
    projeto?: projetoOrderByWithRelationInput
    usuario?: usuarioOrderByWithRelationInput
    participacoes?: participacaoTarefaOrderByRelationAggregateInput
  }

  export type projetoUsuarioWhereUniqueInput = Prisma.AtLeast<{
    projetoUsuario_id?: number
    AND?: projetoUsuarioWhereInput | projetoUsuarioWhereInput[]
    OR?: projetoUsuarioWhereInput[]
    NOT?: projetoUsuarioWhereInput | projetoUsuarioWhereInput[]
    projeto_id?: IntFilter<"projetoUsuario"> | number
    usuario_id?: IntFilter<"projetoUsuario"> | number
    owner?: BoolFilter<"projetoUsuario"> | boolean
    projeto?: XOR<ProjetoRelationFilter, projetoWhereInput>
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
    participacoes?: ParticipacaoTarefaListRelationFilter
  }, "projetoUsuario_id">

  export type projetoUsuarioOrderByWithAggregationInput = {
    projetoUsuario_id?: SortOrder
    projeto_id?: SortOrder
    usuario_id?: SortOrder
    owner?: SortOrder
    _count?: projetoUsuarioCountOrderByAggregateInput
    _avg?: projetoUsuarioAvgOrderByAggregateInput
    _max?: projetoUsuarioMaxOrderByAggregateInput
    _min?: projetoUsuarioMinOrderByAggregateInput
    _sum?: projetoUsuarioSumOrderByAggregateInput
  }

  export type projetoUsuarioScalarWhereWithAggregatesInput = {
    AND?: projetoUsuarioScalarWhereWithAggregatesInput | projetoUsuarioScalarWhereWithAggregatesInput[]
    OR?: projetoUsuarioScalarWhereWithAggregatesInput[]
    NOT?: projetoUsuarioScalarWhereWithAggregatesInput | projetoUsuarioScalarWhereWithAggregatesInput[]
    projetoUsuario_id?: IntWithAggregatesFilter<"projetoUsuario"> | number
    projeto_id?: IntWithAggregatesFilter<"projetoUsuario"> | number
    usuario_id?: IntWithAggregatesFilter<"projetoUsuario"> | number
    owner?: BoolWithAggregatesFilter<"projetoUsuario"> | boolean
  }

  export type projetoTecnologiaWhereInput = {
    AND?: projetoTecnologiaWhereInput | projetoTecnologiaWhereInput[]
    OR?: projetoTecnologiaWhereInput[]
    NOT?: projetoTecnologiaWhereInput | projetoTecnologiaWhereInput[]
    projetoTecnologia_id?: IntFilter<"projetoTecnologia"> | number
    tecnologia_id?: IntFilter<"projetoTecnologia"> | number
    projeto_id?: IntFilter<"projetoTecnologia"> | number
    projeto?: XOR<ProjetoRelationFilter, projetoWhereInput>
    tecnologia?: XOR<TecnologiaRelationFilter, tecnologiaWhereInput>
  }

  export type projetoTecnologiaOrderByWithRelationInput = {
    projetoTecnologia_id?: SortOrder
    tecnologia_id?: SortOrder
    projeto_id?: SortOrder
    projeto?: projetoOrderByWithRelationInput
    tecnologia?: tecnologiaOrderByWithRelationInput
  }

  export type projetoTecnologiaWhereUniqueInput = Prisma.AtLeast<{
    projetoTecnologia_id?: number
    AND?: projetoTecnologiaWhereInput | projetoTecnologiaWhereInput[]
    OR?: projetoTecnologiaWhereInput[]
    NOT?: projetoTecnologiaWhereInput | projetoTecnologiaWhereInput[]
    tecnologia_id?: IntFilter<"projetoTecnologia"> | number
    projeto_id?: IntFilter<"projetoTecnologia"> | number
    projeto?: XOR<ProjetoRelationFilter, projetoWhereInput>
    tecnologia?: XOR<TecnologiaRelationFilter, tecnologiaWhereInput>
  }, "projetoTecnologia_id">

  export type projetoTecnologiaOrderByWithAggregationInput = {
    projetoTecnologia_id?: SortOrder
    tecnologia_id?: SortOrder
    projeto_id?: SortOrder
    _count?: projetoTecnologiaCountOrderByAggregateInput
    _avg?: projetoTecnologiaAvgOrderByAggregateInput
    _max?: projetoTecnologiaMaxOrderByAggregateInput
    _min?: projetoTecnologiaMinOrderByAggregateInput
    _sum?: projetoTecnologiaSumOrderByAggregateInput
  }

  export type projetoTecnologiaScalarWhereWithAggregatesInput = {
    AND?: projetoTecnologiaScalarWhereWithAggregatesInput | projetoTecnologiaScalarWhereWithAggregatesInput[]
    OR?: projetoTecnologiaScalarWhereWithAggregatesInput[]
    NOT?: projetoTecnologiaScalarWhereWithAggregatesInput | projetoTecnologiaScalarWhereWithAggregatesInput[]
    projetoTecnologia_id?: IntWithAggregatesFilter<"projetoTecnologia"> | number
    tecnologia_id?: IntWithAggregatesFilter<"projetoTecnologia"> | number
    projeto_id?: IntWithAggregatesFilter<"projetoTecnologia"> | number
  }

  export type habilidadeUsuarioWhereInput = {
    AND?: habilidadeUsuarioWhereInput | habilidadeUsuarioWhereInput[]
    OR?: habilidadeUsuarioWhereInput[]
    NOT?: habilidadeUsuarioWhereInput | habilidadeUsuarioWhereInput[]
    habilidadeUsuario_id?: IntFilter<"habilidadeUsuario"> | number
    tecnologia_id?: IntFilter<"habilidadeUsuario"> | number
    usuario_id?: IntFilter<"habilidadeUsuario"> | number
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
    tecnologia?: XOR<TecnologiaRelationFilter, tecnologiaWhereInput>
  }

  export type habilidadeUsuarioOrderByWithRelationInput = {
    habilidadeUsuario_id?: SortOrder
    tecnologia_id?: SortOrder
    usuario_id?: SortOrder
    usuario?: usuarioOrderByWithRelationInput
    tecnologia?: tecnologiaOrderByWithRelationInput
  }

  export type habilidadeUsuarioWhereUniqueInput = Prisma.AtLeast<{
    habilidadeUsuario_id?: number
    AND?: habilidadeUsuarioWhereInput | habilidadeUsuarioWhereInput[]
    OR?: habilidadeUsuarioWhereInput[]
    NOT?: habilidadeUsuarioWhereInput | habilidadeUsuarioWhereInput[]
    tecnologia_id?: IntFilter<"habilidadeUsuario"> | number
    usuario_id?: IntFilter<"habilidadeUsuario"> | number
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
    tecnologia?: XOR<TecnologiaRelationFilter, tecnologiaWhereInput>
  }, "habilidadeUsuario_id">

  export type habilidadeUsuarioOrderByWithAggregationInput = {
    habilidadeUsuario_id?: SortOrder
    tecnologia_id?: SortOrder
    usuario_id?: SortOrder
    _count?: habilidadeUsuarioCountOrderByAggregateInput
    _avg?: habilidadeUsuarioAvgOrderByAggregateInput
    _max?: habilidadeUsuarioMaxOrderByAggregateInput
    _min?: habilidadeUsuarioMinOrderByAggregateInput
    _sum?: habilidadeUsuarioSumOrderByAggregateInput
  }

  export type habilidadeUsuarioScalarWhereWithAggregatesInput = {
    AND?: habilidadeUsuarioScalarWhereWithAggregatesInput | habilidadeUsuarioScalarWhereWithAggregatesInput[]
    OR?: habilidadeUsuarioScalarWhereWithAggregatesInput[]
    NOT?: habilidadeUsuarioScalarWhereWithAggregatesInput | habilidadeUsuarioScalarWhereWithAggregatesInput[]
    habilidadeUsuario_id?: IntWithAggregatesFilter<"habilidadeUsuario"> | number
    tecnologia_id?: IntWithAggregatesFilter<"habilidadeUsuario"> | number
    usuario_id?: IntWithAggregatesFilter<"habilidadeUsuario"> | number
  }

  export type recursoWhereInput = {
    AND?: recursoWhereInput | recursoWhereInput[]
    OR?: recursoWhereInput[]
    NOT?: recursoWhereInput | recursoWhereInput[]
    recurso_id?: IntFilter<"recurso"> | number
    descricao?: StringFilter<"recurso"> | string
    projeto_id?: IntFilter<"recurso"> | number
    projeto?: XOR<ProjetoRelationFilter, projetoWhereInput>
  }

  export type recursoOrderByWithRelationInput = {
    recurso_id?: SortOrder
    descricao?: SortOrder
    projeto_id?: SortOrder
    projeto?: projetoOrderByWithRelationInput
  }

  export type recursoWhereUniqueInput = Prisma.AtLeast<{
    recurso_id?: number
    AND?: recursoWhereInput | recursoWhereInput[]
    OR?: recursoWhereInput[]
    NOT?: recursoWhereInput | recursoWhereInput[]
    descricao?: StringFilter<"recurso"> | string
    projeto_id?: IntFilter<"recurso"> | number
    projeto?: XOR<ProjetoRelationFilter, projetoWhereInput>
  }, "recurso_id">

  export type recursoOrderByWithAggregationInput = {
    recurso_id?: SortOrder
    descricao?: SortOrder
    projeto_id?: SortOrder
    _count?: recursoCountOrderByAggregateInput
    _avg?: recursoAvgOrderByAggregateInput
    _max?: recursoMaxOrderByAggregateInput
    _min?: recursoMinOrderByAggregateInput
    _sum?: recursoSumOrderByAggregateInput
  }

  export type recursoScalarWhereWithAggregatesInput = {
    AND?: recursoScalarWhereWithAggregatesInput | recursoScalarWhereWithAggregatesInput[]
    OR?: recursoScalarWhereWithAggregatesInput[]
    NOT?: recursoScalarWhereWithAggregatesInput | recursoScalarWhereWithAggregatesInput[]
    recurso_id?: IntWithAggregatesFilter<"recurso"> | number
    descricao?: StringWithAggregatesFilter<"recurso"> | string
    projeto_id?: IntWithAggregatesFilter<"recurso"> | number
  }

  export type anexoProjetoWhereInput = {
    AND?: anexoProjetoWhereInput | anexoProjetoWhereInput[]
    OR?: anexoProjetoWhereInput[]
    NOT?: anexoProjetoWhereInput | anexoProjetoWhereInput[]
    anexo_id?: IntFilter<"anexoProjeto"> | number
    nome?: StringFilter<"anexoProjeto"> | string
    tipo?: StringFilter<"anexoProjeto"> | string
    conteudo?: BytesFilter<"anexoProjeto"> | Buffer
    projeto_id?: IntFilter<"anexoProjeto"> | number
    created_at?: DateTimeFilter<"anexoProjeto"> | Date | string
    projeto?: XOR<ProjetoRelationFilter, projetoWhereInput>
  }

  export type anexoProjetoOrderByWithRelationInput = {
    anexo_id?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    conteudo?: SortOrder
    projeto_id?: SortOrder
    created_at?: SortOrder
    projeto?: projetoOrderByWithRelationInput
  }

  export type anexoProjetoWhereUniqueInput = Prisma.AtLeast<{
    anexo_id?: number
    AND?: anexoProjetoWhereInput | anexoProjetoWhereInput[]
    OR?: anexoProjetoWhereInput[]
    NOT?: anexoProjetoWhereInput | anexoProjetoWhereInput[]
    nome?: StringFilter<"anexoProjeto"> | string
    tipo?: StringFilter<"anexoProjeto"> | string
    conteudo?: BytesFilter<"anexoProjeto"> | Buffer
    projeto_id?: IntFilter<"anexoProjeto"> | number
    created_at?: DateTimeFilter<"anexoProjeto"> | Date | string
    projeto?: XOR<ProjetoRelationFilter, projetoWhereInput>
  }, "anexo_id">

  export type anexoProjetoOrderByWithAggregationInput = {
    anexo_id?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    conteudo?: SortOrder
    projeto_id?: SortOrder
    created_at?: SortOrder
    _count?: anexoProjetoCountOrderByAggregateInput
    _avg?: anexoProjetoAvgOrderByAggregateInput
    _max?: anexoProjetoMaxOrderByAggregateInput
    _min?: anexoProjetoMinOrderByAggregateInput
    _sum?: anexoProjetoSumOrderByAggregateInput
  }

  export type anexoProjetoScalarWhereWithAggregatesInput = {
    AND?: anexoProjetoScalarWhereWithAggregatesInput | anexoProjetoScalarWhereWithAggregatesInput[]
    OR?: anexoProjetoScalarWhereWithAggregatesInput[]
    NOT?: anexoProjetoScalarWhereWithAggregatesInput | anexoProjetoScalarWhereWithAggregatesInput[]
    anexo_id?: IntWithAggregatesFilter<"anexoProjeto"> | number
    nome?: StringWithAggregatesFilter<"anexoProjeto"> | string
    tipo?: StringWithAggregatesFilter<"anexoProjeto"> | string
    conteudo?: BytesWithAggregatesFilter<"anexoProjeto"> | Buffer
    projeto_id?: IntWithAggregatesFilter<"anexoProjeto"> | number
    created_at?: DateTimeWithAggregatesFilter<"anexoProjeto"> | Date | string
  }

  export type participacaoTarefaWhereInput = {
    AND?: participacaoTarefaWhereInput | participacaoTarefaWhereInput[]
    OR?: participacaoTarefaWhereInput[]
    NOT?: participacaoTarefaWhereInput | participacaoTarefaWhereInput[]
    participacaoTarefa_id?: IntFilter<"participacaoTarefa"> | number
    tarefa_id?: IntFilter<"participacaoTarefa"> | number
    projetoUsuario_id?: IntFilter<"participacaoTarefa"> | number
    tarefa?: XOR<TarefaRelationFilter, tarefaWhereInput>
    projetoUsuario?: XOR<ProjetoUsuarioRelationFilter, projetoUsuarioWhereInput>
    comentarios?: ComentarioListRelationFilter
    usuarios?: UsuarioListRelationFilter
  }

  export type participacaoTarefaOrderByWithRelationInput = {
    participacaoTarefa_id?: SortOrder
    tarefa_id?: SortOrder
    projetoUsuario_id?: SortOrder
    tarefa?: tarefaOrderByWithRelationInput
    projetoUsuario?: projetoUsuarioOrderByWithRelationInput
    comentarios?: comentarioOrderByRelationAggregateInput
    usuarios?: usuarioOrderByRelationAggregateInput
  }

  export type participacaoTarefaWhereUniqueInput = Prisma.AtLeast<{
    participacaoTarefa_id?: number
    AND?: participacaoTarefaWhereInput | participacaoTarefaWhereInput[]
    OR?: participacaoTarefaWhereInput[]
    NOT?: participacaoTarefaWhereInput | participacaoTarefaWhereInput[]
    tarefa_id?: IntFilter<"participacaoTarefa"> | number
    projetoUsuario_id?: IntFilter<"participacaoTarefa"> | number
    tarefa?: XOR<TarefaRelationFilter, tarefaWhereInput>
    projetoUsuario?: XOR<ProjetoUsuarioRelationFilter, projetoUsuarioWhereInput>
    comentarios?: ComentarioListRelationFilter
    usuarios?: UsuarioListRelationFilter
  }, "participacaoTarefa_id">

  export type participacaoTarefaOrderByWithAggregationInput = {
    participacaoTarefa_id?: SortOrder
    tarefa_id?: SortOrder
    projetoUsuario_id?: SortOrder
    _count?: participacaoTarefaCountOrderByAggregateInput
    _avg?: participacaoTarefaAvgOrderByAggregateInput
    _max?: participacaoTarefaMaxOrderByAggregateInput
    _min?: participacaoTarefaMinOrderByAggregateInput
    _sum?: participacaoTarefaSumOrderByAggregateInput
  }

  export type participacaoTarefaScalarWhereWithAggregatesInput = {
    AND?: participacaoTarefaScalarWhereWithAggregatesInput | participacaoTarefaScalarWhereWithAggregatesInput[]
    OR?: participacaoTarefaScalarWhereWithAggregatesInput[]
    NOT?: participacaoTarefaScalarWhereWithAggregatesInput | participacaoTarefaScalarWhereWithAggregatesInput[]
    participacaoTarefa_id?: IntWithAggregatesFilter<"participacaoTarefa"> | number
    tarefa_id?: IntWithAggregatesFilter<"participacaoTarefa"> | number
    projetoUsuario_id?: IntWithAggregatesFilter<"participacaoTarefa"> | number
  }

  export type comentarioWhereInput = {
    AND?: comentarioWhereInput | comentarioWhereInput[]
    OR?: comentarioWhereInput[]
    NOT?: comentarioWhereInput | comentarioWhereInput[]
    comentario_id?: IntFilter<"comentario"> | number
    comentario?: StringFilter<"comentario"> | string
    data_hora?: DateTimeFilter<"comentario"> | Date | string
    participacaoTarefa_id?: IntFilter<"comentario"> | number
    usuario_id?: IntFilter<"comentario"> | number
    participacaoTarefa?: XOR<ParticipacaoTarefaRelationFilter, participacaoTarefaWhereInput>
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
    anexos?: AnexoComentarioListRelationFilter
  }

  export type comentarioOrderByWithRelationInput = {
    comentario_id?: SortOrder
    comentario?: SortOrder
    data_hora?: SortOrder
    participacaoTarefa_id?: SortOrder
    usuario_id?: SortOrder
    participacaoTarefa?: participacaoTarefaOrderByWithRelationInput
    usuario?: usuarioOrderByWithRelationInput
    anexos?: anexoComentarioOrderByRelationAggregateInput
  }

  export type comentarioWhereUniqueInput = Prisma.AtLeast<{
    comentario_id?: number
    AND?: comentarioWhereInput | comentarioWhereInput[]
    OR?: comentarioWhereInput[]
    NOT?: comentarioWhereInput | comentarioWhereInput[]
    comentario?: StringFilter<"comentario"> | string
    data_hora?: DateTimeFilter<"comentario"> | Date | string
    participacaoTarefa_id?: IntFilter<"comentario"> | number
    usuario_id?: IntFilter<"comentario"> | number
    participacaoTarefa?: XOR<ParticipacaoTarefaRelationFilter, participacaoTarefaWhereInput>
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
    anexos?: AnexoComentarioListRelationFilter
  }, "comentario_id">

  export type comentarioOrderByWithAggregationInput = {
    comentario_id?: SortOrder
    comentario?: SortOrder
    data_hora?: SortOrder
    participacaoTarefa_id?: SortOrder
    usuario_id?: SortOrder
    _count?: comentarioCountOrderByAggregateInput
    _avg?: comentarioAvgOrderByAggregateInput
    _max?: comentarioMaxOrderByAggregateInput
    _min?: comentarioMinOrderByAggregateInput
    _sum?: comentarioSumOrderByAggregateInput
  }

  export type comentarioScalarWhereWithAggregatesInput = {
    AND?: comentarioScalarWhereWithAggregatesInput | comentarioScalarWhereWithAggregatesInput[]
    OR?: comentarioScalarWhereWithAggregatesInput[]
    NOT?: comentarioScalarWhereWithAggregatesInput | comentarioScalarWhereWithAggregatesInput[]
    comentario_id?: IntWithAggregatesFilter<"comentario"> | number
    comentario?: StringWithAggregatesFilter<"comentario"> | string
    data_hora?: DateTimeWithAggregatesFilter<"comentario"> | Date | string
    participacaoTarefa_id?: IntWithAggregatesFilter<"comentario"> | number
    usuario_id?: IntWithAggregatesFilter<"comentario"> | number
  }

  export type anexoTarefaWhereInput = {
    AND?: anexoTarefaWhereInput | anexoTarefaWhereInput[]
    OR?: anexoTarefaWhereInput[]
    NOT?: anexoTarefaWhereInput | anexoTarefaWhereInput[]
    anexoTarefa_id?: IntFilter<"anexoTarefa"> | number
    nome?: StringFilter<"anexoTarefa"> | string
    tipo?: StringFilter<"anexoTarefa"> | string
    conteudo?: BytesFilter<"anexoTarefa"> | Buffer
    created_at?: DateTimeFilter<"anexoTarefa"> | Date | string
    tarefa_id?: IntFilter<"anexoTarefa"> | number
    tarefa?: XOR<TarefaRelationFilter, tarefaWhereInput>
    anexosComentario?: AnexoComentarioListRelationFilter
  }

  export type anexoTarefaOrderByWithRelationInput = {
    anexoTarefa_id?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    conteudo?: SortOrder
    created_at?: SortOrder
    tarefa_id?: SortOrder
    tarefa?: tarefaOrderByWithRelationInput
    anexosComentario?: anexoComentarioOrderByRelationAggregateInput
  }

  export type anexoTarefaWhereUniqueInput = Prisma.AtLeast<{
    anexoTarefa_id?: number
    AND?: anexoTarefaWhereInput | anexoTarefaWhereInput[]
    OR?: anexoTarefaWhereInput[]
    NOT?: anexoTarefaWhereInput | anexoTarefaWhereInput[]
    nome?: StringFilter<"anexoTarefa"> | string
    tipo?: StringFilter<"anexoTarefa"> | string
    conteudo?: BytesFilter<"anexoTarefa"> | Buffer
    created_at?: DateTimeFilter<"anexoTarefa"> | Date | string
    tarefa_id?: IntFilter<"anexoTarefa"> | number
    tarefa?: XOR<TarefaRelationFilter, tarefaWhereInput>
    anexosComentario?: AnexoComentarioListRelationFilter
  }, "anexoTarefa_id">

  export type anexoTarefaOrderByWithAggregationInput = {
    anexoTarefa_id?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    conteudo?: SortOrder
    created_at?: SortOrder
    tarefa_id?: SortOrder
    _count?: anexoTarefaCountOrderByAggregateInput
    _avg?: anexoTarefaAvgOrderByAggregateInput
    _max?: anexoTarefaMaxOrderByAggregateInput
    _min?: anexoTarefaMinOrderByAggregateInput
    _sum?: anexoTarefaSumOrderByAggregateInput
  }

  export type anexoTarefaScalarWhereWithAggregatesInput = {
    AND?: anexoTarefaScalarWhereWithAggregatesInput | anexoTarefaScalarWhereWithAggregatesInput[]
    OR?: anexoTarefaScalarWhereWithAggregatesInput[]
    NOT?: anexoTarefaScalarWhereWithAggregatesInput | anexoTarefaScalarWhereWithAggregatesInput[]
    anexoTarefa_id?: IntWithAggregatesFilter<"anexoTarefa"> | number
    nome?: StringWithAggregatesFilter<"anexoTarefa"> | string
    tipo?: StringWithAggregatesFilter<"anexoTarefa"> | string
    conteudo?: BytesWithAggregatesFilter<"anexoTarefa"> | Buffer
    created_at?: DateTimeWithAggregatesFilter<"anexoTarefa"> | Date | string
    tarefa_id?: IntWithAggregatesFilter<"anexoTarefa"> | number
  }

  export type anexoComentarioWhereInput = {
    AND?: anexoComentarioWhereInput | anexoComentarioWhereInput[]
    OR?: anexoComentarioWhereInput[]
    NOT?: anexoComentarioWhereInput | anexoComentarioWhereInput[]
    anexoComentario_id?: IntFilter<"anexoComentario"> | number
    comentario_id?: IntFilter<"anexoComentario"> | number
    anexoTarefa_id?: IntFilter<"anexoComentario"> | number
    comentario?: XOR<ComentarioRelationFilter, comentarioWhereInput>
    anexoTarefa?: XOR<AnexoTarefaRelationFilter, anexoTarefaWhereInput>
  }

  export type anexoComentarioOrderByWithRelationInput = {
    anexoComentario_id?: SortOrder
    comentario_id?: SortOrder
    anexoTarefa_id?: SortOrder
    comentario?: comentarioOrderByWithRelationInput
    anexoTarefa?: anexoTarefaOrderByWithRelationInput
  }

  export type anexoComentarioWhereUniqueInput = Prisma.AtLeast<{
    anexoComentario_id?: number
    AND?: anexoComentarioWhereInput | anexoComentarioWhereInput[]
    OR?: anexoComentarioWhereInput[]
    NOT?: anexoComentarioWhereInput | anexoComentarioWhereInput[]
    comentario_id?: IntFilter<"anexoComentario"> | number
    anexoTarefa_id?: IntFilter<"anexoComentario"> | number
    comentario?: XOR<ComentarioRelationFilter, comentarioWhereInput>
    anexoTarefa?: XOR<AnexoTarefaRelationFilter, anexoTarefaWhereInput>
  }, "anexoComentario_id">

  export type anexoComentarioOrderByWithAggregationInput = {
    anexoComentario_id?: SortOrder
    comentario_id?: SortOrder
    anexoTarefa_id?: SortOrder
    _count?: anexoComentarioCountOrderByAggregateInput
    _avg?: anexoComentarioAvgOrderByAggregateInput
    _max?: anexoComentarioMaxOrderByAggregateInput
    _min?: anexoComentarioMinOrderByAggregateInput
    _sum?: anexoComentarioSumOrderByAggregateInput
  }

  export type anexoComentarioScalarWhereWithAggregatesInput = {
    AND?: anexoComentarioScalarWhereWithAggregatesInput | anexoComentarioScalarWhereWithAggregatesInput[]
    OR?: anexoComentarioScalarWhereWithAggregatesInput[]
    NOT?: anexoComentarioScalarWhereWithAggregatesInput | anexoComentarioScalarWhereWithAggregatesInput[]
    anexoComentario_id?: IntWithAggregatesFilter<"anexoComentario"> | number
    comentario_id?: IntWithAggregatesFilter<"anexoComentario"> | number
    anexoTarefa_id?: IntWithAggregatesFilter<"anexoComentario"> | number
  }

  export type permissaoWhereInput = {
    AND?: permissaoWhereInput | permissaoWhereInput[]
    OR?: permissaoWhereInput[]
    NOT?: permissaoWhereInput | permissaoWhereInput[]
    permissao_id?: IntFilter<"permissao"> | number
    tipo?: StringFilter<"permissao"> | string
    usuario_id?: IntFilter<"permissao"> | number
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
  }

  export type permissaoOrderByWithRelationInput = {
    permissao_id?: SortOrder
    tipo?: SortOrder
    usuario_id?: SortOrder
    usuario?: usuarioOrderByWithRelationInput
  }

  export type permissaoWhereUniqueInput = Prisma.AtLeast<{
    permissao_id?: number
    AND?: permissaoWhereInput | permissaoWhereInput[]
    OR?: permissaoWhereInput[]
    NOT?: permissaoWhereInput | permissaoWhereInput[]
    tipo?: StringFilter<"permissao"> | string
    usuario_id?: IntFilter<"permissao"> | number
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
  }, "permissao_id">

  export type permissaoOrderByWithAggregationInput = {
    permissao_id?: SortOrder
    tipo?: SortOrder
    usuario_id?: SortOrder
    _count?: permissaoCountOrderByAggregateInput
    _avg?: permissaoAvgOrderByAggregateInput
    _max?: permissaoMaxOrderByAggregateInput
    _min?: permissaoMinOrderByAggregateInput
    _sum?: permissaoSumOrderByAggregateInput
  }

  export type permissaoScalarWhereWithAggregatesInput = {
    AND?: permissaoScalarWhereWithAggregatesInput | permissaoScalarWhereWithAggregatesInput[]
    OR?: permissaoScalarWhereWithAggregatesInput[]
    NOT?: permissaoScalarWhereWithAggregatesInput | permissaoScalarWhereWithAggregatesInput[]
    permissao_id?: IntWithAggregatesFilter<"permissao"> | number
    tipo?: StringWithAggregatesFilter<"permissao"> | string
    usuario_id?: IntWithAggregatesFilter<"permissao"> | number
  }

  export type permissaoProjetoWhereInput = {
    AND?: permissaoProjetoWhereInput | permissaoProjetoWhereInput[]
    OR?: permissaoProjetoWhereInput[]
    NOT?: permissaoProjetoWhereInput | permissaoProjetoWhereInput[]
    permissaoProjeto_id?: IntFilter<"permissaoProjeto"> | number
    tipo?: StringFilter<"permissaoProjeto"> | string
    usuario_id?: IntFilter<"permissaoProjeto"> | number
    projeto_id?: IntFilter<"permissaoProjeto"> | number
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
    projeto?: XOR<ProjetoRelationFilter, projetoWhereInput>
  }

  export type permissaoProjetoOrderByWithRelationInput = {
    permissaoProjeto_id?: SortOrder
    tipo?: SortOrder
    usuario_id?: SortOrder
    projeto_id?: SortOrder
    usuario?: usuarioOrderByWithRelationInput
    projeto?: projetoOrderByWithRelationInput
  }

  export type permissaoProjetoWhereUniqueInput = Prisma.AtLeast<{
    permissaoProjeto_id?: number
    AND?: permissaoProjetoWhereInput | permissaoProjetoWhereInput[]
    OR?: permissaoProjetoWhereInput[]
    NOT?: permissaoProjetoWhereInput | permissaoProjetoWhereInput[]
    tipo?: StringFilter<"permissaoProjeto"> | string
    usuario_id?: IntFilter<"permissaoProjeto"> | number
    projeto_id?: IntFilter<"permissaoProjeto"> | number
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
    projeto?: XOR<ProjetoRelationFilter, projetoWhereInput>
  }, "permissaoProjeto_id">

  export type permissaoProjetoOrderByWithAggregationInput = {
    permissaoProjeto_id?: SortOrder
    tipo?: SortOrder
    usuario_id?: SortOrder
    projeto_id?: SortOrder
    _count?: permissaoProjetoCountOrderByAggregateInput
    _avg?: permissaoProjetoAvgOrderByAggregateInput
    _max?: permissaoProjetoMaxOrderByAggregateInput
    _min?: permissaoProjetoMinOrderByAggregateInput
    _sum?: permissaoProjetoSumOrderByAggregateInput
  }

  export type permissaoProjetoScalarWhereWithAggregatesInput = {
    AND?: permissaoProjetoScalarWhereWithAggregatesInput | permissaoProjetoScalarWhereWithAggregatesInput[]
    OR?: permissaoProjetoScalarWhereWithAggregatesInput[]
    NOT?: permissaoProjetoScalarWhereWithAggregatesInput | permissaoProjetoScalarWhereWithAggregatesInput[]
    permissaoProjeto_id?: IntWithAggregatesFilter<"permissaoProjeto"> | number
    tipo?: StringWithAggregatesFilter<"permissaoProjeto"> | string
    usuario_id?: IntWithAggregatesFilter<"permissaoProjeto"> | number
    projeto_id?: IntWithAggregatesFilter<"permissaoProjeto"> | number
  }

  export type pausaTarefaWhereInput = {
    AND?: pausaTarefaWhereInput | pausaTarefaWhereInput[]
    OR?: pausaTarefaWhereInput[]
    NOT?: pausaTarefaWhereInput | pausaTarefaWhereInput[]
    pausa_id?: IntFilter<"pausaTarefa"> | number
    tarefa_id?: IntFilter<"pausaTarefa"> | number
    inicioPausa?: DateTimeFilter<"pausaTarefa"> | Date | string
    fimPausa?: DateTimeNullableFilter<"pausaTarefa"> | Date | string | null
    tarefa?: XOR<TarefaRelationFilter, tarefaWhereInput>
  }

  export type pausaTarefaOrderByWithRelationInput = {
    pausa_id?: SortOrder
    tarefa_id?: SortOrder
    inicioPausa?: SortOrder
    fimPausa?: SortOrderInput | SortOrder
    tarefa?: tarefaOrderByWithRelationInput
  }

  export type pausaTarefaWhereUniqueInput = Prisma.AtLeast<{
    pausa_id?: number
    AND?: pausaTarefaWhereInput | pausaTarefaWhereInput[]
    OR?: pausaTarefaWhereInput[]
    NOT?: pausaTarefaWhereInput | pausaTarefaWhereInput[]
    tarefa_id?: IntFilter<"pausaTarefa"> | number
    inicioPausa?: DateTimeFilter<"pausaTarefa"> | Date | string
    fimPausa?: DateTimeNullableFilter<"pausaTarefa"> | Date | string | null
    tarefa?: XOR<TarefaRelationFilter, tarefaWhereInput>
  }, "pausa_id">

  export type pausaTarefaOrderByWithAggregationInput = {
    pausa_id?: SortOrder
    tarefa_id?: SortOrder
    inicioPausa?: SortOrder
    fimPausa?: SortOrderInput | SortOrder
    _count?: pausaTarefaCountOrderByAggregateInput
    _avg?: pausaTarefaAvgOrderByAggregateInput
    _max?: pausaTarefaMaxOrderByAggregateInput
    _min?: pausaTarefaMinOrderByAggregateInput
    _sum?: pausaTarefaSumOrderByAggregateInput
  }

  export type pausaTarefaScalarWhereWithAggregatesInput = {
    AND?: pausaTarefaScalarWhereWithAggregatesInput | pausaTarefaScalarWhereWithAggregatesInput[]
    OR?: pausaTarefaScalarWhereWithAggregatesInput[]
    NOT?: pausaTarefaScalarWhereWithAggregatesInput | pausaTarefaScalarWhereWithAggregatesInput[]
    pausa_id?: IntWithAggregatesFilter<"pausaTarefa"> | number
    tarefa_id?: IntWithAggregatesFilter<"pausaTarefa"> | number
    inicioPausa?: DateTimeWithAggregatesFilter<"pausaTarefa"> | Date | string
    fimPausa?: DateTimeNullableWithAggregatesFilter<"pausaTarefa"> | Date | string | null
  }

  export type loginCreateInput = {
    email: string
    password?: string | null
    is_verified?: boolean
    provider?: string
    provider_id?: string | null
    profile_image?: string | null
    ativo?: boolean
    usuario?: usuarioCreateNestedOneWithoutLoginInput
  }

  export type loginUncheckedCreateInput = {
    login_id?: number
    email: string
    password?: string | null
    is_verified?: boolean
    provider?: string
    provider_id?: string | null
    profile_image?: string | null
    ativo?: boolean
    usuario?: usuarioUncheckedCreateNestedOneWithoutLoginInput
  }

  export type loginUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    usuario?: usuarioUpdateOneWithoutLoginNestedInput
  }

  export type loginUncheckedUpdateInput = {
    login_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    usuario?: usuarioUncheckedUpdateOneWithoutLoginNestedInput
  }

  export type loginCreateManyInput = {
    login_id?: number
    email: string
    password?: string | null
    is_verified?: boolean
    provider?: string
    provider_id?: string | null
    profile_image?: string | null
    ativo?: boolean
  }

  export type loginUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type loginUncheckedUpdateManyInput = {
    login_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type usuarioCreateInput = {
    nome: string
    created_at?: Date | string
    roule?: string | null
    login: loginCreateNestedOneWithoutUsuarioInput
    projetoUsuarios?: projetoUsuarioCreateNestedManyWithoutUsuarioInput
    habilidades?: habilidadeUsuarioCreateNestedManyWithoutUsuarioInput
    permissoes?: permissaoCreateNestedManyWithoutUsuarioInput
    permissoesProjeto?: permissaoProjetoCreateNestedManyWithoutUsuarioInput
    participacoes?: participacaoTarefaCreateNestedManyWithoutUsuariosInput
    comentarios?: comentarioCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateInput = {
    usuario_id?: number
    nome: string
    created_at?: Date | string
    roule?: string | null
    login_id: number
    projetoUsuarios?: projetoUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    habilidades?: habilidadeUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    permissoes?: permissaoUncheckedCreateNestedManyWithoutUsuarioInput
    permissoesProjeto?: permissaoProjetoUncheckedCreateNestedManyWithoutUsuarioInput
    participacoes?: participacaoTarefaUncheckedCreateNestedManyWithoutUsuariosInput
    comentarios?: comentarioUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    roule?: NullableStringFieldUpdateOperationsInput | string | null
    login?: loginUpdateOneRequiredWithoutUsuarioNestedInput
    projetoUsuarios?: projetoUsuarioUpdateManyWithoutUsuarioNestedInput
    habilidades?: habilidadeUsuarioUpdateManyWithoutUsuarioNestedInput
    permissoes?: permissaoUpdateManyWithoutUsuarioNestedInput
    permissoesProjeto?: permissaoProjetoUpdateManyWithoutUsuarioNestedInput
    participacoes?: participacaoTarefaUpdateManyWithoutUsuariosNestedInput
    comentarios?: comentarioUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    roule?: NullableStringFieldUpdateOperationsInput | string | null
    login_id?: IntFieldUpdateOperationsInput | number
    projetoUsuarios?: projetoUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    habilidades?: habilidadeUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    permissoes?: permissaoUncheckedUpdateManyWithoutUsuarioNestedInput
    permissoesProjeto?: permissaoProjetoUncheckedUpdateManyWithoutUsuarioNestedInput
    participacoes?: participacaoTarefaUncheckedUpdateManyWithoutUsuariosNestedInput
    comentarios?: comentarioUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioCreateManyInput = {
    usuario_id?: number
    nome: string
    created_at?: Date | string
    roule?: string | null
    login_id: number
  }

  export type usuarioUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    roule?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usuarioUncheckedUpdateManyInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    roule?: NullableStringFieldUpdateOperationsInput | string | null
    login_id?: IntFieldUpdateOperationsInput | number
  }

  export type projetoCreateInput = {
    nome: string
    descricao: string
    created_at?: Date | string
    conclude_at?: Date | string | null
    projetoUsuarios?: projetoUsuarioCreateNestedManyWithoutProjetoInput
    tecnologias?: projetoTecnologiaCreateNestedManyWithoutProjetoInput
    recursos?: recursoCreateNestedManyWithoutProjetoInput
    anexos?: anexoProjetoCreateNestedManyWithoutProjetoInput
    permissoes?: permissaoProjetoCreateNestedManyWithoutProjetoInput
  }

  export type projetoUncheckedCreateInput = {
    projeto_id?: number
    nome: string
    descricao: string
    created_at?: Date | string
    conclude_at?: Date | string | null
    projetoUsuarios?: projetoUsuarioUncheckedCreateNestedManyWithoutProjetoInput
    tecnologias?: projetoTecnologiaUncheckedCreateNestedManyWithoutProjetoInput
    recursos?: recursoUncheckedCreateNestedManyWithoutProjetoInput
    anexos?: anexoProjetoUncheckedCreateNestedManyWithoutProjetoInput
    permissoes?: permissaoProjetoUncheckedCreateNestedManyWithoutProjetoInput
  }

  export type projetoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    conclude_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projetoUsuarios?: projetoUsuarioUpdateManyWithoutProjetoNestedInput
    tecnologias?: projetoTecnologiaUpdateManyWithoutProjetoNestedInput
    recursos?: recursoUpdateManyWithoutProjetoNestedInput
    anexos?: anexoProjetoUpdateManyWithoutProjetoNestedInput
    permissoes?: permissaoProjetoUpdateManyWithoutProjetoNestedInput
  }

  export type projetoUncheckedUpdateInput = {
    projeto_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    conclude_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projetoUsuarios?: projetoUsuarioUncheckedUpdateManyWithoutProjetoNestedInput
    tecnologias?: projetoTecnologiaUncheckedUpdateManyWithoutProjetoNestedInput
    recursos?: recursoUncheckedUpdateManyWithoutProjetoNestedInput
    anexos?: anexoProjetoUncheckedUpdateManyWithoutProjetoNestedInput
    permissoes?: permissaoProjetoUncheckedUpdateManyWithoutProjetoNestedInput
  }

  export type projetoCreateManyInput = {
    projeto_id?: number
    nome: string
    descricao: string
    created_at?: Date | string
    conclude_at?: Date | string | null
  }

  export type projetoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    conclude_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projetoUncheckedUpdateManyInput = {
    projeto_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    conclude_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tecnologiaCreateInput = {
    descricao: string
    habilidades?: habilidadeUsuarioCreateNestedManyWithoutTecnologiaInput
    projetos?: projetoTecnologiaCreateNestedManyWithoutTecnologiaInput
  }

  export type tecnologiaUncheckedCreateInput = {
    tecnologia_id?: number
    descricao: string
    habilidades?: habilidadeUsuarioUncheckedCreateNestedManyWithoutTecnologiaInput
    projetos?: projetoTecnologiaUncheckedCreateNestedManyWithoutTecnologiaInput
  }

  export type tecnologiaUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    habilidades?: habilidadeUsuarioUpdateManyWithoutTecnologiaNestedInput
    projetos?: projetoTecnologiaUpdateManyWithoutTecnologiaNestedInput
  }

  export type tecnologiaUncheckedUpdateInput = {
    tecnologia_id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    habilidades?: habilidadeUsuarioUncheckedUpdateManyWithoutTecnologiaNestedInput
    projetos?: projetoTecnologiaUncheckedUpdateManyWithoutTecnologiaNestedInput
  }

  export type tecnologiaCreateManyInput = {
    tecnologia_id?: number
    descricao: string
  }

  export type tecnologiaUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type tecnologiaUncheckedUpdateManyInput = {
    tecnologia_id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type tarefaCreateInput = {
    titulo: string
    descricao: string
    createdAt?: Date | string
    doing?: Date | string | null
    concludeAt?: Date | string | null
    colorBar?: string
    participacoes?: participacaoTarefaCreateNestedManyWithoutTarefaInput
    anexos?: anexoTarefaCreateNestedManyWithoutTarefaInput
    pausas?: pausaTarefaCreateNestedManyWithoutTarefaInput
  }

  export type tarefaUncheckedCreateInput = {
    tarefa_id?: number
    titulo: string
    descricao: string
    createdAt?: Date | string
    doing?: Date | string | null
    concludeAt?: Date | string | null
    colorBar?: string
    participacoes?: participacaoTarefaUncheckedCreateNestedManyWithoutTarefaInput
    anexos?: anexoTarefaUncheckedCreateNestedManyWithoutTarefaInput
    pausas?: pausaTarefaUncheckedCreateNestedManyWithoutTarefaInput
  }

  export type tarefaUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doing?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    colorBar?: StringFieldUpdateOperationsInput | string
    participacoes?: participacaoTarefaUpdateManyWithoutTarefaNestedInput
    anexos?: anexoTarefaUpdateManyWithoutTarefaNestedInput
    pausas?: pausaTarefaUpdateManyWithoutTarefaNestedInput
  }

  export type tarefaUncheckedUpdateInput = {
    tarefa_id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doing?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    colorBar?: StringFieldUpdateOperationsInput | string
    participacoes?: participacaoTarefaUncheckedUpdateManyWithoutTarefaNestedInput
    anexos?: anexoTarefaUncheckedUpdateManyWithoutTarefaNestedInput
    pausas?: pausaTarefaUncheckedUpdateManyWithoutTarefaNestedInput
  }

  export type tarefaCreateManyInput = {
    tarefa_id?: number
    titulo: string
    descricao: string
    createdAt?: Date | string
    doing?: Date | string | null
    concludeAt?: Date | string | null
    colorBar?: string
  }

  export type tarefaUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doing?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    colorBar?: StringFieldUpdateOperationsInput | string
  }

  export type tarefaUncheckedUpdateManyInput = {
    tarefa_id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doing?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    colorBar?: StringFieldUpdateOperationsInput | string
  }

  export type projetoUsuarioCreateInput = {
    owner?: boolean
    projeto: projetoCreateNestedOneWithoutProjetoUsuariosInput
    usuario: usuarioCreateNestedOneWithoutProjetoUsuariosInput
    participacoes?: participacaoTarefaCreateNestedManyWithoutProjetoUsuarioInput
  }

  export type projetoUsuarioUncheckedCreateInput = {
    projetoUsuario_id?: number
    projeto_id: number
    usuario_id: number
    owner?: boolean
    participacoes?: participacaoTarefaUncheckedCreateNestedManyWithoutProjetoUsuarioInput
  }

  export type projetoUsuarioUpdateInput = {
    owner?: BoolFieldUpdateOperationsInput | boolean
    projeto?: projetoUpdateOneRequiredWithoutProjetoUsuariosNestedInput
    usuario?: usuarioUpdateOneRequiredWithoutProjetoUsuariosNestedInput
    participacoes?: participacaoTarefaUpdateManyWithoutProjetoUsuarioNestedInput
  }

  export type projetoUsuarioUncheckedUpdateInput = {
    projetoUsuario_id?: IntFieldUpdateOperationsInput | number
    projeto_id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    owner?: BoolFieldUpdateOperationsInput | boolean
    participacoes?: participacaoTarefaUncheckedUpdateManyWithoutProjetoUsuarioNestedInput
  }

  export type projetoUsuarioCreateManyInput = {
    projetoUsuario_id?: number
    projeto_id: number
    usuario_id: number
    owner?: boolean
  }

  export type projetoUsuarioUpdateManyMutationInput = {
    owner?: BoolFieldUpdateOperationsInput | boolean
  }

  export type projetoUsuarioUncheckedUpdateManyInput = {
    projetoUsuario_id?: IntFieldUpdateOperationsInput | number
    projeto_id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    owner?: BoolFieldUpdateOperationsInput | boolean
  }

  export type projetoTecnologiaCreateInput = {
    projeto: projetoCreateNestedOneWithoutTecnologiasInput
    tecnologia: tecnologiaCreateNestedOneWithoutProjetosInput
  }

  export type projetoTecnologiaUncheckedCreateInput = {
    projetoTecnologia_id?: number
    tecnologia_id: number
    projeto_id: number
  }

  export type projetoTecnologiaUpdateInput = {
    projeto?: projetoUpdateOneRequiredWithoutTecnologiasNestedInput
    tecnologia?: tecnologiaUpdateOneRequiredWithoutProjetosNestedInput
  }

  export type projetoTecnologiaUncheckedUpdateInput = {
    projetoTecnologia_id?: IntFieldUpdateOperationsInput | number
    tecnologia_id?: IntFieldUpdateOperationsInput | number
    projeto_id?: IntFieldUpdateOperationsInput | number
  }

  export type projetoTecnologiaCreateManyInput = {
    projetoTecnologia_id?: number
    tecnologia_id: number
    projeto_id: number
  }

  export type projetoTecnologiaUpdateManyMutationInput = {

  }

  export type projetoTecnologiaUncheckedUpdateManyInput = {
    projetoTecnologia_id?: IntFieldUpdateOperationsInput | number
    tecnologia_id?: IntFieldUpdateOperationsInput | number
    projeto_id?: IntFieldUpdateOperationsInput | number
  }

  export type habilidadeUsuarioCreateInput = {
    usuario: usuarioCreateNestedOneWithoutHabilidadesInput
    tecnologia: tecnologiaCreateNestedOneWithoutHabilidadesInput
  }

  export type habilidadeUsuarioUncheckedCreateInput = {
    habilidadeUsuario_id?: number
    tecnologia_id: number
    usuario_id: number
  }

  export type habilidadeUsuarioUpdateInput = {
    usuario?: usuarioUpdateOneRequiredWithoutHabilidadesNestedInput
    tecnologia?: tecnologiaUpdateOneRequiredWithoutHabilidadesNestedInput
  }

  export type habilidadeUsuarioUncheckedUpdateInput = {
    habilidadeUsuario_id?: IntFieldUpdateOperationsInput | number
    tecnologia_id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type habilidadeUsuarioCreateManyInput = {
    habilidadeUsuario_id?: number
    tecnologia_id: number
    usuario_id: number
  }

  export type habilidadeUsuarioUpdateManyMutationInput = {

  }

  export type habilidadeUsuarioUncheckedUpdateManyInput = {
    habilidadeUsuario_id?: IntFieldUpdateOperationsInput | number
    tecnologia_id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type recursoCreateInput = {
    descricao: string
    projeto: projetoCreateNestedOneWithoutRecursosInput
  }

  export type recursoUncheckedCreateInput = {
    recurso_id?: number
    descricao: string
    projeto_id: number
  }

  export type recursoUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    projeto?: projetoUpdateOneRequiredWithoutRecursosNestedInput
  }

  export type recursoUncheckedUpdateInput = {
    recurso_id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    projeto_id?: IntFieldUpdateOperationsInput | number
  }

  export type recursoCreateManyInput = {
    recurso_id?: number
    descricao: string
    projeto_id: number
  }

  export type recursoUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type recursoUncheckedUpdateManyInput = {
    recurso_id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    projeto_id?: IntFieldUpdateOperationsInput | number
  }

  export type anexoProjetoCreateInput = {
    nome: string
    tipo: string
    conteudo: Buffer
    created_at?: Date | string
    projeto: projetoCreateNestedOneWithoutAnexosInput
  }

  export type anexoProjetoUncheckedCreateInput = {
    anexo_id?: number
    nome: string
    tipo: string
    conteudo: Buffer
    projeto_id: number
    created_at?: Date | string
  }

  export type anexoProjetoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    conteudo?: BytesFieldUpdateOperationsInput | Buffer
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projeto?: projetoUpdateOneRequiredWithoutAnexosNestedInput
  }

  export type anexoProjetoUncheckedUpdateInput = {
    anexo_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    conteudo?: BytesFieldUpdateOperationsInput | Buffer
    projeto_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type anexoProjetoCreateManyInput = {
    anexo_id?: number
    nome: string
    tipo: string
    conteudo: Buffer
    projeto_id: number
    created_at?: Date | string
  }

  export type anexoProjetoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    conteudo?: BytesFieldUpdateOperationsInput | Buffer
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type anexoProjetoUncheckedUpdateManyInput = {
    anexo_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    conteudo?: BytesFieldUpdateOperationsInput | Buffer
    projeto_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type participacaoTarefaCreateInput = {
    tarefa: tarefaCreateNestedOneWithoutParticipacoesInput
    projetoUsuario: projetoUsuarioCreateNestedOneWithoutParticipacoesInput
    comentarios?: comentarioCreateNestedManyWithoutParticipacaoTarefaInput
    usuarios?: usuarioCreateNestedManyWithoutParticipacoesInput
  }

  export type participacaoTarefaUncheckedCreateInput = {
    participacaoTarefa_id?: number
    tarefa_id: number
    projetoUsuario_id: number
    comentarios?: comentarioUncheckedCreateNestedManyWithoutParticipacaoTarefaInput
    usuarios?: usuarioUncheckedCreateNestedManyWithoutParticipacoesInput
  }

  export type participacaoTarefaUpdateInput = {
    tarefa?: tarefaUpdateOneRequiredWithoutParticipacoesNestedInput
    projetoUsuario?: projetoUsuarioUpdateOneRequiredWithoutParticipacoesNestedInput
    comentarios?: comentarioUpdateManyWithoutParticipacaoTarefaNestedInput
    usuarios?: usuarioUpdateManyWithoutParticipacoesNestedInput
  }

  export type participacaoTarefaUncheckedUpdateInput = {
    participacaoTarefa_id?: IntFieldUpdateOperationsInput | number
    tarefa_id?: IntFieldUpdateOperationsInput | number
    projetoUsuario_id?: IntFieldUpdateOperationsInput | number
    comentarios?: comentarioUncheckedUpdateManyWithoutParticipacaoTarefaNestedInput
    usuarios?: usuarioUncheckedUpdateManyWithoutParticipacoesNestedInput
  }

  export type participacaoTarefaCreateManyInput = {
    participacaoTarefa_id?: number
    tarefa_id: number
    projetoUsuario_id: number
  }

  export type participacaoTarefaUpdateManyMutationInput = {

  }

  export type participacaoTarefaUncheckedUpdateManyInput = {
    participacaoTarefa_id?: IntFieldUpdateOperationsInput | number
    tarefa_id?: IntFieldUpdateOperationsInput | number
    projetoUsuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type comentarioCreateInput = {
    comentario: string
    data_hora?: Date | string
    participacaoTarefa: participacaoTarefaCreateNestedOneWithoutComentariosInput
    usuario: usuarioCreateNestedOneWithoutComentariosInput
    anexos?: anexoComentarioCreateNestedManyWithoutComentarioInput
  }

  export type comentarioUncheckedCreateInput = {
    comentario_id?: number
    comentario: string
    data_hora?: Date | string
    participacaoTarefa_id: number
    usuario_id: number
    anexos?: anexoComentarioUncheckedCreateNestedManyWithoutComentarioInput
  }

  export type comentarioUpdateInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    participacaoTarefa?: participacaoTarefaUpdateOneRequiredWithoutComentariosNestedInput
    usuario?: usuarioUpdateOneRequiredWithoutComentariosNestedInput
    anexos?: anexoComentarioUpdateManyWithoutComentarioNestedInput
  }

  export type comentarioUncheckedUpdateInput = {
    comentario_id?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    participacaoTarefa_id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    anexos?: anexoComentarioUncheckedUpdateManyWithoutComentarioNestedInput
  }

  export type comentarioCreateManyInput = {
    comentario_id?: number
    comentario: string
    data_hora?: Date | string
    participacaoTarefa_id: number
    usuario_id: number
  }

  export type comentarioUpdateManyMutationInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comentarioUncheckedUpdateManyInput = {
    comentario_id?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    participacaoTarefa_id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type anexoTarefaCreateInput = {
    nome: string
    tipo: string
    conteudo: Buffer
    created_at?: Date | string
    tarefa: tarefaCreateNestedOneWithoutAnexosInput
    anexosComentario?: anexoComentarioCreateNestedManyWithoutAnexoTarefaInput
  }

  export type anexoTarefaUncheckedCreateInput = {
    anexoTarefa_id?: number
    nome: string
    tipo: string
    conteudo: Buffer
    created_at?: Date | string
    tarefa_id: number
    anexosComentario?: anexoComentarioUncheckedCreateNestedManyWithoutAnexoTarefaInput
  }

  export type anexoTarefaUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    conteudo?: BytesFieldUpdateOperationsInput | Buffer
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tarefa?: tarefaUpdateOneRequiredWithoutAnexosNestedInput
    anexosComentario?: anexoComentarioUpdateManyWithoutAnexoTarefaNestedInput
  }

  export type anexoTarefaUncheckedUpdateInput = {
    anexoTarefa_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    conteudo?: BytesFieldUpdateOperationsInput | Buffer
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tarefa_id?: IntFieldUpdateOperationsInput | number
    anexosComentario?: anexoComentarioUncheckedUpdateManyWithoutAnexoTarefaNestedInput
  }

  export type anexoTarefaCreateManyInput = {
    anexoTarefa_id?: number
    nome: string
    tipo: string
    conteudo: Buffer
    created_at?: Date | string
    tarefa_id: number
  }

  export type anexoTarefaUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    conteudo?: BytesFieldUpdateOperationsInput | Buffer
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type anexoTarefaUncheckedUpdateManyInput = {
    anexoTarefa_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    conteudo?: BytesFieldUpdateOperationsInput | Buffer
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tarefa_id?: IntFieldUpdateOperationsInput | number
  }

  export type anexoComentarioCreateInput = {
    comentario: comentarioCreateNestedOneWithoutAnexosInput
    anexoTarefa: anexoTarefaCreateNestedOneWithoutAnexosComentarioInput
  }

  export type anexoComentarioUncheckedCreateInput = {
    anexoComentario_id?: number
    comentario_id: number
    anexoTarefa_id: number
  }

  export type anexoComentarioUpdateInput = {
    comentario?: comentarioUpdateOneRequiredWithoutAnexosNestedInput
    anexoTarefa?: anexoTarefaUpdateOneRequiredWithoutAnexosComentarioNestedInput
  }

  export type anexoComentarioUncheckedUpdateInput = {
    anexoComentario_id?: IntFieldUpdateOperationsInput | number
    comentario_id?: IntFieldUpdateOperationsInput | number
    anexoTarefa_id?: IntFieldUpdateOperationsInput | number
  }

  export type anexoComentarioCreateManyInput = {
    anexoComentario_id?: number
    comentario_id: number
    anexoTarefa_id: number
  }

  export type anexoComentarioUpdateManyMutationInput = {

  }

  export type anexoComentarioUncheckedUpdateManyInput = {
    anexoComentario_id?: IntFieldUpdateOperationsInput | number
    comentario_id?: IntFieldUpdateOperationsInput | number
    anexoTarefa_id?: IntFieldUpdateOperationsInput | number
  }

  export type permissaoCreateInput = {
    tipo: string
    usuario: usuarioCreateNestedOneWithoutPermissoesInput
  }

  export type permissaoUncheckedCreateInput = {
    permissao_id?: number
    tipo: string
    usuario_id: number
  }

  export type permissaoUpdateInput = {
    tipo?: StringFieldUpdateOperationsInput | string
    usuario?: usuarioUpdateOneRequiredWithoutPermissoesNestedInput
  }

  export type permissaoUncheckedUpdateInput = {
    permissao_id?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type permissaoCreateManyInput = {
    permissao_id?: number
    tipo: string
    usuario_id: number
  }

  export type permissaoUpdateManyMutationInput = {
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type permissaoUncheckedUpdateManyInput = {
    permissao_id?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type permissaoProjetoCreateInput = {
    tipo: string
    usuario: usuarioCreateNestedOneWithoutPermissoesProjetoInput
    projeto: projetoCreateNestedOneWithoutPermissoesInput
  }

  export type permissaoProjetoUncheckedCreateInput = {
    permissaoProjeto_id?: number
    tipo: string
    usuario_id: number
    projeto_id: number
  }

  export type permissaoProjetoUpdateInput = {
    tipo?: StringFieldUpdateOperationsInput | string
    usuario?: usuarioUpdateOneRequiredWithoutPermissoesProjetoNestedInput
    projeto?: projetoUpdateOneRequiredWithoutPermissoesNestedInput
  }

  export type permissaoProjetoUncheckedUpdateInput = {
    permissaoProjeto_id?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    usuario_id?: IntFieldUpdateOperationsInput | number
    projeto_id?: IntFieldUpdateOperationsInput | number
  }

  export type permissaoProjetoCreateManyInput = {
    permissaoProjeto_id?: number
    tipo: string
    usuario_id: number
    projeto_id: number
  }

  export type permissaoProjetoUpdateManyMutationInput = {
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type permissaoProjetoUncheckedUpdateManyInput = {
    permissaoProjeto_id?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    usuario_id?: IntFieldUpdateOperationsInput | number
    projeto_id?: IntFieldUpdateOperationsInput | number
  }

  export type pausaTarefaCreateInput = {
    inicioPausa: Date | string
    fimPausa?: Date | string | null
    tarefa: tarefaCreateNestedOneWithoutPausasInput
  }

  export type pausaTarefaUncheckedCreateInput = {
    pausa_id?: number
    tarefa_id: number
    inicioPausa: Date | string
    fimPausa?: Date | string | null
  }

  export type pausaTarefaUpdateInput = {
    inicioPausa?: DateTimeFieldUpdateOperationsInput | Date | string
    fimPausa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tarefa?: tarefaUpdateOneRequiredWithoutPausasNestedInput
  }

  export type pausaTarefaUncheckedUpdateInput = {
    pausa_id?: IntFieldUpdateOperationsInput | number
    tarefa_id?: IntFieldUpdateOperationsInput | number
    inicioPausa?: DateTimeFieldUpdateOperationsInput | Date | string
    fimPausa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pausaTarefaCreateManyInput = {
    pausa_id?: number
    tarefa_id: number
    inicioPausa: Date | string
    fimPausa?: Date | string | null
  }

  export type pausaTarefaUpdateManyMutationInput = {
    inicioPausa?: DateTimeFieldUpdateOperationsInput | Date | string
    fimPausa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pausaTarefaUncheckedUpdateManyInput = {
    pausa_id?: IntFieldUpdateOperationsInput | number
    tarefa_id?: IntFieldUpdateOperationsInput | number
    inicioPausa?: DateTimeFieldUpdateOperationsInput | Date | string
    fimPausa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UsuarioNullableRelationFilter = {
    is?: usuarioWhereInput | null
    isNot?: usuarioWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type loginCountOrderByAggregateInput = {
    login_id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    is_verified?: SortOrder
    provider?: SortOrder
    provider_id?: SortOrder
    profile_image?: SortOrder
    ativo?: SortOrder
  }

  export type loginAvgOrderByAggregateInput = {
    login_id?: SortOrder
  }

  export type loginMaxOrderByAggregateInput = {
    login_id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    is_verified?: SortOrder
    provider?: SortOrder
    provider_id?: SortOrder
    profile_image?: SortOrder
    ativo?: SortOrder
  }

  export type loginMinOrderByAggregateInput = {
    login_id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    is_verified?: SortOrder
    provider?: SortOrder
    provider_id?: SortOrder
    profile_image?: SortOrder
    ativo?: SortOrder
  }

  export type loginSumOrderByAggregateInput = {
    login_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type LoginRelationFilter = {
    is?: loginWhereInput
    isNot?: loginWhereInput
  }

  export type ProjetoUsuarioListRelationFilter = {
    every?: projetoUsuarioWhereInput
    some?: projetoUsuarioWhereInput
    none?: projetoUsuarioWhereInput
  }

  export type HabilidadeUsuarioListRelationFilter = {
    every?: habilidadeUsuarioWhereInput
    some?: habilidadeUsuarioWhereInput
    none?: habilidadeUsuarioWhereInput
  }

  export type PermissaoListRelationFilter = {
    every?: permissaoWhereInput
    some?: permissaoWhereInput
    none?: permissaoWhereInput
  }

  export type PermissaoProjetoListRelationFilter = {
    every?: permissaoProjetoWhereInput
    some?: permissaoProjetoWhereInput
    none?: permissaoProjetoWhereInput
  }

  export type ParticipacaoTarefaListRelationFilter = {
    every?: participacaoTarefaWhereInput
    some?: participacaoTarefaWhereInput
    none?: participacaoTarefaWhereInput
  }

  export type ComentarioListRelationFilter = {
    every?: comentarioWhereInput
    some?: comentarioWhereInput
    none?: comentarioWhereInput
  }

  export type projetoUsuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type habilidadeUsuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type permissaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type permissaoProjetoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type participacaoTarefaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type comentarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usuarioCountOrderByAggregateInput = {
    usuario_id?: SortOrder
    nome?: SortOrder
    created_at?: SortOrder
    roule?: SortOrder
    login_id?: SortOrder
  }

  export type usuarioAvgOrderByAggregateInput = {
    usuario_id?: SortOrder
    login_id?: SortOrder
  }

  export type usuarioMaxOrderByAggregateInput = {
    usuario_id?: SortOrder
    nome?: SortOrder
    created_at?: SortOrder
    roule?: SortOrder
    login_id?: SortOrder
  }

  export type usuarioMinOrderByAggregateInput = {
    usuario_id?: SortOrder
    nome?: SortOrder
    created_at?: SortOrder
    roule?: SortOrder
    login_id?: SortOrder
  }

  export type usuarioSumOrderByAggregateInput = {
    usuario_id?: SortOrder
    login_id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ProjetoTecnologiaListRelationFilter = {
    every?: projetoTecnologiaWhereInput
    some?: projetoTecnologiaWhereInput
    none?: projetoTecnologiaWhereInput
  }

  export type RecursoListRelationFilter = {
    every?: recursoWhereInput
    some?: recursoWhereInput
    none?: recursoWhereInput
  }

  export type AnexoProjetoListRelationFilter = {
    every?: anexoProjetoWhereInput
    some?: anexoProjetoWhereInput
    none?: anexoProjetoWhereInput
  }

  export type projetoTecnologiaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type recursoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type anexoProjetoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type projetoCountOrderByAggregateInput = {
    projeto_id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    created_at?: SortOrder
    conclude_at?: SortOrder
  }

  export type projetoAvgOrderByAggregateInput = {
    projeto_id?: SortOrder
  }

  export type projetoMaxOrderByAggregateInput = {
    projeto_id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    created_at?: SortOrder
    conclude_at?: SortOrder
  }

  export type projetoMinOrderByAggregateInput = {
    projeto_id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    created_at?: SortOrder
    conclude_at?: SortOrder
  }

  export type projetoSumOrderByAggregateInput = {
    projeto_id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type tecnologiaCountOrderByAggregateInput = {
    tecnologia_id?: SortOrder
    descricao?: SortOrder
  }

  export type tecnologiaAvgOrderByAggregateInput = {
    tecnologia_id?: SortOrder
  }

  export type tecnologiaMaxOrderByAggregateInput = {
    tecnologia_id?: SortOrder
    descricao?: SortOrder
  }

  export type tecnologiaMinOrderByAggregateInput = {
    tecnologia_id?: SortOrder
    descricao?: SortOrder
  }

  export type tecnologiaSumOrderByAggregateInput = {
    tecnologia_id?: SortOrder
  }

  export type AnexoTarefaListRelationFilter = {
    every?: anexoTarefaWhereInput
    some?: anexoTarefaWhereInput
    none?: anexoTarefaWhereInput
  }

  export type PausaTarefaListRelationFilter = {
    every?: pausaTarefaWhereInput
    some?: pausaTarefaWhereInput
    none?: pausaTarefaWhereInput
  }

  export type anexoTarefaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pausaTarefaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tarefaCountOrderByAggregateInput = {
    tarefa_id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
    doing?: SortOrder
    concludeAt?: SortOrder
    colorBar?: SortOrder
  }

  export type tarefaAvgOrderByAggregateInput = {
    tarefa_id?: SortOrder
  }

  export type tarefaMaxOrderByAggregateInput = {
    tarefa_id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
    doing?: SortOrder
    concludeAt?: SortOrder
    colorBar?: SortOrder
  }

  export type tarefaMinOrderByAggregateInput = {
    tarefa_id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    createdAt?: SortOrder
    doing?: SortOrder
    concludeAt?: SortOrder
    colorBar?: SortOrder
  }

  export type tarefaSumOrderByAggregateInput = {
    tarefa_id?: SortOrder
  }

  export type ProjetoRelationFilter = {
    is?: projetoWhereInput
    isNot?: projetoWhereInput
  }

  export type UsuarioRelationFilter = {
    is?: usuarioWhereInput
    isNot?: usuarioWhereInput
  }

  export type projetoUsuarioCountOrderByAggregateInput = {
    projetoUsuario_id?: SortOrder
    projeto_id?: SortOrder
    usuario_id?: SortOrder
    owner?: SortOrder
  }

  export type projetoUsuarioAvgOrderByAggregateInput = {
    projetoUsuario_id?: SortOrder
    projeto_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type projetoUsuarioMaxOrderByAggregateInput = {
    projetoUsuario_id?: SortOrder
    projeto_id?: SortOrder
    usuario_id?: SortOrder
    owner?: SortOrder
  }

  export type projetoUsuarioMinOrderByAggregateInput = {
    projetoUsuario_id?: SortOrder
    projeto_id?: SortOrder
    usuario_id?: SortOrder
    owner?: SortOrder
  }

  export type projetoUsuarioSumOrderByAggregateInput = {
    projetoUsuario_id?: SortOrder
    projeto_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type TecnologiaRelationFilter = {
    is?: tecnologiaWhereInput
    isNot?: tecnologiaWhereInput
  }

  export type projetoTecnologiaCountOrderByAggregateInput = {
    projetoTecnologia_id?: SortOrder
    tecnologia_id?: SortOrder
    projeto_id?: SortOrder
  }

  export type projetoTecnologiaAvgOrderByAggregateInput = {
    projetoTecnologia_id?: SortOrder
    tecnologia_id?: SortOrder
    projeto_id?: SortOrder
  }

  export type projetoTecnologiaMaxOrderByAggregateInput = {
    projetoTecnologia_id?: SortOrder
    tecnologia_id?: SortOrder
    projeto_id?: SortOrder
  }

  export type projetoTecnologiaMinOrderByAggregateInput = {
    projetoTecnologia_id?: SortOrder
    tecnologia_id?: SortOrder
    projeto_id?: SortOrder
  }

  export type projetoTecnologiaSumOrderByAggregateInput = {
    projetoTecnologia_id?: SortOrder
    tecnologia_id?: SortOrder
    projeto_id?: SortOrder
  }

  export type habilidadeUsuarioCountOrderByAggregateInput = {
    habilidadeUsuario_id?: SortOrder
    tecnologia_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type habilidadeUsuarioAvgOrderByAggregateInput = {
    habilidadeUsuario_id?: SortOrder
    tecnologia_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type habilidadeUsuarioMaxOrderByAggregateInput = {
    habilidadeUsuario_id?: SortOrder
    tecnologia_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type habilidadeUsuarioMinOrderByAggregateInput = {
    habilidadeUsuario_id?: SortOrder
    tecnologia_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type habilidadeUsuarioSumOrderByAggregateInput = {
    habilidadeUsuario_id?: SortOrder
    tecnologia_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type recursoCountOrderByAggregateInput = {
    recurso_id?: SortOrder
    descricao?: SortOrder
    projeto_id?: SortOrder
  }

  export type recursoAvgOrderByAggregateInput = {
    recurso_id?: SortOrder
    projeto_id?: SortOrder
  }

  export type recursoMaxOrderByAggregateInput = {
    recurso_id?: SortOrder
    descricao?: SortOrder
    projeto_id?: SortOrder
  }

  export type recursoMinOrderByAggregateInput = {
    recurso_id?: SortOrder
    descricao?: SortOrder
    projeto_id?: SortOrder
  }

  export type recursoSumOrderByAggregateInput = {
    recurso_id?: SortOrder
    projeto_id?: SortOrder
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type anexoProjetoCountOrderByAggregateInput = {
    anexo_id?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    conteudo?: SortOrder
    projeto_id?: SortOrder
    created_at?: SortOrder
  }

  export type anexoProjetoAvgOrderByAggregateInput = {
    anexo_id?: SortOrder
    projeto_id?: SortOrder
  }

  export type anexoProjetoMaxOrderByAggregateInput = {
    anexo_id?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    conteudo?: SortOrder
    projeto_id?: SortOrder
    created_at?: SortOrder
  }

  export type anexoProjetoMinOrderByAggregateInput = {
    anexo_id?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    conteudo?: SortOrder
    projeto_id?: SortOrder
    created_at?: SortOrder
  }

  export type anexoProjetoSumOrderByAggregateInput = {
    anexo_id?: SortOrder
    projeto_id?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type TarefaRelationFilter = {
    is?: tarefaWhereInput
    isNot?: tarefaWhereInput
  }

  export type ProjetoUsuarioRelationFilter = {
    is?: projetoUsuarioWhereInput
    isNot?: projetoUsuarioWhereInput
  }

  export type UsuarioListRelationFilter = {
    every?: usuarioWhereInput
    some?: usuarioWhereInput
    none?: usuarioWhereInput
  }

  export type usuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type participacaoTarefaCountOrderByAggregateInput = {
    participacaoTarefa_id?: SortOrder
    tarefa_id?: SortOrder
    projetoUsuario_id?: SortOrder
  }

  export type participacaoTarefaAvgOrderByAggregateInput = {
    participacaoTarefa_id?: SortOrder
    tarefa_id?: SortOrder
    projetoUsuario_id?: SortOrder
  }

  export type participacaoTarefaMaxOrderByAggregateInput = {
    participacaoTarefa_id?: SortOrder
    tarefa_id?: SortOrder
    projetoUsuario_id?: SortOrder
  }

  export type participacaoTarefaMinOrderByAggregateInput = {
    participacaoTarefa_id?: SortOrder
    tarefa_id?: SortOrder
    projetoUsuario_id?: SortOrder
  }

  export type participacaoTarefaSumOrderByAggregateInput = {
    participacaoTarefa_id?: SortOrder
    tarefa_id?: SortOrder
    projetoUsuario_id?: SortOrder
  }

  export type ParticipacaoTarefaRelationFilter = {
    is?: participacaoTarefaWhereInput
    isNot?: participacaoTarefaWhereInput
  }

  export type AnexoComentarioListRelationFilter = {
    every?: anexoComentarioWhereInput
    some?: anexoComentarioWhereInput
    none?: anexoComentarioWhereInput
  }

  export type anexoComentarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type comentarioCountOrderByAggregateInput = {
    comentario_id?: SortOrder
    comentario?: SortOrder
    data_hora?: SortOrder
    participacaoTarefa_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type comentarioAvgOrderByAggregateInput = {
    comentario_id?: SortOrder
    participacaoTarefa_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type comentarioMaxOrderByAggregateInput = {
    comentario_id?: SortOrder
    comentario?: SortOrder
    data_hora?: SortOrder
    participacaoTarefa_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type comentarioMinOrderByAggregateInput = {
    comentario_id?: SortOrder
    comentario?: SortOrder
    data_hora?: SortOrder
    participacaoTarefa_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type comentarioSumOrderByAggregateInput = {
    comentario_id?: SortOrder
    participacaoTarefa_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type anexoTarefaCountOrderByAggregateInput = {
    anexoTarefa_id?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    conteudo?: SortOrder
    created_at?: SortOrder
    tarefa_id?: SortOrder
  }

  export type anexoTarefaAvgOrderByAggregateInput = {
    anexoTarefa_id?: SortOrder
    tarefa_id?: SortOrder
  }

  export type anexoTarefaMaxOrderByAggregateInput = {
    anexoTarefa_id?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    conteudo?: SortOrder
    created_at?: SortOrder
    tarefa_id?: SortOrder
  }

  export type anexoTarefaMinOrderByAggregateInput = {
    anexoTarefa_id?: SortOrder
    nome?: SortOrder
    tipo?: SortOrder
    conteudo?: SortOrder
    created_at?: SortOrder
    tarefa_id?: SortOrder
  }

  export type anexoTarefaSumOrderByAggregateInput = {
    anexoTarefa_id?: SortOrder
    tarefa_id?: SortOrder
  }

  export type ComentarioRelationFilter = {
    is?: comentarioWhereInput
    isNot?: comentarioWhereInput
  }

  export type AnexoTarefaRelationFilter = {
    is?: anexoTarefaWhereInput
    isNot?: anexoTarefaWhereInput
  }

  export type anexoComentarioCountOrderByAggregateInput = {
    anexoComentario_id?: SortOrder
    comentario_id?: SortOrder
    anexoTarefa_id?: SortOrder
  }

  export type anexoComentarioAvgOrderByAggregateInput = {
    anexoComentario_id?: SortOrder
    comentario_id?: SortOrder
    anexoTarefa_id?: SortOrder
  }

  export type anexoComentarioMaxOrderByAggregateInput = {
    anexoComentario_id?: SortOrder
    comentario_id?: SortOrder
    anexoTarefa_id?: SortOrder
  }

  export type anexoComentarioMinOrderByAggregateInput = {
    anexoComentario_id?: SortOrder
    comentario_id?: SortOrder
    anexoTarefa_id?: SortOrder
  }

  export type anexoComentarioSumOrderByAggregateInput = {
    anexoComentario_id?: SortOrder
    comentario_id?: SortOrder
    anexoTarefa_id?: SortOrder
  }

  export type permissaoCountOrderByAggregateInput = {
    permissao_id?: SortOrder
    tipo?: SortOrder
    usuario_id?: SortOrder
  }

  export type permissaoAvgOrderByAggregateInput = {
    permissao_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type permissaoMaxOrderByAggregateInput = {
    permissao_id?: SortOrder
    tipo?: SortOrder
    usuario_id?: SortOrder
  }

  export type permissaoMinOrderByAggregateInput = {
    permissao_id?: SortOrder
    tipo?: SortOrder
    usuario_id?: SortOrder
  }

  export type permissaoSumOrderByAggregateInput = {
    permissao_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type permissaoProjetoCountOrderByAggregateInput = {
    permissaoProjeto_id?: SortOrder
    tipo?: SortOrder
    usuario_id?: SortOrder
    projeto_id?: SortOrder
  }

  export type permissaoProjetoAvgOrderByAggregateInput = {
    permissaoProjeto_id?: SortOrder
    usuario_id?: SortOrder
    projeto_id?: SortOrder
  }

  export type permissaoProjetoMaxOrderByAggregateInput = {
    permissaoProjeto_id?: SortOrder
    tipo?: SortOrder
    usuario_id?: SortOrder
    projeto_id?: SortOrder
  }

  export type permissaoProjetoMinOrderByAggregateInput = {
    permissaoProjeto_id?: SortOrder
    tipo?: SortOrder
    usuario_id?: SortOrder
    projeto_id?: SortOrder
  }

  export type permissaoProjetoSumOrderByAggregateInput = {
    permissaoProjeto_id?: SortOrder
    usuario_id?: SortOrder
    projeto_id?: SortOrder
  }

  export type pausaTarefaCountOrderByAggregateInput = {
    pausa_id?: SortOrder
    tarefa_id?: SortOrder
    inicioPausa?: SortOrder
    fimPausa?: SortOrder
  }

  export type pausaTarefaAvgOrderByAggregateInput = {
    pausa_id?: SortOrder
    tarefa_id?: SortOrder
  }

  export type pausaTarefaMaxOrderByAggregateInput = {
    pausa_id?: SortOrder
    tarefa_id?: SortOrder
    inicioPausa?: SortOrder
    fimPausa?: SortOrder
  }

  export type pausaTarefaMinOrderByAggregateInput = {
    pausa_id?: SortOrder
    tarefa_id?: SortOrder
    inicioPausa?: SortOrder
    fimPausa?: SortOrder
  }

  export type pausaTarefaSumOrderByAggregateInput = {
    pausa_id?: SortOrder
    tarefa_id?: SortOrder
  }

  export type usuarioCreateNestedOneWithoutLoginInput = {
    create?: XOR<usuarioCreateWithoutLoginInput, usuarioUncheckedCreateWithoutLoginInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutLoginInput
    connect?: usuarioWhereUniqueInput
  }

  export type usuarioUncheckedCreateNestedOneWithoutLoginInput = {
    create?: XOR<usuarioCreateWithoutLoginInput, usuarioUncheckedCreateWithoutLoginInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutLoginInput
    connect?: usuarioWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type usuarioUpdateOneWithoutLoginNestedInput = {
    create?: XOR<usuarioCreateWithoutLoginInput, usuarioUncheckedCreateWithoutLoginInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutLoginInput
    upsert?: usuarioUpsertWithoutLoginInput
    disconnect?: usuarioWhereInput | boolean
    delete?: usuarioWhereInput | boolean
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutLoginInput, usuarioUpdateWithoutLoginInput>, usuarioUncheckedUpdateWithoutLoginInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type usuarioUncheckedUpdateOneWithoutLoginNestedInput = {
    create?: XOR<usuarioCreateWithoutLoginInput, usuarioUncheckedCreateWithoutLoginInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutLoginInput
    upsert?: usuarioUpsertWithoutLoginInput
    disconnect?: usuarioWhereInput | boolean
    delete?: usuarioWhereInput | boolean
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutLoginInput, usuarioUpdateWithoutLoginInput>, usuarioUncheckedUpdateWithoutLoginInput>
  }

  export type loginCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<loginCreateWithoutUsuarioInput, loginUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: loginCreateOrConnectWithoutUsuarioInput
    connect?: loginWhereUniqueInput
  }

  export type projetoUsuarioCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<projetoUsuarioCreateWithoutUsuarioInput, projetoUsuarioUncheckedCreateWithoutUsuarioInput> | projetoUsuarioCreateWithoutUsuarioInput[] | projetoUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: projetoUsuarioCreateOrConnectWithoutUsuarioInput | projetoUsuarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: projetoUsuarioCreateManyUsuarioInputEnvelope
    connect?: projetoUsuarioWhereUniqueInput | projetoUsuarioWhereUniqueInput[]
  }

  export type habilidadeUsuarioCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<habilidadeUsuarioCreateWithoutUsuarioInput, habilidadeUsuarioUncheckedCreateWithoutUsuarioInput> | habilidadeUsuarioCreateWithoutUsuarioInput[] | habilidadeUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: habilidadeUsuarioCreateOrConnectWithoutUsuarioInput | habilidadeUsuarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: habilidadeUsuarioCreateManyUsuarioInputEnvelope
    connect?: habilidadeUsuarioWhereUniqueInput | habilidadeUsuarioWhereUniqueInput[]
  }

  export type permissaoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<permissaoCreateWithoutUsuarioInput, permissaoUncheckedCreateWithoutUsuarioInput> | permissaoCreateWithoutUsuarioInput[] | permissaoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: permissaoCreateOrConnectWithoutUsuarioInput | permissaoCreateOrConnectWithoutUsuarioInput[]
    createMany?: permissaoCreateManyUsuarioInputEnvelope
    connect?: permissaoWhereUniqueInput | permissaoWhereUniqueInput[]
  }

  export type permissaoProjetoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<permissaoProjetoCreateWithoutUsuarioInput, permissaoProjetoUncheckedCreateWithoutUsuarioInput> | permissaoProjetoCreateWithoutUsuarioInput[] | permissaoProjetoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: permissaoProjetoCreateOrConnectWithoutUsuarioInput | permissaoProjetoCreateOrConnectWithoutUsuarioInput[]
    createMany?: permissaoProjetoCreateManyUsuarioInputEnvelope
    connect?: permissaoProjetoWhereUniqueInput | permissaoProjetoWhereUniqueInput[]
  }

  export type participacaoTarefaCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<participacaoTarefaCreateWithoutUsuariosInput, participacaoTarefaUncheckedCreateWithoutUsuariosInput> | participacaoTarefaCreateWithoutUsuariosInput[] | participacaoTarefaUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: participacaoTarefaCreateOrConnectWithoutUsuariosInput | participacaoTarefaCreateOrConnectWithoutUsuariosInput[]
    connect?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
  }

  export type comentarioCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<comentarioCreateWithoutUsuarioInput, comentarioUncheckedCreateWithoutUsuarioInput> | comentarioCreateWithoutUsuarioInput[] | comentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: comentarioCreateOrConnectWithoutUsuarioInput | comentarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: comentarioCreateManyUsuarioInputEnvelope
    connect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
  }

  export type projetoUsuarioUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<projetoUsuarioCreateWithoutUsuarioInput, projetoUsuarioUncheckedCreateWithoutUsuarioInput> | projetoUsuarioCreateWithoutUsuarioInput[] | projetoUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: projetoUsuarioCreateOrConnectWithoutUsuarioInput | projetoUsuarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: projetoUsuarioCreateManyUsuarioInputEnvelope
    connect?: projetoUsuarioWhereUniqueInput | projetoUsuarioWhereUniqueInput[]
  }

  export type habilidadeUsuarioUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<habilidadeUsuarioCreateWithoutUsuarioInput, habilidadeUsuarioUncheckedCreateWithoutUsuarioInput> | habilidadeUsuarioCreateWithoutUsuarioInput[] | habilidadeUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: habilidadeUsuarioCreateOrConnectWithoutUsuarioInput | habilidadeUsuarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: habilidadeUsuarioCreateManyUsuarioInputEnvelope
    connect?: habilidadeUsuarioWhereUniqueInput | habilidadeUsuarioWhereUniqueInput[]
  }

  export type permissaoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<permissaoCreateWithoutUsuarioInput, permissaoUncheckedCreateWithoutUsuarioInput> | permissaoCreateWithoutUsuarioInput[] | permissaoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: permissaoCreateOrConnectWithoutUsuarioInput | permissaoCreateOrConnectWithoutUsuarioInput[]
    createMany?: permissaoCreateManyUsuarioInputEnvelope
    connect?: permissaoWhereUniqueInput | permissaoWhereUniqueInput[]
  }

  export type permissaoProjetoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<permissaoProjetoCreateWithoutUsuarioInput, permissaoProjetoUncheckedCreateWithoutUsuarioInput> | permissaoProjetoCreateWithoutUsuarioInput[] | permissaoProjetoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: permissaoProjetoCreateOrConnectWithoutUsuarioInput | permissaoProjetoCreateOrConnectWithoutUsuarioInput[]
    createMany?: permissaoProjetoCreateManyUsuarioInputEnvelope
    connect?: permissaoProjetoWhereUniqueInput | permissaoProjetoWhereUniqueInput[]
  }

  export type participacaoTarefaUncheckedCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<participacaoTarefaCreateWithoutUsuariosInput, participacaoTarefaUncheckedCreateWithoutUsuariosInput> | participacaoTarefaCreateWithoutUsuariosInput[] | participacaoTarefaUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: participacaoTarefaCreateOrConnectWithoutUsuariosInput | participacaoTarefaCreateOrConnectWithoutUsuariosInput[]
    connect?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
  }

  export type comentarioUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<comentarioCreateWithoutUsuarioInput, comentarioUncheckedCreateWithoutUsuarioInput> | comentarioCreateWithoutUsuarioInput[] | comentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: comentarioCreateOrConnectWithoutUsuarioInput | comentarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: comentarioCreateManyUsuarioInputEnvelope
    connect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type loginUpdateOneRequiredWithoutUsuarioNestedInput = {
    create?: XOR<loginCreateWithoutUsuarioInput, loginUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: loginCreateOrConnectWithoutUsuarioInput
    upsert?: loginUpsertWithoutUsuarioInput
    connect?: loginWhereUniqueInput
    update?: XOR<XOR<loginUpdateToOneWithWhereWithoutUsuarioInput, loginUpdateWithoutUsuarioInput>, loginUncheckedUpdateWithoutUsuarioInput>
  }

  export type projetoUsuarioUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<projetoUsuarioCreateWithoutUsuarioInput, projetoUsuarioUncheckedCreateWithoutUsuarioInput> | projetoUsuarioCreateWithoutUsuarioInput[] | projetoUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: projetoUsuarioCreateOrConnectWithoutUsuarioInput | projetoUsuarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: projetoUsuarioUpsertWithWhereUniqueWithoutUsuarioInput | projetoUsuarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: projetoUsuarioCreateManyUsuarioInputEnvelope
    set?: projetoUsuarioWhereUniqueInput | projetoUsuarioWhereUniqueInput[]
    disconnect?: projetoUsuarioWhereUniqueInput | projetoUsuarioWhereUniqueInput[]
    delete?: projetoUsuarioWhereUniqueInput | projetoUsuarioWhereUniqueInput[]
    connect?: projetoUsuarioWhereUniqueInput | projetoUsuarioWhereUniqueInput[]
    update?: projetoUsuarioUpdateWithWhereUniqueWithoutUsuarioInput | projetoUsuarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: projetoUsuarioUpdateManyWithWhereWithoutUsuarioInput | projetoUsuarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: projetoUsuarioScalarWhereInput | projetoUsuarioScalarWhereInput[]
  }

  export type habilidadeUsuarioUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<habilidadeUsuarioCreateWithoutUsuarioInput, habilidadeUsuarioUncheckedCreateWithoutUsuarioInput> | habilidadeUsuarioCreateWithoutUsuarioInput[] | habilidadeUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: habilidadeUsuarioCreateOrConnectWithoutUsuarioInput | habilidadeUsuarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: habilidadeUsuarioUpsertWithWhereUniqueWithoutUsuarioInput | habilidadeUsuarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: habilidadeUsuarioCreateManyUsuarioInputEnvelope
    set?: habilidadeUsuarioWhereUniqueInput | habilidadeUsuarioWhereUniqueInput[]
    disconnect?: habilidadeUsuarioWhereUniqueInput | habilidadeUsuarioWhereUniqueInput[]
    delete?: habilidadeUsuarioWhereUniqueInput | habilidadeUsuarioWhereUniqueInput[]
    connect?: habilidadeUsuarioWhereUniqueInput | habilidadeUsuarioWhereUniqueInput[]
    update?: habilidadeUsuarioUpdateWithWhereUniqueWithoutUsuarioInput | habilidadeUsuarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: habilidadeUsuarioUpdateManyWithWhereWithoutUsuarioInput | habilidadeUsuarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: habilidadeUsuarioScalarWhereInput | habilidadeUsuarioScalarWhereInput[]
  }

  export type permissaoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<permissaoCreateWithoutUsuarioInput, permissaoUncheckedCreateWithoutUsuarioInput> | permissaoCreateWithoutUsuarioInput[] | permissaoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: permissaoCreateOrConnectWithoutUsuarioInput | permissaoCreateOrConnectWithoutUsuarioInput[]
    upsert?: permissaoUpsertWithWhereUniqueWithoutUsuarioInput | permissaoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: permissaoCreateManyUsuarioInputEnvelope
    set?: permissaoWhereUniqueInput | permissaoWhereUniqueInput[]
    disconnect?: permissaoWhereUniqueInput | permissaoWhereUniqueInput[]
    delete?: permissaoWhereUniqueInput | permissaoWhereUniqueInput[]
    connect?: permissaoWhereUniqueInput | permissaoWhereUniqueInput[]
    update?: permissaoUpdateWithWhereUniqueWithoutUsuarioInput | permissaoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: permissaoUpdateManyWithWhereWithoutUsuarioInput | permissaoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: permissaoScalarWhereInput | permissaoScalarWhereInput[]
  }

  export type permissaoProjetoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<permissaoProjetoCreateWithoutUsuarioInput, permissaoProjetoUncheckedCreateWithoutUsuarioInput> | permissaoProjetoCreateWithoutUsuarioInput[] | permissaoProjetoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: permissaoProjetoCreateOrConnectWithoutUsuarioInput | permissaoProjetoCreateOrConnectWithoutUsuarioInput[]
    upsert?: permissaoProjetoUpsertWithWhereUniqueWithoutUsuarioInput | permissaoProjetoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: permissaoProjetoCreateManyUsuarioInputEnvelope
    set?: permissaoProjetoWhereUniqueInput | permissaoProjetoWhereUniqueInput[]
    disconnect?: permissaoProjetoWhereUniqueInput | permissaoProjetoWhereUniqueInput[]
    delete?: permissaoProjetoWhereUniqueInput | permissaoProjetoWhereUniqueInput[]
    connect?: permissaoProjetoWhereUniqueInput | permissaoProjetoWhereUniqueInput[]
    update?: permissaoProjetoUpdateWithWhereUniqueWithoutUsuarioInput | permissaoProjetoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: permissaoProjetoUpdateManyWithWhereWithoutUsuarioInput | permissaoProjetoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: permissaoProjetoScalarWhereInput | permissaoProjetoScalarWhereInput[]
  }

  export type participacaoTarefaUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<participacaoTarefaCreateWithoutUsuariosInput, participacaoTarefaUncheckedCreateWithoutUsuariosInput> | participacaoTarefaCreateWithoutUsuariosInput[] | participacaoTarefaUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: participacaoTarefaCreateOrConnectWithoutUsuariosInput | participacaoTarefaCreateOrConnectWithoutUsuariosInput[]
    upsert?: participacaoTarefaUpsertWithWhereUniqueWithoutUsuariosInput | participacaoTarefaUpsertWithWhereUniqueWithoutUsuariosInput[]
    set?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    disconnect?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    delete?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    connect?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    update?: participacaoTarefaUpdateWithWhereUniqueWithoutUsuariosInput | participacaoTarefaUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: participacaoTarefaUpdateManyWithWhereWithoutUsuariosInput | participacaoTarefaUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: participacaoTarefaScalarWhereInput | participacaoTarefaScalarWhereInput[]
  }

  export type comentarioUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<comentarioCreateWithoutUsuarioInput, comentarioUncheckedCreateWithoutUsuarioInput> | comentarioCreateWithoutUsuarioInput[] | comentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: comentarioCreateOrConnectWithoutUsuarioInput | comentarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: comentarioUpsertWithWhereUniqueWithoutUsuarioInput | comentarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: comentarioCreateManyUsuarioInputEnvelope
    set?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    disconnect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    delete?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    connect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    update?: comentarioUpdateWithWhereUniqueWithoutUsuarioInput | comentarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: comentarioUpdateManyWithWhereWithoutUsuarioInput | comentarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: comentarioScalarWhereInput | comentarioScalarWhereInput[]
  }

  export type projetoUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<projetoUsuarioCreateWithoutUsuarioInput, projetoUsuarioUncheckedCreateWithoutUsuarioInput> | projetoUsuarioCreateWithoutUsuarioInput[] | projetoUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: projetoUsuarioCreateOrConnectWithoutUsuarioInput | projetoUsuarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: projetoUsuarioUpsertWithWhereUniqueWithoutUsuarioInput | projetoUsuarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: projetoUsuarioCreateManyUsuarioInputEnvelope
    set?: projetoUsuarioWhereUniqueInput | projetoUsuarioWhereUniqueInput[]
    disconnect?: projetoUsuarioWhereUniqueInput | projetoUsuarioWhereUniqueInput[]
    delete?: projetoUsuarioWhereUniqueInput | projetoUsuarioWhereUniqueInput[]
    connect?: projetoUsuarioWhereUniqueInput | projetoUsuarioWhereUniqueInput[]
    update?: projetoUsuarioUpdateWithWhereUniqueWithoutUsuarioInput | projetoUsuarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: projetoUsuarioUpdateManyWithWhereWithoutUsuarioInput | projetoUsuarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: projetoUsuarioScalarWhereInput | projetoUsuarioScalarWhereInput[]
  }

  export type habilidadeUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<habilidadeUsuarioCreateWithoutUsuarioInput, habilidadeUsuarioUncheckedCreateWithoutUsuarioInput> | habilidadeUsuarioCreateWithoutUsuarioInput[] | habilidadeUsuarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: habilidadeUsuarioCreateOrConnectWithoutUsuarioInput | habilidadeUsuarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: habilidadeUsuarioUpsertWithWhereUniqueWithoutUsuarioInput | habilidadeUsuarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: habilidadeUsuarioCreateManyUsuarioInputEnvelope
    set?: habilidadeUsuarioWhereUniqueInput | habilidadeUsuarioWhereUniqueInput[]
    disconnect?: habilidadeUsuarioWhereUniqueInput | habilidadeUsuarioWhereUniqueInput[]
    delete?: habilidadeUsuarioWhereUniqueInput | habilidadeUsuarioWhereUniqueInput[]
    connect?: habilidadeUsuarioWhereUniqueInput | habilidadeUsuarioWhereUniqueInput[]
    update?: habilidadeUsuarioUpdateWithWhereUniqueWithoutUsuarioInput | habilidadeUsuarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: habilidadeUsuarioUpdateManyWithWhereWithoutUsuarioInput | habilidadeUsuarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: habilidadeUsuarioScalarWhereInput | habilidadeUsuarioScalarWhereInput[]
  }

  export type permissaoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<permissaoCreateWithoutUsuarioInput, permissaoUncheckedCreateWithoutUsuarioInput> | permissaoCreateWithoutUsuarioInput[] | permissaoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: permissaoCreateOrConnectWithoutUsuarioInput | permissaoCreateOrConnectWithoutUsuarioInput[]
    upsert?: permissaoUpsertWithWhereUniqueWithoutUsuarioInput | permissaoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: permissaoCreateManyUsuarioInputEnvelope
    set?: permissaoWhereUniqueInput | permissaoWhereUniqueInput[]
    disconnect?: permissaoWhereUniqueInput | permissaoWhereUniqueInput[]
    delete?: permissaoWhereUniqueInput | permissaoWhereUniqueInput[]
    connect?: permissaoWhereUniqueInput | permissaoWhereUniqueInput[]
    update?: permissaoUpdateWithWhereUniqueWithoutUsuarioInput | permissaoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: permissaoUpdateManyWithWhereWithoutUsuarioInput | permissaoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: permissaoScalarWhereInput | permissaoScalarWhereInput[]
  }

  export type permissaoProjetoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<permissaoProjetoCreateWithoutUsuarioInput, permissaoProjetoUncheckedCreateWithoutUsuarioInput> | permissaoProjetoCreateWithoutUsuarioInput[] | permissaoProjetoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: permissaoProjetoCreateOrConnectWithoutUsuarioInput | permissaoProjetoCreateOrConnectWithoutUsuarioInput[]
    upsert?: permissaoProjetoUpsertWithWhereUniqueWithoutUsuarioInput | permissaoProjetoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: permissaoProjetoCreateManyUsuarioInputEnvelope
    set?: permissaoProjetoWhereUniqueInput | permissaoProjetoWhereUniqueInput[]
    disconnect?: permissaoProjetoWhereUniqueInput | permissaoProjetoWhereUniqueInput[]
    delete?: permissaoProjetoWhereUniqueInput | permissaoProjetoWhereUniqueInput[]
    connect?: permissaoProjetoWhereUniqueInput | permissaoProjetoWhereUniqueInput[]
    update?: permissaoProjetoUpdateWithWhereUniqueWithoutUsuarioInput | permissaoProjetoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: permissaoProjetoUpdateManyWithWhereWithoutUsuarioInput | permissaoProjetoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: permissaoProjetoScalarWhereInput | permissaoProjetoScalarWhereInput[]
  }

  export type participacaoTarefaUncheckedUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<participacaoTarefaCreateWithoutUsuariosInput, participacaoTarefaUncheckedCreateWithoutUsuariosInput> | participacaoTarefaCreateWithoutUsuariosInput[] | participacaoTarefaUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: participacaoTarefaCreateOrConnectWithoutUsuariosInput | participacaoTarefaCreateOrConnectWithoutUsuariosInput[]
    upsert?: participacaoTarefaUpsertWithWhereUniqueWithoutUsuariosInput | participacaoTarefaUpsertWithWhereUniqueWithoutUsuariosInput[]
    set?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    disconnect?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    delete?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    connect?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    update?: participacaoTarefaUpdateWithWhereUniqueWithoutUsuariosInput | participacaoTarefaUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: participacaoTarefaUpdateManyWithWhereWithoutUsuariosInput | participacaoTarefaUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: participacaoTarefaScalarWhereInput | participacaoTarefaScalarWhereInput[]
  }

  export type comentarioUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<comentarioCreateWithoutUsuarioInput, comentarioUncheckedCreateWithoutUsuarioInput> | comentarioCreateWithoutUsuarioInput[] | comentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: comentarioCreateOrConnectWithoutUsuarioInput | comentarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: comentarioUpsertWithWhereUniqueWithoutUsuarioInput | comentarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: comentarioCreateManyUsuarioInputEnvelope
    set?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    disconnect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    delete?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    connect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    update?: comentarioUpdateWithWhereUniqueWithoutUsuarioInput | comentarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: comentarioUpdateManyWithWhereWithoutUsuarioInput | comentarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: comentarioScalarWhereInput | comentarioScalarWhereInput[]
  }

  export type projetoUsuarioCreateNestedManyWithoutProjetoInput = {
    create?: XOR<projetoUsuarioCreateWithoutProjetoInput, projetoUsuarioUncheckedCreateWithoutProjetoInput> | projetoUsuarioCreateWithoutProjetoInput[] | projetoUsuarioUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: projetoUsuarioCreateOrConnectWithoutProjetoInput | projetoUsuarioCreateOrConnectWithoutProjetoInput[]
    createMany?: projetoUsuarioCreateManyProjetoInputEnvelope
    connect?: projetoUsuarioWhereUniqueInput | projetoUsuarioWhereUniqueInput[]
  }

  export type projetoTecnologiaCreateNestedManyWithoutProjetoInput = {
    create?: XOR<projetoTecnologiaCreateWithoutProjetoInput, projetoTecnologiaUncheckedCreateWithoutProjetoInput> | projetoTecnologiaCreateWithoutProjetoInput[] | projetoTecnologiaUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: projetoTecnologiaCreateOrConnectWithoutProjetoInput | projetoTecnologiaCreateOrConnectWithoutProjetoInput[]
    createMany?: projetoTecnologiaCreateManyProjetoInputEnvelope
    connect?: projetoTecnologiaWhereUniqueInput | projetoTecnologiaWhereUniqueInput[]
  }

  export type recursoCreateNestedManyWithoutProjetoInput = {
    create?: XOR<recursoCreateWithoutProjetoInput, recursoUncheckedCreateWithoutProjetoInput> | recursoCreateWithoutProjetoInput[] | recursoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: recursoCreateOrConnectWithoutProjetoInput | recursoCreateOrConnectWithoutProjetoInput[]
    createMany?: recursoCreateManyProjetoInputEnvelope
    connect?: recursoWhereUniqueInput | recursoWhereUniqueInput[]
  }

  export type anexoProjetoCreateNestedManyWithoutProjetoInput = {
    create?: XOR<anexoProjetoCreateWithoutProjetoInput, anexoProjetoUncheckedCreateWithoutProjetoInput> | anexoProjetoCreateWithoutProjetoInput[] | anexoProjetoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: anexoProjetoCreateOrConnectWithoutProjetoInput | anexoProjetoCreateOrConnectWithoutProjetoInput[]
    createMany?: anexoProjetoCreateManyProjetoInputEnvelope
    connect?: anexoProjetoWhereUniqueInput | anexoProjetoWhereUniqueInput[]
  }

  export type permissaoProjetoCreateNestedManyWithoutProjetoInput = {
    create?: XOR<permissaoProjetoCreateWithoutProjetoInput, permissaoProjetoUncheckedCreateWithoutProjetoInput> | permissaoProjetoCreateWithoutProjetoInput[] | permissaoProjetoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: permissaoProjetoCreateOrConnectWithoutProjetoInput | permissaoProjetoCreateOrConnectWithoutProjetoInput[]
    createMany?: permissaoProjetoCreateManyProjetoInputEnvelope
    connect?: permissaoProjetoWhereUniqueInput | permissaoProjetoWhereUniqueInput[]
  }

  export type projetoUsuarioUncheckedCreateNestedManyWithoutProjetoInput = {
    create?: XOR<projetoUsuarioCreateWithoutProjetoInput, projetoUsuarioUncheckedCreateWithoutProjetoInput> | projetoUsuarioCreateWithoutProjetoInput[] | projetoUsuarioUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: projetoUsuarioCreateOrConnectWithoutProjetoInput | projetoUsuarioCreateOrConnectWithoutProjetoInput[]
    createMany?: projetoUsuarioCreateManyProjetoInputEnvelope
    connect?: projetoUsuarioWhereUniqueInput | projetoUsuarioWhereUniqueInput[]
  }

  export type projetoTecnologiaUncheckedCreateNestedManyWithoutProjetoInput = {
    create?: XOR<projetoTecnologiaCreateWithoutProjetoInput, projetoTecnologiaUncheckedCreateWithoutProjetoInput> | projetoTecnologiaCreateWithoutProjetoInput[] | projetoTecnologiaUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: projetoTecnologiaCreateOrConnectWithoutProjetoInput | projetoTecnologiaCreateOrConnectWithoutProjetoInput[]
    createMany?: projetoTecnologiaCreateManyProjetoInputEnvelope
    connect?: projetoTecnologiaWhereUniqueInput | projetoTecnologiaWhereUniqueInput[]
  }

  export type recursoUncheckedCreateNestedManyWithoutProjetoInput = {
    create?: XOR<recursoCreateWithoutProjetoInput, recursoUncheckedCreateWithoutProjetoInput> | recursoCreateWithoutProjetoInput[] | recursoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: recursoCreateOrConnectWithoutProjetoInput | recursoCreateOrConnectWithoutProjetoInput[]
    createMany?: recursoCreateManyProjetoInputEnvelope
    connect?: recursoWhereUniqueInput | recursoWhereUniqueInput[]
  }

  export type anexoProjetoUncheckedCreateNestedManyWithoutProjetoInput = {
    create?: XOR<anexoProjetoCreateWithoutProjetoInput, anexoProjetoUncheckedCreateWithoutProjetoInput> | anexoProjetoCreateWithoutProjetoInput[] | anexoProjetoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: anexoProjetoCreateOrConnectWithoutProjetoInput | anexoProjetoCreateOrConnectWithoutProjetoInput[]
    createMany?: anexoProjetoCreateManyProjetoInputEnvelope
    connect?: anexoProjetoWhereUniqueInput | anexoProjetoWhereUniqueInput[]
  }

  export type permissaoProjetoUncheckedCreateNestedManyWithoutProjetoInput = {
    create?: XOR<permissaoProjetoCreateWithoutProjetoInput, permissaoProjetoUncheckedCreateWithoutProjetoInput> | permissaoProjetoCreateWithoutProjetoInput[] | permissaoProjetoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: permissaoProjetoCreateOrConnectWithoutProjetoInput | permissaoProjetoCreateOrConnectWithoutProjetoInput[]
    createMany?: permissaoProjetoCreateManyProjetoInputEnvelope
    connect?: permissaoProjetoWhereUniqueInput | permissaoProjetoWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type projetoUsuarioUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<projetoUsuarioCreateWithoutProjetoInput, projetoUsuarioUncheckedCreateWithoutProjetoInput> | projetoUsuarioCreateWithoutProjetoInput[] | projetoUsuarioUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: projetoUsuarioCreateOrConnectWithoutProjetoInput | projetoUsuarioCreateOrConnectWithoutProjetoInput[]
    upsert?: projetoUsuarioUpsertWithWhereUniqueWithoutProjetoInput | projetoUsuarioUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: projetoUsuarioCreateManyProjetoInputEnvelope
    set?: projetoUsuarioWhereUniqueInput | projetoUsuarioWhereUniqueInput[]
    disconnect?: projetoUsuarioWhereUniqueInput | projetoUsuarioWhereUniqueInput[]
    delete?: projetoUsuarioWhereUniqueInput | projetoUsuarioWhereUniqueInput[]
    connect?: projetoUsuarioWhereUniqueInput | projetoUsuarioWhereUniqueInput[]
    update?: projetoUsuarioUpdateWithWhereUniqueWithoutProjetoInput | projetoUsuarioUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: projetoUsuarioUpdateManyWithWhereWithoutProjetoInput | projetoUsuarioUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: projetoUsuarioScalarWhereInput | projetoUsuarioScalarWhereInput[]
  }

  export type projetoTecnologiaUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<projetoTecnologiaCreateWithoutProjetoInput, projetoTecnologiaUncheckedCreateWithoutProjetoInput> | projetoTecnologiaCreateWithoutProjetoInput[] | projetoTecnologiaUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: projetoTecnologiaCreateOrConnectWithoutProjetoInput | projetoTecnologiaCreateOrConnectWithoutProjetoInput[]
    upsert?: projetoTecnologiaUpsertWithWhereUniqueWithoutProjetoInput | projetoTecnologiaUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: projetoTecnologiaCreateManyProjetoInputEnvelope
    set?: projetoTecnologiaWhereUniqueInput | projetoTecnologiaWhereUniqueInput[]
    disconnect?: projetoTecnologiaWhereUniqueInput | projetoTecnologiaWhereUniqueInput[]
    delete?: projetoTecnologiaWhereUniqueInput | projetoTecnologiaWhereUniqueInput[]
    connect?: projetoTecnologiaWhereUniqueInput | projetoTecnologiaWhereUniqueInput[]
    update?: projetoTecnologiaUpdateWithWhereUniqueWithoutProjetoInput | projetoTecnologiaUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: projetoTecnologiaUpdateManyWithWhereWithoutProjetoInput | projetoTecnologiaUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: projetoTecnologiaScalarWhereInput | projetoTecnologiaScalarWhereInput[]
  }

  export type recursoUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<recursoCreateWithoutProjetoInput, recursoUncheckedCreateWithoutProjetoInput> | recursoCreateWithoutProjetoInput[] | recursoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: recursoCreateOrConnectWithoutProjetoInput | recursoCreateOrConnectWithoutProjetoInput[]
    upsert?: recursoUpsertWithWhereUniqueWithoutProjetoInput | recursoUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: recursoCreateManyProjetoInputEnvelope
    set?: recursoWhereUniqueInput | recursoWhereUniqueInput[]
    disconnect?: recursoWhereUniqueInput | recursoWhereUniqueInput[]
    delete?: recursoWhereUniqueInput | recursoWhereUniqueInput[]
    connect?: recursoWhereUniqueInput | recursoWhereUniqueInput[]
    update?: recursoUpdateWithWhereUniqueWithoutProjetoInput | recursoUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: recursoUpdateManyWithWhereWithoutProjetoInput | recursoUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: recursoScalarWhereInput | recursoScalarWhereInput[]
  }

  export type anexoProjetoUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<anexoProjetoCreateWithoutProjetoInput, anexoProjetoUncheckedCreateWithoutProjetoInput> | anexoProjetoCreateWithoutProjetoInput[] | anexoProjetoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: anexoProjetoCreateOrConnectWithoutProjetoInput | anexoProjetoCreateOrConnectWithoutProjetoInput[]
    upsert?: anexoProjetoUpsertWithWhereUniqueWithoutProjetoInput | anexoProjetoUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: anexoProjetoCreateManyProjetoInputEnvelope
    set?: anexoProjetoWhereUniqueInput | anexoProjetoWhereUniqueInput[]
    disconnect?: anexoProjetoWhereUniqueInput | anexoProjetoWhereUniqueInput[]
    delete?: anexoProjetoWhereUniqueInput | anexoProjetoWhereUniqueInput[]
    connect?: anexoProjetoWhereUniqueInput | anexoProjetoWhereUniqueInput[]
    update?: anexoProjetoUpdateWithWhereUniqueWithoutProjetoInput | anexoProjetoUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: anexoProjetoUpdateManyWithWhereWithoutProjetoInput | anexoProjetoUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: anexoProjetoScalarWhereInput | anexoProjetoScalarWhereInput[]
  }

  export type permissaoProjetoUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<permissaoProjetoCreateWithoutProjetoInput, permissaoProjetoUncheckedCreateWithoutProjetoInput> | permissaoProjetoCreateWithoutProjetoInput[] | permissaoProjetoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: permissaoProjetoCreateOrConnectWithoutProjetoInput | permissaoProjetoCreateOrConnectWithoutProjetoInput[]
    upsert?: permissaoProjetoUpsertWithWhereUniqueWithoutProjetoInput | permissaoProjetoUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: permissaoProjetoCreateManyProjetoInputEnvelope
    set?: permissaoProjetoWhereUniqueInput | permissaoProjetoWhereUniqueInput[]
    disconnect?: permissaoProjetoWhereUniqueInput | permissaoProjetoWhereUniqueInput[]
    delete?: permissaoProjetoWhereUniqueInput | permissaoProjetoWhereUniqueInput[]
    connect?: permissaoProjetoWhereUniqueInput | permissaoProjetoWhereUniqueInput[]
    update?: permissaoProjetoUpdateWithWhereUniqueWithoutProjetoInput | permissaoProjetoUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: permissaoProjetoUpdateManyWithWhereWithoutProjetoInput | permissaoProjetoUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: permissaoProjetoScalarWhereInput | permissaoProjetoScalarWhereInput[]
  }

  export type projetoUsuarioUncheckedUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<projetoUsuarioCreateWithoutProjetoInput, projetoUsuarioUncheckedCreateWithoutProjetoInput> | projetoUsuarioCreateWithoutProjetoInput[] | projetoUsuarioUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: projetoUsuarioCreateOrConnectWithoutProjetoInput | projetoUsuarioCreateOrConnectWithoutProjetoInput[]
    upsert?: projetoUsuarioUpsertWithWhereUniqueWithoutProjetoInput | projetoUsuarioUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: projetoUsuarioCreateManyProjetoInputEnvelope
    set?: projetoUsuarioWhereUniqueInput | projetoUsuarioWhereUniqueInput[]
    disconnect?: projetoUsuarioWhereUniqueInput | projetoUsuarioWhereUniqueInput[]
    delete?: projetoUsuarioWhereUniqueInput | projetoUsuarioWhereUniqueInput[]
    connect?: projetoUsuarioWhereUniqueInput | projetoUsuarioWhereUniqueInput[]
    update?: projetoUsuarioUpdateWithWhereUniqueWithoutProjetoInput | projetoUsuarioUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: projetoUsuarioUpdateManyWithWhereWithoutProjetoInput | projetoUsuarioUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: projetoUsuarioScalarWhereInput | projetoUsuarioScalarWhereInput[]
  }

  export type projetoTecnologiaUncheckedUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<projetoTecnologiaCreateWithoutProjetoInput, projetoTecnologiaUncheckedCreateWithoutProjetoInput> | projetoTecnologiaCreateWithoutProjetoInput[] | projetoTecnologiaUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: projetoTecnologiaCreateOrConnectWithoutProjetoInput | projetoTecnologiaCreateOrConnectWithoutProjetoInput[]
    upsert?: projetoTecnologiaUpsertWithWhereUniqueWithoutProjetoInput | projetoTecnologiaUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: projetoTecnologiaCreateManyProjetoInputEnvelope
    set?: projetoTecnologiaWhereUniqueInput | projetoTecnologiaWhereUniqueInput[]
    disconnect?: projetoTecnologiaWhereUniqueInput | projetoTecnologiaWhereUniqueInput[]
    delete?: projetoTecnologiaWhereUniqueInput | projetoTecnologiaWhereUniqueInput[]
    connect?: projetoTecnologiaWhereUniqueInput | projetoTecnologiaWhereUniqueInput[]
    update?: projetoTecnologiaUpdateWithWhereUniqueWithoutProjetoInput | projetoTecnologiaUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: projetoTecnologiaUpdateManyWithWhereWithoutProjetoInput | projetoTecnologiaUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: projetoTecnologiaScalarWhereInput | projetoTecnologiaScalarWhereInput[]
  }

  export type recursoUncheckedUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<recursoCreateWithoutProjetoInput, recursoUncheckedCreateWithoutProjetoInput> | recursoCreateWithoutProjetoInput[] | recursoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: recursoCreateOrConnectWithoutProjetoInput | recursoCreateOrConnectWithoutProjetoInput[]
    upsert?: recursoUpsertWithWhereUniqueWithoutProjetoInput | recursoUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: recursoCreateManyProjetoInputEnvelope
    set?: recursoWhereUniqueInput | recursoWhereUniqueInput[]
    disconnect?: recursoWhereUniqueInput | recursoWhereUniqueInput[]
    delete?: recursoWhereUniqueInput | recursoWhereUniqueInput[]
    connect?: recursoWhereUniqueInput | recursoWhereUniqueInput[]
    update?: recursoUpdateWithWhereUniqueWithoutProjetoInput | recursoUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: recursoUpdateManyWithWhereWithoutProjetoInput | recursoUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: recursoScalarWhereInput | recursoScalarWhereInput[]
  }

  export type anexoProjetoUncheckedUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<anexoProjetoCreateWithoutProjetoInput, anexoProjetoUncheckedCreateWithoutProjetoInput> | anexoProjetoCreateWithoutProjetoInput[] | anexoProjetoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: anexoProjetoCreateOrConnectWithoutProjetoInput | anexoProjetoCreateOrConnectWithoutProjetoInput[]
    upsert?: anexoProjetoUpsertWithWhereUniqueWithoutProjetoInput | anexoProjetoUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: anexoProjetoCreateManyProjetoInputEnvelope
    set?: anexoProjetoWhereUniqueInput | anexoProjetoWhereUniqueInput[]
    disconnect?: anexoProjetoWhereUniqueInput | anexoProjetoWhereUniqueInput[]
    delete?: anexoProjetoWhereUniqueInput | anexoProjetoWhereUniqueInput[]
    connect?: anexoProjetoWhereUniqueInput | anexoProjetoWhereUniqueInput[]
    update?: anexoProjetoUpdateWithWhereUniqueWithoutProjetoInput | anexoProjetoUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: anexoProjetoUpdateManyWithWhereWithoutProjetoInput | anexoProjetoUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: anexoProjetoScalarWhereInput | anexoProjetoScalarWhereInput[]
  }

  export type permissaoProjetoUncheckedUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<permissaoProjetoCreateWithoutProjetoInput, permissaoProjetoUncheckedCreateWithoutProjetoInput> | permissaoProjetoCreateWithoutProjetoInput[] | permissaoProjetoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: permissaoProjetoCreateOrConnectWithoutProjetoInput | permissaoProjetoCreateOrConnectWithoutProjetoInput[]
    upsert?: permissaoProjetoUpsertWithWhereUniqueWithoutProjetoInput | permissaoProjetoUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: permissaoProjetoCreateManyProjetoInputEnvelope
    set?: permissaoProjetoWhereUniqueInput | permissaoProjetoWhereUniqueInput[]
    disconnect?: permissaoProjetoWhereUniqueInput | permissaoProjetoWhereUniqueInput[]
    delete?: permissaoProjetoWhereUniqueInput | permissaoProjetoWhereUniqueInput[]
    connect?: permissaoProjetoWhereUniqueInput | permissaoProjetoWhereUniqueInput[]
    update?: permissaoProjetoUpdateWithWhereUniqueWithoutProjetoInput | permissaoProjetoUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: permissaoProjetoUpdateManyWithWhereWithoutProjetoInput | permissaoProjetoUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: permissaoProjetoScalarWhereInput | permissaoProjetoScalarWhereInput[]
  }

  export type habilidadeUsuarioCreateNestedManyWithoutTecnologiaInput = {
    create?: XOR<habilidadeUsuarioCreateWithoutTecnologiaInput, habilidadeUsuarioUncheckedCreateWithoutTecnologiaInput> | habilidadeUsuarioCreateWithoutTecnologiaInput[] | habilidadeUsuarioUncheckedCreateWithoutTecnologiaInput[]
    connectOrCreate?: habilidadeUsuarioCreateOrConnectWithoutTecnologiaInput | habilidadeUsuarioCreateOrConnectWithoutTecnologiaInput[]
    createMany?: habilidadeUsuarioCreateManyTecnologiaInputEnvelope
    connect?: habilidadeUsuarioWhereUniqueInput | habilidadeUsuarioWhereUniqueInput[]
  }

  export type projetoTecnologiaCreateNestedManyWithoutTecnologiaInput = {
    create?: XOR<projetoTecnologiaCreateWithoutTecnologiaInput, projetoTecnologiaUncheckedCreateWithoutTecnologiaInput> | projetoTecnologiaCreateWithoutTecnologiaInput[] | projetoTecnologiaUncheckedCreateWithoutTecnologiaInput[]
    connectOrCreate?: projetoTecnologiaCreateOrConnectWithoutTecnologiaInput | projetoTecnologiaCreateOrConnectWithoutTecnologiaInput[]
    createMany?: projetoTecnologiaCreateManyTecnologiaInputEnvelope
    connect?: projetoTecnologiaWhereUniqueInput | projetoTecnologiaWhereUniqueInput[]
  }

  export type habilidadeUsuarioUncheckedCreateNestedManyWithoutTecnologiaInput = {
    create?: XOR<habilidadeUsuarioCreateWithoutTecnologiaInput, habilidadeUsuarioUncheckedCreateWithoutTecnologiaInput> | habilidadeUsuarioCreateWithoutTecnologiaInput[] | habilidadeUsuarioUncheckedCreateWithoutTecnologiaInput[]
    connectOrCreate?: habilidadeUsuarioCreateOrConnectWithoutTecnologiaInput | habilidadeUsuarioCreateOrConnectWithoutTecnologiaInput[]
    createMany?: habilidadeUsuarioCreateManyTecnologiaInputEnvelope
    connect?: habilidadeUsuarioWhereUniqueInput | habilidadeUsuarioWhereUniqueInput[]
  }

  export type projetoTecnologiaUncheckedCreateNestedManyWithoutTecnologiaInput = {
    create?: XOR<projetoTecnologiaCreateWithoutTecnologiaInput, projetoTecnologiaUncheckedCreateWithoutTecnologiaInput> | projetoTecnologiaCreateWithoutTecnologiaInput[] | projetoTecnologiaUncheckedCreateWithoutTecnologiaInput[]
    connectOrCreate?: projetoTecnologiaCreateOrConnectWithoutTecnologiaInput | projetoTecnologiaCreateOrConnectWithoutTecnologiaInput[]
    createMany?: projetoTecnologiaCreateManyTecnologiaInputEnvelope
    connect?: projetoTecnologiaWhereUniqueInput | projetoTecnologiaWhereUniqueInput[]
  }

  export type habilidadeUsuarioUpdateManyWithoutTecnologiaNestedInput = {
    create?: XOR<habilidadeUsuarioCreateWithoutTecnologiaInput, habilidadeUsuarioUncheckedCreateWithoutTecnologiaInput> | habilidadeUsuarioCreateWithoutTecnologiaInput[] | habilidadeUsuarioUncheckedCreateWithoutTecnologiaInput[]
    connectOrCreate?: habilidadeUsuarioCreateOrConnectWithoutTecnologiaInput | habilidadeUsuarioCreateOrConnectWithoutTecnologiaInput[]
    upsert?: habilidadeUsuarioUpsertWithWhereUniqueWithoutTecnologiaInput | habilidadeUsuarioUpsertWithWhereUniqueWithoutTecnologiaInput[]
    createMany?: habilidadeUsuarioCreateManyTecnologiaInputEnvelope
    set?: habilidadeUsuarioWhereUniqueInput | habilidadeUsuarioWhereUniqueInput[]
    disconnect?: habilidadeUsuarioWhereUniqueInput | habilidadeUsuarioWhereUniqueInput[]
    delete?: habilidadeUsuarioWhereUniqueInput | habilidadeUsuarioWhereUniqueInput[]
    connect?: habilidadeUsuarioWhereUniqueInput | habilidadeUsuarioWhereUniqueInput[]
    update?: habilidadeUsuarioUpdateWithWhereUniqueWithoutTecnologiaInput | habilidadeUsuarioUpdateWithWhereUniqueWithoutTecnologiaInput[]
    updateMany?: habilidadeUsuarioUpdateManyWithWhereWithoutTecnologiaInput | habilidadeUsuarioUpdateManyWithWhereWithoutTecnologiaInput[]
    deleteMany?: habilidadeUsuarioScalarWhereInput | habilidadeUsuarioScalarWhereInput[]
  }

  export type projetoTecnologiaUpdateManyWithoutTecnologiaNestedInput = {
    create?: XOR<projetoTecnologiaCreateWithoutTecnologiaInput, projetoTecnologiaUncheckedCreateWithoutTecnologiaInput> | projetoTecnologiaCreateWithoutTecnologiaInput[] | projetoTecnologiaUncheckedCreateWithoutTecnologiaInput[]
    connectOrCreate?: projetoTecnologiaCreateOrConnectWithoutTecnologiaInput | projetoTecnologiaCreateOrConnectWithoutTecnologiaInput[]
    upsert?: projetoTecnologiaUpsertWithWhereUniqueWithoutTecnologiaInput | projetoTecnologiaUpsertWithWhereUniqueWithoutTecnologiaInput[]
    createMany?: projetoTecnologiaCreateManyTecnologiaInputEnvelope
    set?: projetoTecnologiaWhereUniqueInput | projetoTecnologiaWhereUniqueInput[]
    disconnect?: projetoTecnologiaWhereUniqueInput | projetoTecnologiaWhereUniqueInput[]
    delete?: projetoTecnologiaWhereUniqueInput | projetoTecnologiaWhereUniqueInput[]
    connect?: projetoTecnologiaWhereUniqueInput | projetoTecnologiaWhereUniqueInput[]
    update?: projetoTecnologiaUpdateWithWhereUniqueWithoutTecnologiaInput | projetoTecnologiaUpdateWithWhereUniqueWithoutTecnologiaInput[]
    updateMany?: projetoTecnologiaUpdateManyWithWhereWithoutTecnologiaInput | projetoTecnologiaUpdateManyWithWhereWithoutTecnologiaInput[]
    deleteMany?: projetoTecnologiaScalarWhereInput | projetoTecnologiaScalarWhereInput[]
  }

  export type habilidadeUsuarioUncheckedUpdateManyWithoutTecnologiaNestedInput = {
    create?: XOR<habilidadeUsuarioCreateWithoutTecnologiaInput, habilidadeUsuarioUncheckedCreateWithoutTecnologiaInput> | habilidadeUsuarioCreateWithoutTecnologiaInput[] | habilidadeUsuarioUncheckedCreateWithoutTecnologiaInput[]
    connectOrCreate?: habilidadeUsuarioCreateOrConnectWithoutTecnologiaInput | habilidadeUsuarioCreateOrConnectWithoutTecnologiaInput[]
    upsert?: habilidadeUsuarioUpsertWithWhereUniqueWithoutTecnologiaInput | habilidadeUsuarioUpsertWithWhereUniqueWithoutTecnologiaInput[]
    createMany?: habilidadeUsuarioCreateManyTecnologiaInputEnvelope
    set?: habilidadeUsuarioWhereUniqueInput | habilidadeUsuarioWhereUniqueInput[]
    disconnect?: habilidadeUsuarioWhereUniqueInput | habilidadeUsuarioWhereUniqueInput[]
    delete?: habilidadeUsuarioWhereUniqueInput | habilidadeUsuarioWhereUniqueInput[]
    connect?: habilidadeUsuarioWhereUniqueInput | habilidadeUsuarioWhereUniqueInput[]
    update?: habilidadeUsuarioUpdateWithWhereUniqueWithoutTecnologiaInput | habilidadeUsuarioUpdateWithWhereUniqueWithoutTecnologiaInput[]
    updateMany?: habilidadeUsuarioUpdateManyWithWhereWithoutTecnologiaInput | habilidadeUsuarioUpdateManyWithWhereWithoutTecnologiaInput[]
    deleteMany?: habilidadeUsuarioScalarWhereInput | habilidadeUsuarioScalarWhereInput[]
  }

  export type projetoTecnologiaUncheckedUpdateManyWithoutTecnologiaNestedInput = {
    create?: XOR<projetoTecnologiaCreateWithoutTecnologiaInput, projetoTecnologiaUncheckedCreateWithoutTecnologiaInput> | projetoTecnologiaCreateWithoutTecnologiaInput[] | projetoTecnologiaUncheckedCreateWithoutTecnologiaInput[]
    connectOrCreate?: projetoTecnologiaCreateOrConnectWithoutTecnologiaInput | projetoTecnologiaCreateOrConnectWithoutTecnologiaInput[]
    upsert?: projetoTecnologiaUpsertWithWhereUniqueWithoutTecnologiaInput | projetoTecnologiaUpsertWithWhereUniqueWithoutTecnologiaInput[]
    createMany?: projetoTecnologiaCreateManyTecnologiaInputEnvelope
    set?: projetoTecnologiaWhereUniqueInput | projetoTecnologiaWhereUniqueInput[]
    disconnect?: projetoTecnologiaWhereUniqueInput | projetoTecnologiaWhereUniqueInput[]
    delete?: projetoTecnologiaWhereUniqueInput | projetoTecnologiaWhereUniqueInput[]
    connect?: projetoTecnologiaWhereUniqueInput | projetoTecnologiaWhereUniqueInput[]
    update?: projetoTecnologiaUpdateWithWhereUniqueWithoutTecnologiaInput | projetoTecnologiaUpdateWithWhereUniqueWithoutTecnologiaInput[]
    updateMany?: projetoTecnologiaUpdateManyWithWhereWithoutTecnologiaInput | projetoTecnologiaUpdateManyWithWhereWithoutTecnologiaInput[]
    deleteMany?: projetoTecnologiaScalarWhereInput | projetoTecnologiaScalarWhereInput[]
  }

  export type participacaoTarefaCreateNestedManyWithoutTarefaInput = {
    create?: XOR<participacaoTarefaCreateWithoutTarefaInput, participacaoTarefaUncheckedCreateWithoutTarefaInput> | participacaoTarefaCreateWithoutTarefaInput[] | participacaoTarefaUncheckedCreateWithoutTarefaInput[]
    connectOrCreate?: participacaoTarefaCreateOrConnectWithoutTarefaInput | participacaoTarefaCreateOrConnectWithoutTarefaInput[]
    createMany?: participacaoTarefaCreateManyTarefaInputEnvelope
    connect?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
  }

  export type anexoTarefaCreateNestedManyWithoutTarefaInput = {
    create?: XOR<anexoTarefaCreateWithoutTarefaInput, anexoTarefaUncheckedCreateWithoutTarefaInput> | anexoTarefaCreateWithoutTarefaInput[] | anexoTarefaUncheckedCreateWithoutTarefaInput[]
    connectOrCreate?: anexoTarefaCreateOrConnectWithoutTarefaInput | anexoTarefaCreateOrConnectWithoutTarefaInput[]
    createMany?: anexoTarefaCreateManyTarefaInputEnvelope
    connect?: anexoTarefaWhereUniqueInput | anexoTarefaWhereUniqueInput[]
  }

  export type pausaTarefaCreateNestedManyWithoutTarefaInput = {
    create?: XOR<pausaTarefaCreateWithoutTarefaInput, pausaTarefaUncheckedCreateWithoutTarefaInput> | pausaTarefaCreateWithoutTarefaInput[] | pausaTarefaUncheckedCreateWithoutTarefaInput[]
    connectOrCreate?: pausaTarefaCreateOrConnectWithoutTarefaInput | pausaTarefaCreateOrConnectWithoutTarefaInput[]
    createMany?: pausaTarefaCreateManyTarefaInputEnvelope
    connect?: pausaTarefaWhereUniqueInput | pausaTarefaWhereUniqueInput[]
  }

  export type participacaoTarefaUncheckedCreateNestedManyWithoutTarefaInput = {
    create?: XOR<participacaoTarefaCreateWithoutTarefaInput, participacaoTarefaUncheckedCreateWithoutTarefaInput> | participacaoTarefaCreateWithoutTarefaInput[] | participacaoTarefaUncheckedCreateWithoutTarefaInput[]
    connectOrCreate?: participacaoTarefaCreateOrConnectWithoutTarefaInput | participacaoTarefaCreateOrConnectWithoutTarefaInput[]
    createMany?: participacaoTarefaCreateManyTarefaInputEnvelope
    connect?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
  }

  export type anexoTarefaUncheckedCreateNestedManyWithoutTarefaInput = {
    create?: XOR<anexoTarefaCreateWithoutTarefaInput, anexoTarefaUncheckedCreateWithoutTarefaInput> | anexoTarefaCreateWithoutTarefaInput[] | anexoTarefaUncheckedCreateWithoutTarefaInput[]
    connectOrCreate?: anexoTarefaCreateOrConnectWithoutTarefaInput | anexoTarefaCreateOrConnectWithoutTarefaInput[]
    createMany?: anexoTarefaCreateManyTarefaInputEnvelope
    connect?: anexoTarefaWhereUniqueInput | anexoTarefaWhereUniqueInput[]
  }

  export type pausaTarefaUncheckedCreateNestedManyWithoutTarefaInput = {
    create?: XOR<pausaTarefaCreateWithoutTarefaInput, pausaTarefaUncheckedCreateWithoutTarefaInput> | pausaTarefaCreateWithoutTarefaInput[] | pausaTarefaUncheckedCreateWithoutTarefaInput[]
    connectOrCreate?: pausaTarefaCreateOrConnectWithoutTarefaInput | pausaTarefaCreateOrConnectWithoutTarefaInput[]
    createMany?: pausaTarefaCreateManyTarefaInputEnvelope
    connect?: pausaTarefaWhereUniqueInput | pausaTarefaWhereUniqueInput[]
  }

  export type participacaoTarefaUpdateManyWithoutTarefaNestedInput = {
    create?: XOR<participacaoTarefaCreateWithoutTarefaInput, participacaoTarefaUncheckedCreateWithoutTarefaInput> | participacaoTarefaCreateWithoutTarefaInput[] | participacaoTarefaUncheckedCreateWithoutTarefaInput[]
    connectOrCreate?: participacaoTarefaCreateOrConnectWithoutTarefaInput | participacaoTarefaCreateOrConnectWithoutTarefaInput[]
    upsert?: participacaoTarefaUpsertWithWhereUniqueWithoutTarefaInput | participacaoTarefaUpsertWithWhereUniqueWithoutTarefaInput[]
    createMany?: participacaoTarefaCreateManyTarefaInputEnvelope
    set?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    disconnect?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    delete?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    connect?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    update?: participacaoTarefaUpdateWithWhereUniqueWithoutTarefaInput | participacaoTarefaUpdateWithWhereUniqueWithoutTarefaInput[]
    updateMany?: participacaoTarefaUpdateManyWithWhereWithoutTarefaInput | participacaoTarefaUpdateManyWithWhereWithoutTarefaInput[]
    deleteMany?: participacaoTarefaScalarWhereInput | participacaoTarefaScalarWhereInput[]
  }

  export type anexoTarefaUpdateManyWithoutTarefaNestedInput = {
    create?: XOR<anexoTarefaCreateWithoutTarefaInput, anexoTarefaUncheckedCreateWithoutTarefaInput> | anexoTarefaCreateWithoutTarefaInput[] | anexoTarefaUncheckedCreateWithoutTarefaInput[]
    connectOrCreate?: anexoTarefaCreateOrConnectWithoutTarefaInput | anexoTarefaCreateOrConnectWithoutTarefaInput[]
    upsert?: anexoTarefaUpsertWithWhereUniqueWithoutTarefaInput | anexoTarefaUpsertWithWhereUniqueWithoutTarefaInput[]
    createMany?: anexoTarefaCreateManyTarefaInputEnvelope
    set?: anexoTarefaWhereUniqueInput | anexoTarefaWhereUniqueInput[]
    disconnect?: anexoTarefaWhereUniqueInput | anexoTarefaWhereUniqueInput[]
    delete?: anexoTarefaWhereUniqueInput | anexoTarefaWhereUniqueInput[]
    connect?: anexoTarefaWhereUniqueInput | anexoTarefaWhereUniqueInput[]
    update?: anexoTarefaUpdateWithWhereUniqueWithoutTarefaInput | anexoTarefaUpdateWithWhereUniqueWithoutTarefaInput[]
    updateMany?: anexoTarefaUpdateManyWithWhereWithoutTarefaInput | anexoTarefaUpdateManyWithWhereWithoutTarefaInput[]
    deleteMany?: anexoTarefaScalarWhereInput | anexoTarefaScalarWhereInput[]
  }

  export type pausaTarefaUpdateManyWithoutTarefaNestedInput = {
    create?: XOR<pausaTarefaCreateWithoutTarefaInput, pausaTarefaUncheckedCreateWithoutTarefaInput> | pausaTarefaCreateWithoutTarefaInput[] | pausaTarefaUncheckedCreateWithoutTarefaInput[]
    connectOrCreate?: pausaTarefaCreateOrConnectWithoutTarefaInput | pausaTarefaCreateOrConnectWithoutTarefaInput[]
    upsert?: pausaTarefaUpsertWithWhereUniqueWithoutTarefaInput | pausaTarefaUpsertWithWhereUniqueWithoutTarefaInput[]
    createMany?: pausaTarefaCreateManyTarefaInputEnvelope
    set?: pausaTarefaWhereUniqueInput | pausaTarefaWhereUniqueInput[]
    disconnect?: pausaTarefaWhereUniqueInput | pausaTarefaWhereUniqueInput[]
    delete?: pausaTarefaWhereUniqueInput | pausaTarefaWhereUniqueInput[]
    connect?: pausaTarefaWhereUniqueInput | pausaTarefaWhereUniqueInput[]
    update?: pausaTarefaUpdateWithWhereUniqueWithoutTarefaInput | pausaTarefaUpdateWithWhereUniqueWithoutTarefaInput[]
    updateMany?: pausaTarefaUpdateManyWithWhereWithoutTarefaInput | pausaTarefaUpdateManyWithWhereWithoutTarefaInput[]
    deleteMany?: pausaTarefaScalarWhereInput | pausaTarefaScalarWhereInput[]
  }

  export type participacaoTarefaUncheckedUpdateManyWithoutTarefaNestedInput = {
    create?: XOR<participacaoTarefaCreateWithoutTarefaInput, participacaoTarefaUncheckedCreateWithoutTarefaInput> | participacaoTarefaCreateWithoutTarefaInput[] | participacaoTarefaUncheckedCreateWithoutTarefaInput[]
    connectOrCreate?: participacaoTarefaCreateOrConnectWithoutTarefaInput | participacaoTarefaCreateOrConnectWithoutTarefaInput[]
    upsert?: participacaoTarefaUpsertWithWhereUniqueWithoutTarefaInput | participacaoTarefaUpsertWithWhereUniqueWithoutTarefaInput[]
    createMany?: participacaoTarefaCreateManyTarefaInputEnvelope
    set?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    disconnect?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    delete?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    connect?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    update?: participacaoTarefaUpdateWithWhereUniqueWithoutTarefaInput | participacaoTarefaUpdateWithWhereUniqueWithoutTarefaInput[]
    updateMany?: participacaoTarefaUpdateManyWithWhereWithoutTarefaInput | participacaoTarefaUpdateManyWithWhereWithoutTarefaInput[]
    deleteMany?: participacaoTarefaScalarWhereInput | participacaoTarefaScalarWhereInput[]
  }

  export type anexoTarefaUncheckedUpdateManyWithoutTarefaNestedInput = {
    create?: XOR<anexoTarefaCreateWithoutTarefaInput, anexoTarefaUncheckedCreateWithoutTarefaInput> | anexoTarefaCreateWithoutTarefaInput[] | anexoTarefaUncheckedCreateWithoutTarefaInput[]
    connectOrCreate?: anexoTarefaCreateOrConnectWithoutTarefaInput | anexoTarefaCreateOrConnectWithoutTarefaInput[]
    upsert?: anexoTarefaUpsertWithWhereUniqueWithoutTarefaInput | anexoTarefaUpsertWithWhereUniqueWithoutTarefaInput[]
    createMany?: anexoTarefaCreateManyTarefaInputEnvelope
    set?: anexoTarefaWhereUniqueInput | anexoTarefaWhereUniqueInput[]
    disconnect?: anexoTarefaWhereUniqueInput | anexoTarefaWhereUniqueInput[]
    delete?: anexoTarefaWhereUniqueInput | anexoTarefaWhereUniqueInput[]
    connect?: anexoTarefaWhereUniqueInput | anexoTarefaWhereUniqueInput[]
    update?: anexoTarefaUpdateWithWhereUniqueWithoutTarefaInput | anexoTarefaUpdateWithWhereUniqueWithoutTarefaInput[]
    updateMany?: anexoTarefaUpdateManyWithWhereWithoutTarefaInput | anexoTarefaUpdateManyWithWhereWithoutTarefaInput[]
    deleteMany?: anexoTarefaScalarWhereInput | anexoTarefaScalarWhereInput[]
  }

  export type pausaTarefaUncheckedUpdateManyWithoutTarefaNestedInput = {
    create?: XOR<pausaTarefaCreateWithoutTarefaInput, pausaTarefaUncheckedCreateWithoutTarefaInput> | pausaTarefaCreateWithoutTarefaInput[] | pausaTarefaUncheckedCreateWithoutTarefaInput[]
    connectOrCreate?: pausaTarefaCreateOrConnectWithoutTarefaInput | pausaTarefaCreateOrConnectWithoutTarefaInput[]
    upsert?: pausaTarefaUpsertWithWhereUniqueWithoutTarefaInput | pausaTarefaUpsertWithWhereUniqueWithoutTarefaInput[]
    createMany?: pausaTarefaCreateManyTarefaInputEnvelope
    set?: pausaTarefaWhereUniqueInput | pausaTarefaWhereUniqueInput[]
    disconnect?: pausaTarefaWhereUniqueInput | pausaTarefaWhereUniqueInput[]
    delete?: pausaTarefaWhereUniqueInput | pausaTarefaWhereUniqueInput[]
    connect?: pausaTarefaWhereUniqueInput | pausaTarefaWhereUniqueInput[]
    update?: pausaTarefaUpdateWithWhereUniqueWithoutTarefaInput | pausaTarefaUpdateWithWhereUniqueWithoutTarefaInput[]
    updateMany?: pausaTarefaUpdateManyWithWhereWithoutTarefaInput | pausaTarefaUpdateManyWithWhereWithoutTarefaInput[]
    deleteMany?: pausaTarefaScalarWhereInput | pausaTarefaScalarWhereInput[]
  }

  export type projetoCreateNestedOneWithoutProjetoUsuariosInput = {
    create?: XOR<projetoCreateWithoutProjetoUsuariosInput, projetoUncheckedCreateWithoutProjetoUsuariosInput>
    connectOrCreate?: projetoCreateOrConnectWithoutProjetoUsuariosInput
    connect?: projetoWhereUniqueInput
  }

  export type usuarioCreateNestedOneWithoutProjetoUsuariosInput = {
    create?: XOR<usuarioCreateWithoutProjetoUsuariosInput, usuarioUncheckedCreateWithoutProjetoUsuariosInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutProjetoUsuariosInput
    connect?: usuarioWhereUniqueInput
  }

  export type participacaoTarefaCreateNestedManyWithoutProjetoUsuarioInput = {
    create?: XOR<participacaoTarefaCreateWithoutProjetoUsuarioInput, participacaoTarefaUncheckedCreateWithoutProjetoUsuarioInput> | participacaoTarefaCreateWithoutProjetoUsuarioInput[] | participacaoTarefaUncheckedCreateWithoutProjetoUsuarioInput[]
    connectOrCreate?: participacaoTarefaCreateOrConnectWithoutProjetoUsuarioInput | participacaoTarefaCreateOrConnectWithoutProjetoUsuarioInput[]
    createMany?: participacaoTarefaCreateManyProjetoUsuarioInputEnvelope
    connect?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
  }

  export type participacaoTarefaUncheckedCreateNestedManyWithoutProjetoUsuarioInput = {
    create?: XOR<participacaoTarefaCreateWithoutProjetoUsuarioInput, participacaoTarefaUncheckedCreateWithoutProjetoUsuarioInput> | participacaoTarefaCreateWithoutProjetoUsuarioInput[] | participacaoTarefaUncheckedCreateWithoutProjetoUsuarioInput[]
    connectOrCreate?: participacaoTarefaCreateOrConnectWithoutProjetoUsuarioInput | participacaoTarefaCreateOrConnectWithoutProjetoUsuarioInput[]
    createMany?: participacaoTarefaCreateManyProjetoUsuarioInputEnvelope
    connect?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
  }

  export type projetoUpdateOneRequiredWithoutProjetoUsuariosNestedInput = {
    create?: XOR<projetoCreateWithoutProjetoUsuariosInput, projetoUncheckedCreateWithoutProjetoUsuariosInput>
    connectOrCreate?: projetoCreateOrConnectWithoutProjetoUsuariosInput
    upsert?: projetoUpsertWithoutProjetoUsuariosInput
    connect?: projetoWhereUniqueInput
    update?: XOR<XOR<projetoUpdateToOneWithWhereWithoutProjetoUsuariosInput, projetoUpdateWithoutProjetoUsuariosInput>, projetoUncheckedUpdateWithoutProjetoUsuariosInput>
  }

  export type usuarioUpdateOneRequiredWithoutProjetoUsuariosNestedInput = {
    create?: XOR<usuarioCreateWithoutProjetoUsuariosInput, usuarioUncheckedCreateWithoutProjetoUsuariosInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutProjetoUsuariosInput
    upsert?: usuarioUpsertWithoutProjetoUsuariosInput
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutProjetoUsuariosInput, usuarioUpdateWithoutProjetoUsuariosInput>, usuarioUncheckedUpdateWithoutProjetoUsuariosInput>
  }

  export type participacaoTarefaUpdateManyWithoutProjetoUsuarioNestedInput = {
    create?: XOR<participacaoTarefaCreateWithoutProjetoUsuarioInput, participacaoTarefaUncheckedCreateWithoutProjetoUsuarioInput> | participacaoTarefaCreateWithoutProjetoUsuarioInput[] | participacaoTarefaUncheckedCreateWithoutProjetoUsuarioInput[]
    connectOrCreate?: participacaoTarefaCreateOrConnectWithoutProjetoUsuarioInput | participacaoTarefaCreateOrConnectWithoutProjetoUsuarioInput[]
    upsert?: participacaoTarefaUpsertWithWhereUniqueWithoutProjetoUsuarioInput | participacaoTarefaUpsertWithWhereUniqueWithoutProjetoUsuarioInput[]
    createMany?: participacaoTarefaCreateManyProjetoUsuarioInputEnvelope
    set?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    disconnect?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    delete?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    connect?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    update?: participacaoTarefaUpdateWithWhereUniqueWithoutProjetoUsuarioInput | participacaoTarefaUpdateWithWhereUniqueWithoutProjetoUsuarioInput[]
    updateMany?: participacaoTarefaUpdateManyWithWhereWithoutProjetoUsuarioInput | participacaoTarefaUpdateManyWithWhereWithoutProjetoUsuarioInput[]
    deleteMany?: participacaoTarefaScalarWhereInput | participacaoTarefaScalarWhereInput[]
  }

  export type participacaoTarefaUncheckedUpdateManyWithoutProjetoUsuarioNestedInput = {
    create?: XOR<participacaoTarefaCreateWithoutProjetoUsuarioInput, participacaoTarefaUncheckedCreateWithoutProjetoUsuarioInput> | participacaoTarefaCreateWithoutProjetoUsuarioInput[] | participacaoTarefaUncheckedCreateWithoutProjetoUsuarioInput[]
    connectOrCreate?: participacaoTarefaCreateOrConnectWithoutProjetoUsuarioInput | participacaoTarefaCreateOrConnectWithoutProjetoUsuarioInput[]
    upsert?: participacaoTarefaUpsertWithWhereUniqueWithoutProjetoUsuarioInput | participacaoTarefaUpsertWithWhereUniqueWithoutProjetoUsuarioInput[]
    createMany?: participacaoTarefaCreateManyProjetoUsuarioInputEnvelope
    set?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    disconnect?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    delete?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    connect?: participacaoTarefaWhereUniqueInput | participacaoTarefaWhereUniqueInput[]
    update?: participacaoTarefaUpdateWithWhereUniqueWithoutProjetoUsuarioInput | participacaoTarefaUpdateWithWhereUniqueWithoutProjetoUsuarioInput[]
    updateMany?: participacaoTarefaUpdateManyWithWhereWithoutProjetoUsuarioInput | participacaoTarefaUpdateManyWithWhereWithoutProjetoUsuarioInput[]
    deleteMany?: participacaoTarefaScalarWhereInput | participacaoTarefaScalarWhereInput[]
  }

  export type projetoCreateNestedOneWithoutTecnologiasInput = {
    create?: XOR<projetoCreateWithoutTecnologiasInput, projetoUncheckedCreateWithoutTecnologiasInput>
    connectOrCreate?: projetoCreateOrConnectWithoutTecnologiasInput
    connect?: projetoWhereUniqueInput
  }

  export type tecnologiaCreateNestedOneWithoutProjetosInput = {
    create?: XOR<tecnologiaCreateWithoutProjetosInput, tecnologiaUncheckedCreateWithoutProjetosInput>
    connectOrCreate?: tecnologiaCreateOrConnectWithoutProjetosInput
    connect?: tecnologiaWhereUniqueInput
  }

  export type projetoUpdateOneRequiredWithoutTecnologiasNestedInput = {
    create?: XOR<projetoCreateWithoutTecnologiasInput, projetoUncheckedCreateWithoutTecnologiasInput>
    connectOrCreate?: projetoCreateOrConnectWithoutTecnologiasInput
    upsert?: projetoUpsertWithoutTecnologiasInput
    connect?: projetoWhereUniqueInput
    update?: XOR<XOR<projetoUpdateToOneWithWhereWithoutTecnologiasInput, projetoUpdateWithoutTecnologiasInput>, projetoUncheckedUpdateWithoutTecnologiasInput>
  }

  export type tecnologiaUpdateOneRequiredWithoutProjetosNestedInput = {
    create?: XOR<tecnologiaCreateWithoutProjetosInput, tecnologiaUncheckedCreateWithoutProjetosInput>
    connectOrCreate?: tecnologiaCreateOrConnectWithoutProjetosInput
    upsert?: tecnologiaUpsertWithoutProjetosInput
    connect?: tecnologiaWhereUniqueInput
    update?: XOR<XOR<tecnologiaUpdateToOneWithWhereWithoutProjetosInput, tecnologiaUpdateWithoutProjetosInput>, tecnologiaUncheckedUpdateWithoutProjetosInput>
  }

  export type usuarioCreateNestedOneWithoutHabilidadesInput = {
    create?: XOR<usuarioCreateWithoutHabilidadesInput, usuarioUncheckedCreateWithoutHabilidadesInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutHabilidadesInput
    connect?: usuarioWhereUniqueInput
  }

  export type tecnologiaCreateNestedOneWithoutHabilidadesInput = {
    create?: XOR<tecnologiaCreateWithoutHabilidadesInput, tecnologiaUncheckedCreateWithoutHabilidadesInput>
    connectOrCreate?: tecnologiaCreateOrConnectWithoutHabilidadesInput
    connect?: tecnologiaWhereUniqueInput
  }

  export type usuarioUpdateOneRequiredWithoutHabilidadesNestedInput = {
    create?: XOR<usuarioCreateWithoutHabilidadesInput, usuarioUncheckedCreateWithoutHabilidadesInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutHabilidadesInput
    upsert?: usuarioUpsertWithoutHabilidadesInput
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutHabilidadesInput, usuarioUpdateWithoutHabilidadesInput>, usuarioUncheckedUpdateWithoutHabilidadesInput>
  }

  export type tecnologiaUpdateOneRequiredWithoutHabilidadesNestedInput = {
    create?: XOR<tecnologiaCreateWithoutHabilidadesInput, tecnologiaUncheckedCreateWithoutHabilidadesInput>
    connectOrCreate?: tecnologiaCreateOrConnectWithoutHabilidadesInput
    upsert?: tecnologiaUpsertWithoutHabilidadesInput
    connect?: tecnologiaWhereUniqueInput
    update?: XOR<XOR<tecnologiaUpdateToOneWithWhereWithoutHabilidadesInput, tecnologiaUpdateWithoutHabilidadesInput>, tecnologiaUncheckedUpdateWithoutHabilidadesInput>
  }

  export type projetoCreateNestedOneWithoutRecursosInput = {
    create?: XOR<projetoCreateWithoutRecursosInput, projetoUncheckedCreateWithoutRecursosInput>
    connectOrCreate?: projetoCreateOrConnectWithoutRecursosInput
    connect?: projetoWhereUniqueInput
  }

  export type projetoUpdateOneRequiredWithoutRecursosNestedInput = {
    create?: XOR<projetoCreateWithoutRecursosInput, projetoUncheckedCreateWithoutRecursosInput>
    connectOrCreate?: projetoCreateOrConnectWithoutRecursosInput
    upsert?: projetoUpsertWithoutRecursosInput
    connect?: projetoWhereUniqueInput
    update?: XOR<XOR<projetoUpdateToOneWithWhereWithoutRecursosInput, projetoUpdateWithoutRecursosInput>, projetoUncheckedUpdateWithoutRecursosInput>
  }

  export type projetoCreateNestedOneWithoutAnexosInput = {
    create?: XOR<projetoCreateWithoutAnexosInput, projetoUncheckedCreateWithoutAnexosInput>
    connectOrCreate?: projetoCreateOrConnectWithoutAnexosInput
    connect?: projetoWhereUniqueInput
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type projetoUpdateOneRequiredWithoutAnexosNestedInput = {
    create?: XOR<projetoCreateWithoutAnexosInput, projetoUncheckedCreateWithoutAnexosInput>
    connectOrCreate?: projetoCreateOrConnectWithoutAnexosInput
    upsert?: projetoUpsertWithoutAnexosInput
    connect?: projetoWhereUniqueInput
    update?: XOR<XOR<projetoUpdateToOneWithWhereWithoutAnexosInput, projetoUpdateWithoutAnexosInput>, projetoUncheckedUpdateWithoutAnexosInput>
  }

  export type tarefaCreateNestedOneWithoutParticipacoesInput = {
    create?: XOR<tarefaCreateWithoutParticipacoesInput, tarefaUncheckedCreateWithoutParticipacoesInput>
    connectOrCreate?: tarefaCreateOrConnectWithoutParticipacoesInput
    connect?: tarefaWhereUniqueInput
  }

  export type projetoUsuarioCreateNestedOneWithoutParticipacoesInput = {
    create?: XOR<projetoUsuarioCreateWithoutParticipacoesInput, projetoUsuarioUncheckedCreateWithoutParticipacoesInput>
    connectOrCreate?: projetoUsuarioCreateOrConnectWithoutParticipacoesInput
    connect?: projetoUsuarioWhereUniqueInput
  }

  export type comentarioCreateNestedManyWithoutParticipacaoTarefaInput = {
    create?: XOR<comentarioCreateWithoutParticipacaoTarefaInput, comentarioUncheckedCreateWithoutParticipacaoTarefaInput> | comentarioCreateWithoutParticipacaoTarefaInput[] | comentarioUncheckedCreateWithoutParticipacaoTarefaInput[]
    connectOrCreate?: comentarioCreateOrConnectWithoutParticipacaoTarefaInput | comentarioCreateOrConnectWithoutParticipacaoTarefaInput[]
    createMany?: comentarioCreateManyParticipacaoTarefaInputEnvelope
    connect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
  }

  export type usuarioCreateNestedManyWithoutParticipacoesInput = {
    create?: XOR<usuarioCreateWithoutParticipacoesInput, usuarioUncheckedCreateWithoutParticipacoesInput> | usuarioCreateWithoutParticipacoesInput[] | usuarioUncheckedCreateWithoutParticipacoesInput[]
    connectOrCreate?: usuarioCreateOrConnectWithoutParticipacoesInput | usuarioCreateOrConnectWithoutParticipacoesInput[]
    connect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
  }

  export type comentarioUncheckedCreateNestedManyWithoutParticipacaoTarefaInput = {
    create?: XOR<comentarioCreateWithoutParticipacaoTarefaInput, comentarioUncheckedCreateWithoutParticipacaoTarefaInput> | comentarioCreateWithoutParticipacaoTarefaInput[] | comentarioUncheckedCreateWithoutParticipacaoTarefaInput[]
    connectOrCreate?: comentarioCreateOrConnectWithoutParticipacaoTarefaInput | comentarioCreateOrConnectWithoutParticipacaoTarefaInput[]
    createMany?: comentarioCreateManyParticipacaoTarefaInputEnvelope
    connect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
  }

  export type usuarioUncheckedCreateNestedManyWithoutParticipacoesInput = {
    create?: XOR<usuarioCreateWithoutParticipacoesInput, usuarioUncheckedCreateWithoutParticipacoesInput> | usuarioCreateWithoutParticipacoesInput[] | usuarioUncheckedCreateWithoutParticipacoesInput[]
    connectOrCreate?: usuarioCreateOrConnectWithoutParticipacoesInput | usuarioCreateOrConnectWithoutParticipacoesInput[]
    connect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
  }

  export type tarefaUpdateOneRequiredWithoutParticipacoesNestedInput = {
    create?: XOR<tarefaCreateWithoutParticipacoesInput, tarefaUncheckedCreateWithoutParticipacoesInput>
    connectOrCreate?: tarefaCreateOrConnectWithoutParticipacoesInput
    upsert?: tarefaUpsertWithoutParticipacoesInput
    connect?: tarefaWhereUniqueInput
    update?: XOR<XOR<tarefaUpdateToOneWithWhereWithoutParticipacoesInput, tarefaUpdateWithoutParticipacoesInput>, tarefaUncheckedUpdateWithoutParticipacoesInput>
  }

  export type projetoUsuarioUpdateOneRequiredWithoutParticipacoesNestedInput = {
    create?: XOR<projetoUsuarioCreateWithoutParticipacoesInput, projetoUsuarioUncheckedCreateWithoutParticipacoesInput>
    connectOrCreate?: projetoUsuarioCreateOrConnectWithoutParticipacoesInput
    upsert?: projetoUsuarioUpsertWithoutParticipacoesInput
    connect?: projetoUsuarioWhereUniqueInput
    update?: XOR<XOR<projetoUsuarioUpdateToOneWithWhereWithoutParticipacoesInput, projetoUsuarioUpdateWithoutParticipacoesInput>, projetoUsuarioUncheckedUpdateWithoutParticipacoesInput>
  }

  export type comentarioUpdateManyWithoutParticipacaoTarefaNestedInput = {
    create?: XOR<comentarioCreateWithoutParticipacaoTarefaInput, comentarioUncheckedCreateWithoutParticipacaoTarefaInput> | comentarioCreateWithoutParticipacaoTarefaInput[] | comentarioUncheckedCreateWithoutParticipacaoTarefaInput[]
    connectOrCreate?: comentarioCreateOrConnectWithoutParticipacaoTarefaInput | comentarioCreateOrConnectWithoutParticipacaoTarefaInput[]
    upsert?: comentarioUpsertWithWhereUniqueWithoutParticipacaoTarefaInput | comentarioUpsertWithWhereUniqueWithoutParticipacaoTarefaInput[]
    createMany?: comentarioCreateManyParticipacaoTarefaInputEnvelope
    set?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    disconnect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    delete?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    connect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    update?: comentarioUpdateWithWhereUniqueWithoutParticipacaoTarefaInput | comentarioUpdateWithWhereUniqueWithoutParticipacaoTarefaInput[]
    updateMany?: comentarioUpdateManyWithWhereWithoutParticipacaoTarefaInput | comentarioUpdateManyWithWhereWithoutParticipacaoTarefaInput[]
    deleteMany?: comentarioScalarWhereInput | comentarioScalarWhereInput[]
  }

  export type usuarioUpdateManyWithoutParticipacoesNestedInput = {
    create?: XOR<usuarioCreateWithoutParticipacoesInput, usuarioUncheckedCreateWithoutParticipacoesInput> | usuarioCreateWithoutParticipacoesInput[] | usuarioUncheckedCreateWithoutParticipacoesInput[]
    connectOrCreate?: usuarioCreateOrConnectWithoutParticipacoesInput | usuarioCreateOrConnectWithoutParticipacoesInput[]
    upsert?: usuarioUpsertWithWhereUniqueWithoutParticipacoesInput | usuarioUpsertWithWhereUniqueWithoutParticipacoesInput[]
    set?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    disconnect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    delete?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    connect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    update?: usuarioUpdateWithWhereUniqueWithoutParticipacoesInput | usuarioUpdateWithWhereUniqueWithoutParticipacoesInput[]
    updateMany?: usuarioUpdateManyWithWhereWithoutParticipacoesInput | usuarioUpdateManyWithWhereWithoutParticipacoesInput[]
    deleteMany?: usuarioScalarWhereInput | usuarioScalarWhereInput[]
  }

  export type comentarioUncheckedUpdateManyWithoutParticipacaoTarefaNestedInput = {
    create?: XOR<comentarioCreateWithoutParticipacaoTarefaInput, comentarioUncheckedCreateWithoutParticipacaoTarefaInput> | comentarioCreateWithoutParticipacaoTarefaInput[] | comentarioUncheckedCreateWithoutParticipacaoTarefaInput[]
    connectOrCreate?: comentarioCreateOrConnectWithoutParticipacaoTarefaInput | comentarioCreateOrConnectWithoutParticipacaoTarefaInput[]
    upsert?: comentarioUpsertWithWhereUniqueWithoutParticipacaoTarefaInput | comentarioUpsertWithWhereUniqueWithoutParticipacaoTarefaInput[]
    createMany?: comentarioCreateManyParticipacaoTarefaInputEnvelope
    set?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    disconnect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    delete?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    connect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    update?: comentarioUpdateWithWhereUniqueWithoutParticipacaoTarefaInput | comentarioUpdateWithWhereUniqueWithoutParticipacaoTarefaInput[]
    updateMany?: comentarioUpdateManyWithWhereWithoutParticipacaoTarefaInput | comentarioUpdateManyWithWhereWithoutParticipacaoTarefaInput[]
    deleteMany?: comentarioScalarWhereInput | comentarioScalarWhereInput[]
  }

  export type usuarioUncheckedUpdateManyWithoutParticipacoesNestedInput = {
    create?: XOR<usuarioCreateWithoutParticipacoesInput, usuarioUncheckedCreateWithoutParticipacoesInput> | usuarioCreateWithoutParticipacoesInput[] | usuarioUncheckedCreateWithoutParticipacoesInput[]
    connectOrCreate?: usuarioCreateOrConnectWithoutParticipacoesInput | usuarioCreateOrConnectWithoutParticipacoesInput[]
    upsert?: usuarioUpsertWithWhereUniqueWithoutParticipacoesInput | usuarioUpsertWithWhereUniqueWithoutParticipacoesInput[]
    set?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    disconnect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    delete?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    connect?: usuarioWhereUniqueInput | usuarioWhereUniqueInput[]
    update?: usuarioUpdateWithWhereUniqueWithoutParticipacoesInput | usuarioUpdateWithWhereUniqueWithoutParticipacoesInput[]
    updateMany?: usuarioUpdateManyWithWhereWithoutParticipacoesInput | usuarioUpdateManyWithWhereWithoutParticipacoesInput[]
    deleteMany?: usuarioScalarWhereInput | usuarioScalarWhereInput[]
  }

  export type participacaoTarefaCreateNestedOneWithoutComentariosInput = {
    create?: XOR<participacaoTarefaCreateWithoutComentariosInput, participacaoTarefaUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: participacaoTarefaCreateOrConnectWithoutComentariosInput
    connect?: participacaoTarefaWhereUniqueInput
  }

  export type usuarioCreateNestedOneWithoutComentariosInput = {
    create?: XOR<usuarioCreateWithoutComentariosInput, usuarioUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutComentariosInput
    connect?: usuarioWhereUniqueInput
  }

  export type anexoComentarioCreateNestedManyWithoutComentarioInput = {
    create?: XOR<anexoComentarioCreateWithoutComentarioInput, anexoComentarioUncheckedCreateWithoutComentarioInput> | anexoComentarioCreateWithoutComentarioInput[] | anexoComentarioUncheckedCreateWithoutComentarioInput[]
    connectOrCreate?: anexoComentarioCreateOrConnectWithoutComentarioInput | anexoComentarioCreateOrConnectWithoutComentarioInput[]
    createMany?: anexoComentarioCreateManyComentarioInputEnvelope
    connect?: anexoComentarioWhereUniqueInput | anexoComentarioWhereUniqueInput[]
  }

  export type anexoComentarioUncheckedCreateNestedManyWithoutComentarioInput = {
    create?: XOR<anexoComentarioCreateWithoutComentarioInput, anexoComentarioUncheckedCreateWithoutComentarioInput> | anexoComentarioCreateWithoutComentarioInput[] | anexoComentarioUncheckedCreateWithoutComentarioInput[]
    connectOrCreate?: anexoComentarioCreateOrConnectWithoutComentarioInput | anexoComentarioCreateOrConnectWithoutComentarioInput[]
    createMany?: anexoComentarioCreateManyComentarioInputEnvelope
    connect?: anexoComentarioWhereUniqueInput | anexoComentarioWhereUniqueInput[]
  }

  export type participacaoTarefaUpdateOneRequiredWithoutComentariosNestedInput = {
    create?: XOR<participacaoTarefaCreateWithoutComentariosInput, participacaoTarefaUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: participacaoTarefaCreateOrConnectWithoutComentariosInput
    upsert?: participacaoTarefaUpsertWithoutComentariosInput
    connect?: participacaoTarefaWhereUniqueInput
    update?: XOR<XOR<participacaoTarefaUpdateToOneWithWhereWithoutComentariosInput, participacaoTarefaUpdateWithoutComentariosInput>, participacaoTarefaUncheckedUpdateWithoutComentariosInput>
  }

  export type usuarioUpdateOneRequiredWithoutComentariosNestedInput = {
    create?: XOR<usuarioCreateWithoutComentariosInput, usuarioUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutComentariosInput
    upsert?: usuarioUpsertWithoutComentariosInput
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutComentariosInput, usuarioUpdateWithoutComentariosInput>, usuarioUncheckedUpdateWithoutComentariosInput>
  }

  export type anexoComentarioUpdateManyWithoutComentarioNestedInput = {
    create?: XOR<anexoComentarioCreateWithoutComentarioInput, anexoComentarioUncheckedCreateWithoutComentarioInput> | anexoComentarioCreateWithoutComentarioInput[] | anexoComentarioUncheckedCreateWithoutComentarioInput[]
    connectOrCreate?: anexoComentarioCreateOrConnectWithoutComentarioInput | anexoComentarioCreateOrConnectWithoutComentarioInput[]
    upsert?: anexoComentarioUpsertWithWhereUniqueWithoutComentarioInput | anexoComentarioUpsertWithWhereUniqueWithoutComentarioInput[]
    createMany?: anexoComentarioCreateManyComentarioInputEnvelope
    set?: anexoComentarioWhereUniqueInput | anexoComentarioWhereUniqueInput[]
    disconnect?: anexoComentarioWhereUniqueInput | anexoComentarioWhereUniqueInput[]
    delete?: anexoComentarioWhereUniqueInput | anexoComentarioWhereUniqueInput[]
    connect?: anexoComentarioWhereUniqueInput | anexoComentarioWhereUniqueInput[]
    update?: anexoComentarioUpdateWithWhereUniqueWithoutComentarioInput | anexoComentarioUpdateWithWhereUniqueWithoutComentarioInput[]
    updateMany?: anexoComentarioUpdateManyWithWhereWithoutComentarioInput | anexoComentarioUpdateManyWithWhereWithoutComentarioInput[]
    deleteMany?: anexoComentarioScalarWhereInput | anexoComentarioScalarWhereInput[]
  }

  export type anexoComentarioUncheckedUpdateManyWithoutComentarioNestedInput = {
    create?: XOR<anexoComentarioCreateWithoutComentarioInput, anexoComentarioUncheckedCreateWithoutComentarioInput> | anexoComentarioCreateWithoutComentarioInput[] | anexoComentarioUncheckedCreateWithoutComentarioInput[]
    connectOrCreate?: anexoComentarioCreateOrConnectWithoutComentarioInput | anexoComentarioCreateOrConnectWithoutComentarioInput[]
    upsert?: anexoComentarioUpsertWithWhereUniqueWithoutComentarioInput | anexoComentarioUpsertWithWhereUniqueWithoutComentarioInput[]
    createMany?: anexoComentarioCreateManyComentarioInputEnvelope
    set?: anexoComentarioWhereUniqueInput | anexoComentarioWhereUniqueInput[]
    disconnect?: anexoComentarioWhereUniqueInput | anexoComentarioWhereUniqueInput[]
    delete?: anexoComentarioWhereUniqueInput | anexoComentarioWhereUniqueInput[]
    connect?: anexoComentarioWhereUniqueInput | anexoComentarioWhereUniqueInput[]
    update?: anexoComentarioUpdateWithWhereUniqueWithoutComentarioInput | anexoComentarioUpdateWithWhereUniqueWithoutComentarioInput[]
    updateMany?: anexoComentarioUpdateManyWithWhereWithoutComentarioInput | anexoComentarioUpdateManyWithWhereWithoutComentarioInput[]
    deleteMany?: anexoComentarioScalarWhereInput | anexoComentarioScalarWhereInput[]
  }

  export type tarefaCreateNestedOneWithoutAnexosInput = {
    create?: XOR<tarefaCreateWithoutAnexosInput, tarefaUncheckedCreateWithoutAnexosInput>
    connectOrCreate?: tarefaCreateOrConnectWithoutAnexosInput
    connect?: tarefaWhereUniqueInput
  }

  export type anexoComentarioCreateNestedManyWithoutAnexoTarefaInput = {
    create?: XOR<anexoComentarioCreateWithoutAnexoTarefaInput, anexoComentarioUncheckedCreateWithoutAnexoTarefaInput> | anexoComentarioCreateWithoutAnexoTarefaInput[] | anexoComentarioUncheckedCreateWithoutAnexoTarefaInput[]
    connectOrCreate?: anexoComentarioCreateOrConnectWithoutAnexoTarefaInput | anexoComentarioCreateOrConnectWithoutAnexoTarefaInput[]
    createMany?: anexoComentarioCreateManyAnexoTarefaInputEnvelope
    connect?: anexoComentarioWhereUniqueInput | anexoComentarioWhereUniqueInput[]
  }

  export type anexoComentarioUncheckedCreateNestedManyWithoutAnexoTarefaInput = {
    create?: XOR<anexoComentarioCreateWithoutAnexoTarefaInput, anexoComentarioUncheckedCreateWithoutAnexoTarefaInput> | anexoComentarioCreateWithoutAnexoTarefaInput[] | anexoComentarioUncheckedCreateWithoutAnexoTarefaInput[]
    connectOrCreate?: anexoComentarioCreateOrConnectWithoutAnexoTarefaInput | anexoComentarioCreateOrConnectWithoutAnexoTarefaInput[]
    createMany?: anexoComentarioCreateManyAnexoTarefaInputEnvelope
    connect?: anexoComentarioWhereUniqueInput | anexoComentarioWhereUniqueInput[]
  }

  export type tarefaUpdateOneRequiredWithoutAnexosNestedInput = {
    create?: XOR<tarefaCreateWithoutAnexosInput, tarefaUncheckedCreateWithoutAnexosInput>
    connectOrCreate?: tarefaCreateOrConnectWithoutAnexosInput
    upsert?: tarefaUpsertWithoutAnexosInput
    connect?: tarefaWhereUniqueInput
    update?: XOR<XOR<tarefaUpdateToOneWithWhereWithoutAnexosInput, tarefaUpdateWithoutAnexosInput>, tarefaUncheckedUpdateWithoutAnexosInput>
  }

  export type anexoComentarioUpdateManyWithoutAnexoTarefaNestedInput = {
    create?: XOR<anexoComentarioCreateWithoutAnexoTarefaInput, anexoComentarioUncheckedCreateWithoutAnexoTarefaInput> | anexoComentarioCreateWithoutAnexoTarefaInput[] | anexoComentarioUncheckedCreateWithoutAnexoTarefaInput[]
    connectOrCreate?: anexoComentarioCreateOrConnectWithoutAnexoTarefaInput | anexoComentarioCreateOrConnectWithoutAnexoTarefaInput[]
    upsert?: anexoComentarioUpsertWithWhereUniqueWithoutAnexoTarefaInput | anexoComentarioUpsertWithWhereUniqueWithoutAnexoTarefaInput[]
    createMany?: anexoComentarioCreateManyAnexoTarefaInputEnvelope
    set?: anexoComentarioWhereUniqueInput | anexoComentarioWhereUniqueInput[]
    disconnect?: anexoComentarioWhereUniqueInput | anexoComentarioWhereUniqueInput[]
    delete?: anexoComentarioWhereUniqueInput | anexoComentarioWhereUniqueInput[]
    connect?: anexoComentarioWhereUniqueInput | anexoComentarioWhereUniqueInput[]
    update?: anexoComentarioUpdateWithWhereUniqueWithoutAnexoTarefaInput | anexoComentarioUpdateWithWhereUniqueWithoutAnexoTarefaInput[]
    updateMany?: anexoComentarioUpdateManyWithWhereWithoutAnexoTarefaInput | anexoComentarioUpdateManyWithWhereWithoutAnexoTarefaInput[]
    deleteMany?: anexoComentarioScalarWhereInput | anexoComentarioScalarWhereInput[]
  }

  export type anexoComentarioUncheckedUpdateManyWithoutAnexoTarefaNestedInput = {
    create?: XOR<anexoComentarioCreateWithoutAnexoTarefaInput, anexoComentarioUncheckedCreateWithoutAnexoTarefaInput> | anexoComentarioCreateWithoutAnexoTarefaInput[] | anexoComentarioUncheckedCreateWithoutAnexoTarefaInput[]
    connectOrCreate?: anexoComentarioCreateOrConnectWithoutAnexoTarefaInput | anexoComentarioCreateOrConnectWithoutAnexoTarefaInput[]
    upsert?: anexoComentarioUpsertWithWhereUniqueWithoutAnexoTarefaInput | anexoComentarioUpsertWithWhereUniqueWithoutAnexoTarefaInput[]
    createMany?: anexoComentarioCreateManyAnexoTarefaInputEnvelope
    set?: anexoComentarioWhereUniqueInput | anexoComentarioWhereUniqueInput[]
    disconnect?: anexoComentarioWhereUniqueInput | anexoComentarioWhereUniqueInput[]
    delete?: anexoComentarioWhereUniqueInput | anexoComentarioWhereUniqueInput[]
    connect?: anexoComentarioWhereUniqueInput | anexoComentarioWhereUniqueInput[]
    update?: anexoComentarioUpdateWithWhereUniqueWithoutAnexoTarefaInput | anexoComentarioUpdateWithWhereUniqueWithoutAnexoTarefaInput[]
    updateMany?: anexoComentarioUpdateManyWithWhereWithoutAnexoTarefaInput | anexoComentarioUpdateManyWithWhereWithoutAnexoTarefaInput[]
    deleteMany?: anexoComentarioScalarWhereInput | anexoComentarioScalarWhereInput[]
  }

  export type comentarioCreateNestedOneWithoutAnexosInput = {
    create?: XOR<comentarioCreateWithoutAnexosInput, comentarioUncheckedCreateWithoutAnexosInput>
    connectOrCreate?: comentarioCreateOrConnectWithoutAnexosInput
    connect?: comentarioWhereUniqueInput
  }

  export type anexoTarefaCreateNestedOneWithoutAnexosComentarioInput = {
    create?: XOR<anexoTarefaCreateWithoutAnexosComentarioInput, anexoTarefaUncheckedCreateWithoutAnexosComentarioInput>
    connectOrCreate?: anexoTarefaCreateOrConnectWithoutAnexosComentarioInput
    connect?: anexoTarefaWhereUniqueInput
  }

  export type comentarioUpdateOneRequiredWithoutAnexosNestedInput = {
    create?: XOR<comentarioCreateWithoutAnexosInput, comentarioUncheckedCreateWithoutAnexosInput>
    connectOrCreate?: comentarioCreateOrConnectWithoutAnexosInput
    upsert?: comentarioUpsertWithoutAnexosInput
    connect?: comentarioWhereUniqueInput
    update?: XOR<XOR<comentarioUpdateToOneWithWhereWithoutAnexosInput, comentarioUpdateWithoutAnexosInput>, comentarioUncheckedUpdateWithoutAnexosInput>
  }

  export type anexoTarefaUpdateOneRequiredWithoutAnexosComentarioNestedInput = {
    create?: XOR<anexoTarefaCreateWithoutAnexosComentarioInput, anexoTarefaUncheckedCreateWithoutAnexosComentarioInput>
    connectOrCreate?: anexoTarefaCreateOrConnectWithoutAnexosComentarioInput
    upsert?: anexoTarefaUpsertWithoutAnexosComentarioInput
    connect?: anexoTarefaWhereUniqueInput
    update?: XOR<XOR<anexoTarefaUpdateToOneWithWhereWithoutAnexosComentarioInput, anexoTarefaUpdateWithoutAnexosComentarioInput>, anexoTarefaUncheckedUpdateWithoutAnexosComentarioInput>
  }

  export type usuarioCreateNestedOneWithoutPermissoesInput = {
    create?: XOR<usuarioCreateWithoutPermissoesInput, usuarioUncheckedCreateWithoutPermissoesInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutPermissoesInput
    connect?: usuarioWhereUniqueInput
  }

  export type usuarioUpdateOneRequiredWithoutPermissoesNestedInput = {
    create?: XOR<usuarioCreateWithoutPermissoesInput, usuarioUncheckedCreateWithoutPermissoesInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutPermissoesInput
    upsert?: usuarioUpsertWithoutPermissoesInput
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutPermissoesInput, usuarioUpdateWithoutPermissoesInput>, usuarioUncheckedUpdateWithoutPermissoesInput>
  }

  export type usuarioCreateNestedOneWithoutPermissoesProjetoInput = {
    create?: XOR<usuarioCreateWithoutPermissoesProjetoInput, usuarioUncheckedCreateWithoutPermissoesProjetoInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutPermissoesProjetoInput
    connect?: usuarioWhereUniqueInput
  }

  export type projetoCreateNestedOneWithoutPermissoesInput = {
    create?: XOR<projetoCreateWithoutPermissoesInput, projetoUncheckedCreateWithoutPermissoesInput>
    connectOrCreate?: projetoCreateOrConnectWithoutPermissoesInput
    connect?: projetoWhereUniqueInput
  }

  export type usuarioUpdateOneRequiredWithoutPermissoesProjetoNestedInput = {
    create?: XOR<usuarioCreateWithoutPermissoesProjetoInput, usuarioUncheckedCreateWithoutPermissoesProjetoInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutPermissoesProjetoInput
    upsert?: usuarioUpsertWithoutPermissoesProjetoInput
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutPermissoesProjetoInput, usuarioUpdateWithoutPermissoesProjetoInput>, usuarioUncheckedUpdateWithoutPermissoesProjetoInput>
  }

  export type projetoUpdateOneRequiredWithoutPermissoesNestedInput = {
    create?: XOR<projetoCreateWithoutPermissoesInput, projetoUncheckedCreateWithoutPermissoesInput>
    connectOrCreate?: projetoCreateOrConnectWithoutPermissoesInput
    upsert?: projetoUpsertWithoutPermissoesInput
    connect?: projetoWhereUniqueInput
    update?: XOR<XOR<projetoUpdateToOneWithWhereWithoutPermissoesInput, projetoUpdateWithoutPermissoesInput>, projetoUncheckedUpdateWithoutPermissoesInput>
  }

  export type tarefaCreateNestedOneWithoutPausasInput = {
    create?: XOR<tarefaCreateWithoutPausasInput, tarefaUncheckedCreateWithoutPausasInput>
    connectOrCreate?: tarefaCreateOrConnectWithoutPausasInput
    connect?: tarefaWhereUniqueInput
  }

  export type tarefaUpdateOneRequiredWithoutPausasNestedInput = {
    create?: XOR<tarefaCreateWithoutPausasInput, tarefaUncheckedCreateWithoutPausasInput>
    connectOrCreate?: tarefaCreateOrConnectWithoutPausasInput
    upsert?: tarefaUpsertWithoutPausasInput
    connect?: tarefaWhereUniqueInput
    update?: XOR<XOR<tarefaUpdateToOneWithWhereWithoutPausasInput, tarefaUpdateWithoutPausasInput>, tarefaUncheckedUpdateWithoutPausasInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type usuarioCreateWithoutLoginInput = {
    nome: string
    created_at?: Date | string
    roule?: string | null
    projetoUsuarios?: projetoUsuarioCreateNestedManyWithoutUsuarioInput
    habilidades?: habilidadeUsuarioCreateNestedManyWithoutUsuarioInput
    permissoes?: permissaoCreateNestedManyWithoutUsuarioInput
    permissoesProjeto?: permissaoProjetoCreateNestedManyWithoutUsuarioInput
    participacoes?: participacaoTarefaCreateNestedManyWithoutUsuariosInput
    comentarios?: comentarioCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutLoginInput = {
    usuario_id?: number
    nome: string
    created_at?: Date | string
    roule?: string | null
    projetoUsuarios?: projetoUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    habilidades?: habilidadeUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    permissoes?: permissaoUncheckedCreateNestedManyWithoutUsuarioInput
    permissoesProjeto?: permissaoProjetoUncheckedCreateNestedManyWithoutUsuarioInput
    participacoes?: participacaoTarefaUncheckedCreateNestedManyWithoutUsuariosInput
    comentarios?: comentarioUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutLoginInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutLoginInput, usuarioUncheckedCreateWithoutLoginInput>
  }

  export type usuarioUpsertWithoutLoginInput = {
    update: XOR<usuarioUpdateWithoutLoginInput, usuarioUncheckedUpdateWithoutLoginInput>
    create: XOR<usuarioCreateWithoutLoginInput, usuarioUncheckedCreateWithoutLoginInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutLoginInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutLoginInput, usuarioUncheckedUpdateWithoutLoginInput>
  }

  export type usuarioUpdateWithoutLoginInput = {
    nome?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    roule?: NullableStringFieldUpdateOperationsInput | string | null
    projetoUsuarios?: projetoUsuarioUpdateManyWithoutUsuarioNestedInput
    habilidades?: habilidadeUsuarioUpdateManyWithoutUsuarioNestedInput
    permissoes?: permissaoUpdateManyWithoutUsuarioNestedInput
    permissoesProjeto?: permissaoProjetoUpdateManyWithoutUsuarioNestedInput
    participacoes?: participacaoTarefaUpdateManyWithoutUsuariosNestedInput
    comentarios?: comentarioUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutLoginInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    roule?: NullableStringFieldUpdateOperationsInput | string | null
    projetoUsuarios?: projetoUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    habilidades?: habilidadeUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    permissoes?: permissaoUncheckedUpdateManyWithoutUsuarioNestedInput
    permissoesProjeto?: permissaoProjetoUncheckedUpdateManyWithoutUsuarioNestedInput
    participacoes?: participacaoTarefaUncheckedUpdateManyWithoutUsuariosNestedInput
    comentarios?: comentarioUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type loginCreateWithoutUsuarioInput = {
    email: string
    password?: string | null
    is_verified?: boolean
    provider?: string
    provider_id?: string | null
    profile_image?: string | null
    ativo?: boolean
  }

  export type loginUncheckedCreateWithoutUsuarioInput = {
    login_id?: number
    email: string
    password?: string | null
    is_verified?: boolean
    provider?: string
    provider_id?: string | null
    profile_image?: string | null
    ativo?: boolean
  }

  export type loginCreateOrConnectWithoutUsuarioInput = {
    where: loginWhereUniqueInput
    create: XOR<loginCreateWithoutUsuarioInput, loginUncheckedCreateWithoutUsuarioInput>
  }

  export type projetoUsuarioCreateWithoutUsuarioInput = {
    owner?: boolean
    projeto: projetoCreateNestedOneWithoutProjetoUsuariosInput
    participacoes?: participacaoTarefaCreateNestedManyWithoutProjetoUsuarioInput
  }

  export type projetoUsuarioUncheckedCreateWithoutUsuarioInput = {
    projetoUsuario_id?: number
    projeto_id: number
    owner?: boolean
    participacoes?: participacaoTarefaUncheckedCreateNestedManyWithoutProjetoUsuarioInput
  }

  export type projetoUsuarioCreateOrConnectWithoutUsuarioInput = {
    where: projetoUsuarioWhereUniqueInput
    create: XOR<projetoUsuarioCreateWithoutUsuarioInput, projetoUsuarioUncheckedCreateWithoutUsuarioInput>
  }

  export type projetoUsuarioCreateManyUsuarioInputEnvelope = {
    data: projetoUsuarioCreateManyUsuarioInput | projetoUsuarioCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type habilidadeUsuarioCreateWithoutUsuarioInput = {
    tecnologia: tecnologiaCreateNestedOneWithoutHabilidadesInput
  }

  export type habilidadeUsuarioUncheckedCreateWithoutUsuarioInput = {
    habilidadeUsuario_id?: number
    tecnologia_id: number
  }

  export type habilidadeUsuarioCreateOrConnectWithoutUsuarioInput = {
    where: habilidadeUsuarioWhereUniqueInput
    create: XOR<habilidadeUsuarioCreateWithoutUsuarioInput, habilidadeUsuarioUncheckedCreateWithoutUsuarioInput>
  }

  export type habilidadeUsuarioCreateManyUsuarioInputEnvelope = {
    data: habilidadeUsuarioCreateManyUsuarioInput | habilidadeUsuarioCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type permissaoCreateWithoutUsuarioInput = {
    tipo: string
  }

  export type permissaoUncheckedCreateWithoutUsuarioInput = {
    permissao_id?: number
    tipo: string
  }

  export type permissaoCreateOrConnectWithoutUsuarioInput = {
    where: permissaoWhereUniqueInput
    create: XOR<permissaoCreateWithoutUsuarioInput, permissaoUncheckedCreateWithoutUsuarioInput>
  }

  export type permissaoCreateManyUsuarioInputEnvelope = {
    data: permissaoCreateManyUsuarioInput | permissaoCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type permissaoProjetoCreateWithoutUsuarioInput = {
    tipo: string
    projeto: projetoCreateNestedOneWithoutPermissoesInput
  }

  export type permissaoProjetoUncheckedCreateWithoutUsuarioInput = {
    permissaoProjeto_id?: number
    tipo: string
    projeto_id: number
  }

  export type permissaoProjetoCreateOrConnectWithoutUsuarioInput = {
    where: permissaoProjetoWhereUniqueInput
    create: XOR<permissaoProjetoCreateWithoutUsuarioInput, permissaoProjetoUncheckedCreateWithoutUsuarioInput>
  }

  export type permissaoProjetoCreateManyUsuarioInputEnvelope = {
    data: permissaoProjetoCreateManyUsuarioInput | permissaoProjetoCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type participacaoTarefaCreateWithoutUsuariosInput = {
    tarefa: tarefaCreateNestedOneWithoutParticipacoesInput
    projetoUsuario: projetoUsuarioCreateNestedOneWithoutParticipacoesInput
    comentarios?: comentarioCreateNestedManyWithoutParticipacaoTarefaInput
  }

  export type participacaoTarefaUncheckedCreateWithoutUsuariosInput = {
    participacaoTarefa_id?: number
    tarefa_id: number
    projetoUsuario_id: number
    comentarios?: comentarioUncheckedCreateNestedManyWithoutParticipacaoTarefaInput
  }

  export type participacaoTarefaCreateOrConnectWithoutUsuariosInput = {
    where: participacaoTarefaWhereUniqueInput
    create: XOR<participacaoTarefaCreateWithoutUsuariosInput, participacaoTarefaUncheckedCreateWithoutUsuariosInput>
  }

  export type comentarioCreateWithoutUsuarioInput = {
    comentario: string
    data_hora?: Date | string
    participacaoTarefa: participacaoTarefaCreateNestedOneWithoutComentariosInput
    anexos?: anexoComentarioCreateNestedManyWithoutComentarioInput
  }

  export type comentarioUncheckedCreateWithoutUsuarioInput = {
    comentario_id?: number
    comentario: string
    data_hora?: Date | string
    participacaoTarefa_id: number
    anexos?: anexoComentarioUncheckedCreateNestedManyWithoutComentarioInput
  }

  export type comentarioCreateOrConnectWithoutUsuarioInput = {
    where: comentarioWhereUniqueInput
    create: XOR<comentarioCreateWithoutUsuarioInput, comentarioUncheckedCreateWithoutUsuarioInput>
  }

  export type comentarioCreateManyUsuarioInputEnvelope = {
    data: comentarioCreateManyUsuarioInput | comentarioCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type loginUpsertWithoutUsuarioInput = {
    update: XOR<loginUpdateWithoutUsuarioInput, loginUncheckedUpdateWithoutUsuarioInput>
    create: XOR<loginCreateWithoutUsuarioInput, loginUncheckedCreateWithoutUsuarioInput>
    where?: loginWhereInput
  }

  export type loginUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: loginWhereInput
    data: XOR<loginUpdateWithoutUsuarioInput, loginUncheckedUpdateWithoutUsuarioInput>
  }

  export type loginUpdateWithoutUsuarioInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type loginUncheckedUpdateWithoutUsuarioInput = {
    login_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    provider?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type projetoUsuarioUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: projetoUsuarioWhereUniqueInput
    update: XOR<projetoUsuarioUpdateWithoutUsuarioInput, projetoUsuarioUncheckedUpdateWithoutUsuarioInput>
    create: XOR<projetoUsuarioCreateWithoutUsuarioInput, projetoUsuarioUncheckedCreateWithoutUsuarioInput>
  }

  export type projetoUsuarioUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: projetoUsuarioWhereUniqueInput
    data: XOR<projetoUsuarioUpdateWithoutUsuarioInput, projetoUsuarioUncheckedUpdateWithoutUsuarioInput>
  }

  export type projetoUsuarioUpdateManyWithWhereWithoutUsuarioInput = {
    where: projetoUsuarioScalarWhereInput
    data: XOR<projetoUsuarioUpdateManyMutationInput, projetoUsuarioUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type projetoUsuarioScalarWhereInput = {
    AND?: projetoUsuarioScalarWhereInput | projetoUsuarioScalarWhereInput[]
    OR?: projetoUsuarioScalarWhereInput[]
    NOT?: projetoUsuarioScalarWhereInput | projetoUsuarioScalarWhereInput[]
    projetoUsuario_id?: IntFilter<"projetoUsuario"> | number
    projeto_id?: IntFilter<"projetoUsuario"> | number
    usuario_id?: IntFilter<"projetoUsuario"> | number
    owner?: BoolFilter<"projetoUsuario"> | boolean
  }

  export type habilidadeUsuarioUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: habilidadeUsuarioWhereUniqueInput
    update: XOR<habilidadeUsuarioUpdateWithoutUsuarioInput, habilidadeUsuarioUncheckedUpdateWithoutUsuarioInput>
    create: XOR<habilidadeUsuarioCreateWithoutUsuarioInput, habilidadeUsuarioUncheckedCreateWithoutUsuarioInput>
  }

  export type habilidadeUsuarioUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: habilidadeUsuarioWhereUniqueInput
    data: XOR<habilidadeUsuarioUpdateWithoutUsuarioInput, habilidadeUsuarioUncheckedUpdateWithoutUsuarioInput>
  }

  export type habilidadeUsuarioUpdateManyWithWhereWithoutUsuarioInput = {
    where: habilidadeUsuarioScalarWhereInput
    data: XOR<habilidadeUsuarioUpdateManyMutationInput, habilidadeUsuarioUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type habilidadeUsuarioScalarWhereInput = {
    AND?: habilidadeUsuarioScalarWhereInput | habilidadeUsuarioScalarWhereInput[]
    OR?: habilidadeUsuarioScalarWhereInput[]
    NOT?: habilidadeUsuarioScalarWhereInput | habilidadeUsuarioScalarWhereInput[]
    habilidadeUsuario_id?: IntFilter<"habilidadeUsuario"> | number
    tecnologia_id?: IntFilter<"habilidadeUsuario"> | number
    usuario_id?: IntFilter<"habilidadeUsuario"> | number
  }

  export type permissaoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: permissaoWhereUniqueInput
    update: XOR<permissaoUpdateWithoutUsuarioInput, permissaoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<permissaoCreateWithoutUsuarioInput, permissaoUncheckedCreateWithoutUsuarioInput>
  }

  export type permissaoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: permissaoWhereUniqueInput
    data: XOR<permissaoUpdateWithoutUsuarioInput, permissaoUncheckedUpdateWithoutUsuarioInput>
  }

  export type permissaoUpdateManyWithWhereWithoutUsuarioInput = {
    where: permissaoScalarWhereInput
    data: XOR<permissaoUpdateManyMutationInput, permissaoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type permissaoScalarWhereInput = {
    AND?: permissaoScalarWhereInput | permissaoScalarWhereInput[]
    OR?: permissaoScalarWhereInput[]
    NOT?: permissaoScalarWhereInput | permissaoScalarWhereInput[]
    permissao_id?: IntFilter<"permissao"> | number
    tipo?: StringFilter<"permissao"> | string
    usuario_id?: IntFilter<"permissao"> | number
  }

  export type permissaoProjetoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: permissaoProjetoWhereUniqueInput
    update: XOR<permissaoProjetoUpdateWithoutUsuarioInput, permissaoProjetoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<permissaoProjetoCreateWithoutUsuarioInput, permissaoProjetoUncheckedCreateWithoutUsuarioInput>
  }

  export type permissaoProjetoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: permissaoProjetoWhereUniqueInput
    data: XOR<permissaoProjetoUpdateWithoutUsuarioInput, permissaoProjetoUncheckedUpdateWithoutUsuarioInput>
  }

  export type permissaoProjetoUpdateManyWithWhereWithoutUsuarioInput = {
    where: permissaoProjetoScalarWhereInput
    data: XOR<permissaoProjetoUpdateManyMutationInput, permissaoProjetoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type permissaoProjetoScalarWhereInput = {
    AND?: permissaoProjetoScalarWhereInput | permissaoProjetoScalarWhereInput[]
    OR?: permissaoProjetoScalarWhereInput[]
    NOT?: permissaoProjetoScalarWhereInput | permissaoProjetoScalarWhereInput[]
    permissaoProjeto_id?: IntFilter<"permissaoProjeto"> | number
    tipo?: StringFilter<"permissaoProjeto"> | string
    usuario_id?: IntFilter<"permissaoProjeto"> | number
    projeto_id?: IntFilter<"permissaoProjeto"> | number
  }

  export type participacaoTarefaUpsertWithWhereUniqueWithoutUsuariosInput = {
    where: participacaoTarefaWhereUniqueInput
    update: XOR<participacaoTarefaUpdateWithoutUsuariosInput, participacaoTarefaUncheckedUpdateWithoutUsuariosInput>
    create: XOR<participacaoTarefaCreateWithoutUsuariosInput, participacaoTarefaUncheckedCreateWithoutUsuariosInput>
  }

  export type participacaoTarefaUpdateWithWhereUniqueWithoutUsuariosInput = {
    where: participacaoTarefaWhereUniqueInput
    data: XOR<participacaoTarefaUpdateWithoutUsuariosInput, participacaoTarefaUncheckedUpdateWithoutUsuariosInput>
  }

  export type participacaoTarefaUpdateManyWithWhereWithoutUsuariosInput = {
    where: participacaoTarefaScalarWhereInput
    data: XOR<participacaoTarefaUpdateManyMutationInput, participacaoTarefaUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type participacaoTarefaScalarWhereInput = {
    AND?: participacaoTarefaScalarWhereInput | participacaoTarefaScalarWhereInput[]
    OR?: participacaoTarefaScalarWhereInput[]
    NOT?: participacaoTarefaScalarWhereInput | participacaoTarefaScalarWhereInput[]
    participacaoTarefa_id?: IntFilter<"participacaoTarefa"> | number
    tarefa_id?: IntFilter<"participacaoTarefa"> | number
    projetoUsuario_id?: IntFilter<"participacaoTarefa"> | number
  }

  export type comentarioUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: comentarioWhereUniqueInput
    update: XOR<comentarioUpdateWithoutUsuarioInput, comentarioUncheckedUpdateWithoutUsuarioInput>
    create: XOR<comentarioCreateWithoutUsuarioInput, comentarioUncheckedCreateWithoutUsuarioInput>
  }

  export type comentarioUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: comentarioWhereUniqueInput
    data: XOR<comentarioUpdateWithoutUsuarioInput, comentarioUncheckedUpdateWithoutUsuarioInput>
  }

  export type comentarioUpdateManyWithWhereWithoutUsuarioInput = {
    where: comentarioScalarWhereInput
    data: XOR<comentarioUpdateManyMutationInput, comentarioUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type comentarioScalarWhereInput = {
    AND?: comentarioScalarWhereInput | comentarioScalarWhereInput[]
    OR?: comentarioScalarWhereInput[]
    NOT?: comentarioScalarWhereInput | comentarioScalarWhereInput[]
    comentario_id?: IntFilter<"comentario"> | number
    comentario?: StringFilter<"comentario"> | string
    data_hora?: DateTimeFilter<"comentario"> | Date | string
    participacaoTarefa_id?: IntFilter<"comentario"> | number
    usuario_id?: IntFilter<"comentario"> | number
  }

  export type projetoUsuarioCreateWithoutProjetoInput = {
    owner?: boolean
    usuario: usuarioCreateNestedOneWithoutProjetoUsuariosInput
    participacoes?: participacaoTarefaCreateNestedManyWithoutProjetoUsuarioInput
  }

  export type projetoUsuarioUncheckedCreateWithoutProjetoInput = {
    projetoUsuario_id?: number
    usuario_id: number
    owner?: boolean
    participacoes?: participacaoTarefaUncheckedCreateNestedManyWithoutProjetoUsuarioInput
  }

  export type projetoUsuarioCreateOrConnectWithoutProjetoInput = {
    where: projetoUsuarioWhereUniqueInput
    create: XOR<projetoUsuarioCreateWithoutProjetoInput, projetoUsuarioUncheckedCreateWithoutProjetoInput>
  }

  export type projetoUsuarioCreateManyProjetoInputEnvelope = {
    data: projetoUsuarioCreateManyProjetoInput | projetoUsuarioCreateManyProjetoInput[]
    skipDuplicates?: boolean
  }

  export type projetoTecnologiaCreateWithoutProjetoInput = {
    tecnologia: tecnologiaCreateNestedOneWithoutProjetosInput
  }

  export type projetoTecnologiaUncheckedCreateWithoutProjetoInput = {
    projetoTecnologia_id?: number
    tecnologia_id: number
  }

  export type projetoTecnologiaCreateOrConnectWithoutProjetoInput = {
    where: projetoTecnologiaWhereUniqueInput
    create: XOR<projetoTecnologiaCreateWithoutProjetoInput, projetoTecnologiaUncheckedCreateWithoutProjetoInput>
  }

  export type projetoTecnologiaCreateManyProjetoInputEnvelope = {
    data: projetoTecnologiaCreateManyProjetoInput | projetoTecnologiaCreateManyProjetoInput[]
    skipDuplicates?: boolean
  }

  export type recursoCreateWithoutProjetoInput = {
    descricao: string
  }

  export type recursoUncheckedCreateWithoutProjetoInput = {
    recurso_id?: number
    descricao: string
  }

  export type recursoCreateOrConnectWithoutProjetoInput = {
    where: recursoWhereUniqueInput
    create: XOR<recursoCreateWithoutProjetoInput, recursoUncheckedCreateWithoutProjetoInput>
  }

  export type recursoCreateManyProjetoInputEnvelope = {
    data: recursoCreateManyProjetoInput | recursoCreateManyProjetoInput[]
    skipDuplicates?: boolean
  }

  export type anexoProjetoCreateWithoutProjetoInput = {
    nome: string
    tipo: string
    conteudo: Buffer
    created_at?: Date | string
  }

  export type anexoProjetoUncheckedCreateWithoutProjetoInput = {
    anexo_id?: number
    nome: string
    tipo: string
    conteudo: Buffer
    created_at?: Date | string
  }

  export type anexoProjetoCreateOrConnectWithoutProjetoInput = {
    where: anexoProjetoWhereUniqueInput
    create: XOR<anexoProjetoCreateWithoutProjetoInput, anexoProjetoUncheckedCreateWithoutProjetoInput>
  }

  export type anexoProjetoCreateManyProjetoInputEnvelope = {
    data: anexoProjetoCreateManyProjetoInput | anexoProjetoCreateManyProjetoInput[]
    skipDuplicates?: boolean
  }

  export type permissaoProjetoCreateWithoutProjetoInput = {
    tipo: string
    usuario: usuarioCreateNestedOneWithoutPermissoesProjetoInput
  }

  export type permissaoProjetoUncheckedCreateWithoutProjetoInput = {
    permissaoProjeto_id?: number
    tipo: string
    usuario_id: number
  }

  export type permissaoProjetoCreateOrConnectWithoutProjetoInput = {
    where: permissaoProjetoWhereUniqueInput
    create: XOR<permissaoProjetoCreateWithoutProjetoInput, permissaoProjetoUncheckedCreateWithoutProjetoInput>
  }

  export type permissaoProjetoCreateManyProjetoInputEnvelope = {
    data: permissaoProjetoCreateManyProjetoInput | permissaoProjetoCreateManyProjetoInput[]
    skipDuplicates?: boolean
  }

  export type projetoUsuarioUpsertWithWhereUniqueWithoutProjetoInput = {
    where: projetoUsuarioWhereUniqueInput
    update: XOR<projetoUsuarioUpdateWithoutProjetoInput, projetoUsuarioUncheckedUpdateWithoutProjetoInput>
    create: XOR<projetoUsuarioCreateWithoutProjetoInput, projetoUsuarioUncheckedCreateWithoutProjetoInput>
  }

  export type projetoUsuarioUpdateWithWhereUniqueWithoutProjetoInput = {
    where: projetoUsuarioWhereUniqueInput
    data: XOR<projetoUsuarioUpdateWithoutProjetoInput, projetoUsuarioUncheckedUpdateWithoutProjetoInput>
  }

  export type projetoUsuarioUpdateManyWithWhereWithoutProjetoInput = {
    where: projetoUsuarioScalarWhereInput
    data: XOR<projetoUsuarioUpdateManyMutationInput, projetoUsuarioUncheckedUpdateManyWithoutProjetoInput>
  }

  export type projetoTecnologiaUpsertWithWhereUniqueWithoutProjetoInput = {
    where: projetoTecnologiaWhereUniqueInput
    update: XOR<projetoTecnologiaUpdateWithoutProjetoInput, projetoTecnologiaUncheckedUpdateWithoutProjetoInput>
    create: XOR<projetoTecnologiaCreateWithoutProjetoInput, projetoTecnologiaUncheckedCreateWithoutProjetoInput>
  }

  export type projetoTecnologiaUpdateWithWhereUniqueWithoutProjetoInput = {
    where: projetoTecnologiaWhereUniqueInput
    data: XOR<projetoTecnologiaUpdateWithoutProjetoInput, projetoTecnologiaUncheckedUpdateWithoutProjetoInput>
  }

  export type projetoTecnologiaUpdateManyWithWhereWithoutProjetoInput = {
    where: projetoTecnologiaScalarWhereInput
    data: XOR<projetoTecnologiaUpdateManyMutationInput, projetoTecnologiaUncheckedUpdateManyWithoutProjetoInput>
  }

  export type projetoTecnologiaScalarWhereInput = {
    AND?: projetoTecnologiaScalarWhereInput | projetoTecnologiaScalarWhereInput[]
    OR?: projetoTecnologiaScalarWhereInput[]
    NOT?: projetoTecnologiaScalarWhereInput | projetoTecnologiaScalarWhereInput[]
    projetoTecnologia_id?: IntFilter<"projetoTecnologia"> | number
    tecnologia_id?: IntFilter<"projetoTecnologia"> | number
    projeto_id?: IntFilter<"projetoTecnologia"> | number
  }

  export type recursoUpsertWithWhereUniqueWithoutProjetoInput = {
    where: recursoWhereUniqueInput
    update: XOR<recursoUpdateWithoutProjetoInput, recursoUncheckedUpdateWithoutProjetoInput>
    create: XOR<recursoCreateWithoutProjetoInput, recursoUncheckedCreateWithoutProjetoInput>
  }

  export type recursoUpdateWithWhereUniqueWithoutProjetoInput = {
    where: recursoWhereUniqueInput
    data: XOR<recursoUpdateWithoutProjetoInput, recursoUncheckedUpdateWithoutProjetoInput>
  }

  export type recursoUpdateManyWithWhereWithoutProjetoInput = {
    where: recursoScalarWhereInput
    data: XOR<recursoUpdateManyMutationInput, recursoUncheckedUpdateManyWithoutProjetoInput>
  }

  export type recursoScalarWhereInput = {
    AND?: recursoScalarWhereInput | recursoScalarWhereInput[]
    OR?: recursoScalarWhereInput[]
    NOT?: recursoScalarWhereInput | recursoScalarWhereInput[]
    recurso_id?: IntFilter<"recurso"> | number
    descricao?: StringFilter<"recurso"> | string
    projeto_id?: IntFilter<"recurso"> | number
  }

  export type anexoProjetoUpsertWithWhereUniqueWithoutProjetoInput = {
    where: anexoProjetoWhereUniqueInput
    update: XOR<anexoProjetoUpdateWithoutProjetoInput, anexoProjetoUncheckedUpdateWithoutProjetoInput>
    create: XOR<anexoProjetoCreateWithoutProjetoInput, anexoProjetoUncheckedCreateWithoutProjetoInput>
  }

  export type anexoProjetoUpdateWithWhereUniqueWithoutProjetoInput = {
    where: anexoProjetoWhereUniqueInput
    data: XOR<anexoProjetoUpdateWithoutProjetoInput, anexoProjetoUncheckedUpdateWithoutProjetoInput>
  }

  export type anexoProjetoUpdateManyWithWhereWithoutProjetoInput = {
    where: anexoProjetoScalarWhereInput
    data: XOR<anexoProjetoUpdateManyMutationInput, anexoProjetoUncheckedUpdateManyWithoutProjetoInput>
  }

  export type anexoProjetoScalarWhereInput = {
    AND?: anexoProjetoScalarWhereInput | anexoProjetoScalarWhereInput[]
    OR?: anexoProjetoScalarWhereInput[]
    NOT?: anexoProjetoScalarWhereInput | anexoProjetoScalarWhereInput[]
    anexo_id?: IntFilter<"anexoProjeto"> | number
    nome?: StringFilter<"anexoProjeto"> | string
    tipo?: StringFilter<"anexoProjeto"> | string
    conteudo?: BytesFilter<"anexoProjeto"> | Buffer
    projeto_id?: IntFilter<"anexoProjeto"> | number
    created_at?: DateTimeFilter<"anexoProjeto"> | Date | string
  }

  export type permissaoProjetoUpsertWithWhereUniqueWithoutProjetoInput = {
    where: permissaoProjetoWhereUniqueInput
    update: XOR<permissaoProjetoUpdateWithoutProjetoInput, permissaoProjetoUncheckedUpdateWithoutProjetoInput>
    create: XOR<permissaoProjetoCreateWithoutProjetoInput, permissaoProjetoUncheckedCreateWithoutProjetoInput>
  }

  export type permissaoProjetoUpdateWithWhereUniqueWithoutProjetoInput = {
    where: permissaoProjetoWhereUniqueInput
    data: XOR<permissaoProjetoUpdateWithoutProjetoInput, permissaoProjetoUncheckedUpdateWithoutProjetoInput>
  }

  export type permissaoProjetoUpdateManyWithWhereWithoutProjetoInput = {
    where: permissaoProjetoScalarWhereInput
    data: XOR<permissaoProjetoUpdateManyMutationInput, permissaoProjetoUncheckedUpdateManyWithoutProjetoInput>
  }

  export type habilidadeUsuarioCreateWithoutTecnologiaInput = {
    usuario: usuarioCreateNestedOneWithoutHabilidadesInput
  }

  export type habilidadeUsuarioUncheckedCreateWithoutTecnologiaInput = {
    habilidadeUsuario_id?: number
    usuario_id: number
  }

  export type habilidadeUsuarioCreateOrConnectWithoutTecnologiaInput = {
    where: habilidadeUsuarioWhereUniqueInput
    create: XOR<habilidadeUsuarioCreateWithoutTecnologiaInput, habilidadeUsuarioUncheckedCreateWithoutTecnologiaInput>
  }

  export type habilidadeUsuarioCreateManyTecnologiaInputEnvelope = {
    data: habilidadeUsuarioCreateManyTecnologiaInput | habilidadeUsuarioCreateManyTecnologiaInput[]
    skipDuplicates?: boolean
  }

  export type projetoTecnologiaCreateWithoutTecnologiaInput = {
    projeto: projetoCreateNestedOneWithoutTecnologiasInput
  }

  export type projetoTecnologiaUncheckedCreateWithoutTecnologiaInput = {
    projetoTecnologia_id?: number
    projeto_id: number
  }

  export type projetoTecnologiaCreateOrConnectWithoutTecnologiaInput = {
    where: projetoTecnologiaWhereUniqueInput
    create: XOR<projetoTecnologiaCreateWithoutTecnologiaInput, projetoTecnologiaUncheckedCreateWithoutTecnologiaInput>
  }

  export type projetoTecnologiaCreateManyTecnologiaInputEnvelope = {
    data: projetoTecnologiaCreateManyTecnologiaInput | projetoTecnologiaCreateManyTecnologiaInput[]
    skipDuplicates?: boolean
  }

  export type habilidadeUsuarioUpsertWithWhereUniqueWithoutTecnologiaInput = {
    where: habilidadeUsuarioWhereUniqueInput
    update: XOR<habilidadeUsuarioUpdateWithoutTecnologiaInput, habilidadeUsuarioUncheckedUpdateWithoutTecnologiaInput>
    create: XOR<habilidadeUsuarioCreateWithoutTecnologiaInput, habilidadeUsuarioUncheckedCreateWithoutTecnologiaInput>
  }

  export type habilidadeUsuarioUpdateWithWhereUniqueWithoutTecnologiaInput = {
    where: habilidadeUsuarioWhereUniqueInput
    data: XOR<habilidadeUsuarioUpdateWithoutTecnologiaInput, habilidadeUsuarioUncheckedUpdateWithoutTecnologiaInput>
  }

  export type habilidadeUsuarioUpdateManyWithWhereWithoutTecnologiaInput = {
    where: habilidadeUsuarioScalarWhereInput
    data: XOR<habilidadeUsuarioUpdateManyMutationInput, habilidadeUsuarioUncheckedUpdateManyWithoutTecnologiaInput>
  }

  export type projetoTecnologiaUpsertWithWhereUniqueWithoutTecnologiaInput = {
    where: projetoTecnologiaWhereUniqueInput
    update: XOR<projetoTecnologiaUpdateWithoutTecnologiaInput, projetoTecnologiaUncheckedUpdateWithoutTecnologiaInput>
    create: XOR<projetoTecnologiaCreateWithoutTecnologiaInput, projetoTecnologiaUncheckedCreateWithoutTecnologiaInput>
  }

  export type projetoTecnologiaUpdateWithWhereUniqueWithoutTecnologiaInput = {
    where: projetoTecnologiaWhereUniqueInput
    data: XOR<projetoTecnologiaUpdateWithoutTecnologiaInput, projetoTecnologiaUncheckedUpdateWithoutTecnologiaInput>
  }

  export type projetoTecnologiaUpdateManyWithWhereWithoutTecnologiaInput = {
    where: projetoTecnologiaScalarWhereInput
    data: XOR<projetoTecnologiaUpdateManyMutationInput, projetoTecnologiaUncheckedUpdateManyWithoutTecnologiaInput>
  }

  export type participacaoTarefaCreateWithoutTarefaInput = {
    projetoUsuario: projetoUsuarioCreateNestedOneWithoutParticipacoesInput
    comentarios?: comentarioCreateNestedManyWithoutParticipacaoTarefaInput
    usuarios?: usuarioCreateNestedManyWithoutParticipacoesInput
  }

  export type participacaoTarefaUncheckedCreateWithoutTarefaInput = {
    participacaoTarefa_id?: number
    projetoUsuario_id: number
    comentarios?: comentarioUncheckedCreateNestedManyWithoutParticipacaoTarefaInput
    usuarios?: usuarioUncheckedCreateNestedManyWithoutParticipacoesInput
  }

  export type participacaoTarefaCreateOrConnectWithoutTarefaInput = {
    where: participacaoTarefaWhereUniqueInput
    create: XOR<participacaoTarefaCreateWithoutTarefaInput, participacaoTarefaUncheckedCreateWithoutTarefaInput>
  }

  export type participacaoTarefaCreateManyTarefaInputEnvelope = {
    data: participacaoTarefaCreateManyTarefaInput | participacaoTarefaCreateManyTarefaInput[]
    skipDuplicates?: boolean
  }

  export type anexoTarefaCreateWithoutTarefaInput = {
    nome: string
    tipo: string
    conteudo: Buffer
    created_at?: Date | string
    anexosComentario?: anexoComentarioCreateNestedManyWithoutAnexoTarefaInput
  }

  export type anexoTarefaUncheckedCreateWithoutTarefaInput = {
    anexoTarefa_id?: number
    nome: string
    tipo: string
    conteudo: Buffer
    created_at?: Date | string
    anexosComentario?: anexoComentarioUncheckedCreateNestedManyWithoutAnexoTarefaInput
  }

  export type anexoTarefaCreateOrConnectWithoutTarefaInput = {
    where: anexoTarefaWhereUniqueInput
    create: XOR<anexoTarefaCreateWithoutTarefaInput, anexoTarefaUncheckedCreateWithoutTarefaInput>
  }

  export type anexoTarefaCreateManyTarefaInputEnvelope = {
    data: anexoTarefaCreateManyTarefaInput | anexoTarefaCreateManyTarefaInput[]
    skipDuplicates?: boolean
  }

  export type pausaTarefaCreateWithoutTarefaInput = {
    inicioPausa: Date | string
    fimPausa?: Date | string | null
  }

  export type pausaTarefaUncheckedCreateWithoutTarefaInput = {
    pausa_id?: number
    inicioPausa: Date | string
    fimPausa?: Date | string | null
  }

  export type pausaTarefaCreateOrConnectWithoutTarefaInput = {
    where: pausaTarefaWhereUniqueInput
    create: XOR<pausaTarefaCreateWithoutTarefaInput, pausaTarefaUncheckedCreateWithoutTarefaInput>
  }

  export type pausaTarefaCreateManyTarefaInputEnvelope = {
    data: pausaTarefaCreateManyTarefaInput | pausaTarefaCreateManyTarefaInput[]
    skipDuplicates?: boolean
  }

  export type participacaoTarefaUpsertWithWhereUniqueWithoutTarefaInput = {
    where: participacaoTarefaWhereUniqueInput
    update: XOR<participacaoTarefaUpdateWithoutTarefaInput, participacaoTarefaUncheckedUpdateWithoutTarefaInput>
    create: XOR<participacaoTarefaCreateWithoutTarefaInput, participacaoTarefaUncheckedCreateWithoutTarefaInput>
  }

  export type participacaoTarefaUpdateWithWhereUniqueWithoutTarefaInput = {
    where: participacaoTarefaWhereUniqueInput
    data: XOR<participacaoTarefaUpdateWithoutTarefaInput, participacaoTarefaUncheckedUpdateWithoutTarefaInput>
  }

  export type participacaoTarefaUpdateManyWithWhereWithoutTarefaInput = {
    where: participacaoTarefaScalarWhereInput
    data: XOR<participacaoTarefaUpdateManyMutationInput, participacaoTarefaUncheckedUpdateManyWithoutTarefaInput>
  }

  export type anexoTarefaUpsertWithWhereUniqueWithoutTarefaInput = {
    where: anexoTarefaWhereUniqueInput
    update: XOR<anexoTarefaUpdateWithoutTarefaInput, anexoTarefaUncheckedUpdateWithoutTarefaInput>
    create: XOR<anexoTarefaCreateWithoutTarefaInput, anexoTarefaUncheckedCreateWithoutTarefaInput>
  }

  export type anexoTarefaUpdateWithWhereUniqueWithoutTarefaInput = {
    where: anexoTarefaWhereUniqueInput
    data: XOR<anexoTarefaUpdateWithoutTarefaInput, anexoTarefaUncheckedUpdateWithoutTarefaInput>
  }

  export type anexoTarefaUpdateManyWithWhereWithoutTarefaInput = {
    where: anexoTarefaScalarWhereInput
    data: XOR<anexoTarefaUpdateManyMutationInput, anexoTarefaUncheckedUpdateManyWithoutTarefaInput>
  }

  export type anexoTarefaScalarWhereInput = {
    AND?: anexoTarefaScalarWhereInput | anexoTarefaScalarWhereInput[]
    OR?: anexoTarefaScalarWhereInput[]
    NOT?: anexoTarefaScalarWhereInput | anexoTarefaScalarWhereInput[]
    anexoTarefa_id?: IntFilter<"anexoTarefa"> | number
    nome?: StringFilter<"anexoTarefa"> | string
    tipo?: StringFilter<"anexoTarefa"> | string
    conteudo?: BytesFilter<"anexoTarefa"> | Buffer
    created_at?: DateTimeFilter<"anexoTarefa"> | Date | string
    tarefa_id?: IntFilter<"anexoTarefa"> | number
  }

  export type pausaTarefaUpsertWithWhereUniqueWithoutTarefaInput = {
    where: pausaTarefaWhereUniqueInput
    update: XOR<pausaTarefaUpdateWithoutTarefaInput, pausaTarefaUncheckedUpdateWithoutTarefaInput>
    create: XOR<pausaTarefaCreateWithoutTarefaInput, pausaTarefaUncheckedCreateWithoutTarefaInput>
  }

  export type pausaTarefaUpdateWithWhereUniqueWithoutTarefaInput = {
    where: pausaTarefaWhereUniqueInput
    data: XOR<pausaTarefaUpdateWithoutTarefaInput, pausaTarefaUncheckedUpdateWithoutTarefaInput>
  }

  export type pausaTarefaUpdateManyWithWhereWithoutTarefaInput = {
    where: pausaTarefaScalarWhereInput
    data: XOR<pausaTarefaUpdateManyMutationInput, pausaTarefaUncheckedUpdateManyWithoutTarefaInput>
  }

  export type pausaTarefaScalarWhereInput = {
    AND?: pausaTarefaScalarWhereInput | pausaTarefaScalarWhereInput[]
    OR?: pausaTarefaScalarWhereInput[]
    NOT?: pausaTarefaScalarWhereInput | pausaTarefaScalarWhereInput[]
    pausa_id?: IntFilter<"pausaTarefa"> | number
    tarefa_id?: IntFilter<"pausaTarefa"> | number
    inicioPausa?: DateTimeFilter<"pausaTarefa"> | Date | string
    fimPausa?: DateTimeNullableFilter<"pausaTarefa"> | Date | string | null
  }

  export type projetoCreateWithoutProjetoUsuariosInput = {
    nome: string
    descricao: string
    created_at?: Date | string
    conclude_at?: Date | string | null
    tecnologias?: projetoTecnologiaCreateNestedManyWithoutProjetoInput
    recursos?: recursoCreateNestedManyWithoutProjetoInput
    anexos?: anexoProjetoCreateNestedManyWithoutProjetoInput
    permissoes?: permissaoProjetoCreateNestedManyWithoutProjetoInput
  }

  export type projetoUncheckedCreateWithoutProjetoUsuariosInput = {
    projeto_id?: number
    nome: string
    descricao: string
    created_at?: Date | string
    conclude_at?: Date | string | null
    tecnologias?: projetoTecnologiaUncheckedCreateNestedManyWithoutProjetoInput
    recursos?: recursoUncheckedCreateNestedManyWithoutProjetoInput
    anexos?: anexoProjetoUncheckedCreateNestedManyWithoutProjetoInput
    permissoes?: permissaoProjetoUncheckedCreateNestedManyWithoutProjetoInput
  }

  export type projetoCreateOrConnectWithoutProjetoUsuariosInput = {
    where: projetoWhereUniqueInput
    create: XOR<projetoCreateWithoutProjetoUsuariosInput, projetoUncheckedCreateWithoutProjetoUsuariosInput>
  }

  export type usuarioCreateWithoutProjetoUsuariosInput = {
    nome: string
    created_at?: Date | string
    roule?: string | null
    login: loginCreateNestedOneWithoutUsuarioInput
    habilidades?: habilidadeUsuarioCreateNestedManyWithoutUsuarioInput
    permissoes?: permissaoCreateNestedManyWithoutUsuarioInput
    permissoesProjeto?: permissaoProjetoCreateNestedManyWithoutUsuarioInput
    participacoes?: participacaoTarefaCreateNestedManyWithoutUsuariosInput
    comentarios?: comentarioCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutProjetoUsuariosInput = {
    usuario_id?: number
    nome: string
    created_at?: Date | string
    roule?: string | null
    login_id: number
    habilidades?: habilidadeUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    permissoes?: permissaoUncheckedCreateNestedManyWithoutUsuarioInput
    permissoesProjeto?: permissaoProjetoUncheckedCreateNestedManyWithoutUsuarioInput
    participacoes?: participacaoTarefaUncheckedCreateNestedManyWithoutUsuariosInput
    comentarios?: comentarioUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutProjetoUsuariosInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutProjetoUsuariosInput, usuarioUncheckedCreateWithoutProjetoUsuariosInput>
  }

  export type participacaoTarefaCreateWithoutProjetoUsuarioInput = {
    tarefa: tarefaCreateNestedOneWithoutParticipacoesInput
    comentarios?: comentarioCreateNestedManyWithoutParticipacaoTarefaInput
    usuarios?: usuarioCreateNestedManyWithoutParticipacoesInput
  }

  export type participacaoTarefaUncheckedCreateWithoutProjetoUsuarioInput = {
    participacaoTarefa_id?: number
    tarefa_id: number
    comentarios?: comentarioUncheckedCreateNestedManyWithoutParticipacaoTarefaInput
    usuarios?: usuarioUncheckedCreateNestedManyWithoutParticipacoesInput
  }

  export type participacaoTarefaCreateOrConnectWithoutProjetoUsuarioInput = {
    where: participacaoTarefaWhereUniqueInput
    create: XOR<participacaoTarefaCreateWithoutProjetoUsuarioInput, participacaoTarefaUncheckedCreateWithoutProjetoUsuarioInput>
  }

  export type participacaoTarefaCreateManyProjetoUsuarioInputEnvelope = {
    data: participacaoTarefaCreateManyProjetoUsuarioInput | participacaoTarefaCreateManyProjetoUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type projetoUpsertWithoutProjetoUsuariosInput = {
    update: XOR<projetoUpdateWithoutProjetoUsuariosInput, projetoUncheckedUpdateWithoutProjetoUsuariosInput>
    create: XOR<projetoCreateWithoutProjetoUsuariosInput, projetoUncheckedCreateWithoutProjetoUsuariosInput>
    where?: projetoWhereInput
  }

  export type projetoUpdateToOneWithWhereWithoutProjetoUsuariosInput = {
    where?: projetoWhereInput
    data: XOR<projetoUpdateWithoutProjetoUsuariosInput, projetoUncheckedUpdateWithoutProjetoUsuariosInput>
  }

  export type projetoUpdateWithoutProjetoUsuariosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    conclude_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tecnologias?: projetoTecnologiaUpdateManyWithoutProjetoNestedInput
    recursos?: recursoUpdateManyWithoutProjetoNestedInput
    anexos?: anexoProjetoUpdateManyWithoutProjetoNestedInput
    permissoes?: permissaoProjetoUpdateManyWithoutProjetoNestedInput
  }

  export type projetoUncheckedUpdateWithoutProjetoUsuariosInput = {
    projeto_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    conclude_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tecnologias?: projetoTecnologiaUncheckedUpdateManyWithoutProjetoNestedInput
    recursos?: recursoUncheckedUpdateManyWithoutProjetoNestedInput
    anexos?: anexoProjetoUncheckedUpdateManyWithoutProjetoNestedInput
    permissoes?: permissaoProjetoUncheckedUpdateManyWithoutProjetoNestedInput
  }

  export type usuarioUpsertWithoutProjetoUsuariosInput = {
    update: XOR<usuarioUpdateWithoutProjetoUsuariosInput, usuarioUncheckedUpdateWithoutProjetoUsuariosInput>
    create: XOR<usuarioCreateWithoutProjetoUsuariosInput, usuarioUncheckedCreateWithoutProjetoUsuariosInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutProjetoUsuariosInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutProjetoUsuariosInput, usuarioUncheckedUpdateWithoutProjetoUsuariosInput>
  }

  export type usuarioUpdateWithoutProjetoUsuariosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    roule?: NullableStringFieldUpdateOperationsInput | string | null
    login?: loginUpdateOneRequiredWithoutUsuarioNestedInput
    habilidades?: habilidadeUsuarioUpdateManyWithoutUsuarioNestedInput
    permissoes?: permissaoUpdateManyWithoutUsuarioNestedInput
    permissoesProjeto?: permissaoProjetoUpdateManyWithoutUsuarioNestedInput
    participacoes?: participacaoTarefaUpdateManyWithoutUsuariosNestedInput
    comentarios?: comentarioUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutProjetoUsuariosInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    roule?: NullableStringFieldUpdateOperationsInput | string | null
    login_id?: IntFieldUpdateOperationsInput | number
    habilidades?: habilidadeUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    permissoes?: permissaoUncheckedUpdateManyWithoutUsuarioNestedInput
    permissoesProjeto?: permissaoProjetoUncheckedUpdateManyWithoutUsuarioNestedInput
    participacoes?: participacaoTarefaUncheckedUpdateManyWithoutUsuariosNestedInput
    comentarios?: comentarioUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type participacaoTarefaUpsertWithWhereUniqueWithoutProjetoUsuarioInput = {
    where: participacaoTarefaWhereUniqueInput
    update: XOR<participacaoTarefaUpdateWithoutProjetoUsuarioInput, participacaoTarefaUncheckedUpdateWithoutProjetoUsuarioInput>
    create: XOR<participacaoTarefaCreateWithoutProjetoUsuarioInput, participacaoTarefaUncheckedCreateWithoutProjetoUsuarioInput>
  }

  export type participacaoTarefaUpdateWithWhereUniqueWithoutProjetoUsuarioInput = {
    where: participacaoTarefaWhereUniqueInput
    data: XOR<participacaoTarefaUpdateWithoutProjetoUsuarioInput, participacaoTarefaUncheckedUpdateWithoutProjetoUsuarioInput>
  }

  export type participacaoTarefaUpdateManyWithWhereWithoutProjetoUsuarioInput = {
    where: participacaoTarefaScalarWhereInput
    data: XOR<participacaoTarefaUpdateManyMutationInput, participacaoTarefaUncheckedUpdateManyWithoutProjetoUsuarioInput>
  }

  export type projetoCreateWithoutTecnologiasInput = {
    nome: string
    descricao: string
    created_at?: Date | string
    conclude_at?: Date | string | null
    projetoUsuarios?: projetoUsuarioCreateNestedManyWithoutProjetoInput
    recursos?: recursoCreateNestedManyWithoutProjetoInput
    anexos?: anexoProjetoCreateNestedManyWithoutProjetoInput
    permissoes?: permissaoProjetoCreateNestedManyWithoutProjetoInput
  }

  export type projetoUncheckedCreateWithoutTecnologiasInput = {
    projeto_id?: number
    nome: string
    descricao: string
    created_at?: Date | string
    conclude_at?: Date | string | null
    projetoUsuarios?: projetoUsuarioUncheckedCreateNestedManyWithoutProjetoInput
    recursos?: recursoUncheckedCreateNestedManyWithoutProjetoInput
    anexos?: anexoProjetoUncheckedCreateNestedManyWithoutProjetoInput
    permissoes?: permissaoProjetoUncheckedCreateNestedManyWithoutProjetoInput
  }

  export type projetoCreateOrConnectWithoutTecnologiasInput = {
    where: projetoWhereUniqueInput
    create: XOR<projetoCreateWithoutTecnologiasInput, projetoUncheckedCreateWithoutTecnologiasInput>
  }

  export type tecnologiaCreateWithoutProjetosInput = {
    descricao: string
    habilidades?: habilidadeUsuarioCreateNestedManyWithoutTecnologiaInput
  }

  export type tecnologiaUncheckedCreateWithoutProjetosInput = {
    tecnologia_id?: number
    descricao: string
    habilidades?: habilidadeUsuarioUncheckedCreateNestedManyWithoutTecnologiaInput
  }

  export type tecnologiaCreateOrConnectWithoutProjetosInput = {
    where: tecnologiaWhereUniqueInput
    create: XOR<tecnologiaCreateWithoutProjetosInput, tecnologiaUncheckedCreateWithoutProjetosInput>
  }

  export type projetoUpsertWithoutTecnologiasInput = {
    update: XOR<projetoUpdateWithoutTecnologiasInput, projetoUncheckedUpdateWithoutTecnologiasInput>
    create: XOR<projetoCreateWithoutTecnologiasInput, projetoUncheckedCreateWithoutTecnologiasInput>
    where?: projetoWhereInput
  }

  export type projetoUpdateToOneWithWhereWithoutTecnologiasInput = {
    where?: projetoWhereInput
    data: XOR<projetoUpdateWithoutTecnologiasInput, projetoUncheckedUpdateWithoutTecnologiasInput>
  }

  export type projetoUpdateWithoutTecnologiasInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    conclude_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projetoUsuarios?: projetoUsuarioUpdateManyWithoutProjetoNestedInput
    recursos?: recursoUpdateManyWithoutProjetoNestedInput
    anexos?: anexoProjetoUpdateManyWithoutProjetoNestedInput
    permissoes?: permissaoProjetoUpdateManyWithoutProjetoNestedInput
  }

  export type projetoUncheckedUpdateWithoutTecnologiasInput = {
    projeto_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    conclude_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projetoUsuarios?: projetoUsuarioUncheckedUpdateManyWithoutProjetoNestedInput
    recursos?: recursoUncheckedUpdateManyWithoutProjetoNestedInput
    anexos?: anexoProjetoUncheckedUpdateManyWithoutProjetoNestedInput
    permissoes?: permissaoProjetoUncheckedUpdateManyWithoutProjetoNestedInput
  }

  export type tecnologiaUpsertWithoutProjetosInput = {
    update: XOR<tecnologiaUpdateWithoutProjetosInput, tecnologiaUncheckedUpdateWithoutProjetosInput>
    create: XOR<tecnologiaCreateWithoutProjetosInput, tecnologiaUncheckedCreateWithoutProjetosInput>
    where?: tecnologiaWhereInput
  }

  export type tecnologiaUpdateToOneWithWhereWithoutProjetosInput = {
    where?: tecnologiaWhereInput
    data: XOR<tecnologiaUpdateWithoutProjetosInput, tecnologiaUncheckedUpdateWithoutProjetosInput>
  }

  export type tecnologiaUpdateWithoutProjetosInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    habilidades?: habilidadeUsuarioUpdateManyWithoutTecnologiaNestedInput
  }

  export type tecnologiaUncheckedUpdateWithoutProjetosInput = {
    tecnologia_id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    habilidades?: habilidadeUsuarioUncheckedUpdateManyWithoutTecnologiaNestedInput
  }

  export type usuarioCreateWithoutHabilidadesInput = {
    nome: string
    created_at?: Date | string
    roule?: string | null
    login: loginCreateNestedOneWithoutUsuarioInput
    projetoUsuarios?: projetoUsuarioCreateNestedManyWithoutUsuarioInput
    permissoes?: permissaoCreateNestedManyWithoutUsuarioInput
    permissoesProjeto?: permissaoProjetoCreateNestedManyWithoutUsuarioInput
    participacoes?: participacaoTarefaCreateNestedManyWithoutUsuariosInput
    comentarios?: comentarioCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutHabilidadesInput = {
    usuario_id?: number
    nome: string
    created_at?: Date | string
    roule?: string | null
    login_id: number
    projetoUsuarios?: projetoUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    permissoes?: permissaoUncheckedCreateNestedManyWithoutUsuarioInput
    permissoesProjeto?: permissaoProjetoUncheckedCreateNestedManyWithoutUsuarioInput
    participacoes?: participacaoTarefaUncheckedCreateNestedManyWithoutUsuariosInput
    comentarios?: comentarioUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutHabilidadesInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutHabilidadesInput, usuarioUncheckedCreateWithoutHabilidadesInput>
  }

  export type tecnologiaCreateWithoutHabilidadesInput = {
    descricao: string
    projetos?: projetoTecnologiaCreateNestedManyWithoutTecnologiaInput
  }

  export type tecnologiaUncheckedCreateWithoutHabilidadesInput = {
    tecnologia_id?: number
    descricao: string
    projetos?: projetoTecnologiaUncheckedCreateNestedManyWithoutTecnologiaInput
  }

  export type tecnologiaCreateOrConnectWithoutHabilidadesInput = {
    where: tecnologiaWhereUniqueInput
    create: XOR<tecnologiaCreateWithoutHabilidadesInput, tecnologiaUncheckedCreateWithoutHabilidadesInput>
  }

  export type usuarioUpsertWithoutHabilidadesInput = {
    update: XOR<usuarioUpdateWithoutHabilidadesInput, usuarioUncheckedUpdateWithoutHabilidadesInput>
    create: XOR<usuarioCreateWithoutHabilidadesInput, usuarioUncheckedCreateWithoutHabilidadesInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutHabilidadesInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutHabilidadesInput, usuarioUncheckedUpdateWithoutHabilidadesInput>
  }

  export type usuarioUpdateWithoutHabilidadesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    roule?: NullableStringFieldUpdateOperationsInput | string | null
    login?: loginUpdateOneRequiredWithoutUsuarioNestedInput
    projetoUsuarios?: projetoUsuarioUpdateManyWithoutUsuarioNestedInput
    permissoes?: permissaoUpdateManyWithoutUsuarioNestedInput
    permissoesProjeto?: permissaoProjetoUpdateManyWithoutUsuarioNestedInput
    participacoes?: participacaoTarefaUpdateManyWithoutUsuariosNestedInput
    comentarios?: comentarioUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutHabilidadesInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    roule?: NullableStringFieldUpdateOperationsInput | string | null
    login_id?: IntFieldUpdateOperationsInput | number
    projetoUsuarios?: projetoUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    permissoes?: permissaoUncheckedUpdateManyWithoutUsuarioNestedInput
    permissoesProjeto?: permissaoProjetoUncheckedUpdateManyWithoutUsuarioNestedInput
    participacoes?: participacaoTarefaUncheckedUpdateManyWithoutUsuariosNestedInput
    comentarios?: comentarioUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type tecnologiaUpsertWithoutHabilidadesInput = {
    update: XOR<tecnologiaUpdateWithoutHabilidadesInput, tecnologiaUncheckedUpdateWithoutHabilidadesInput>
    create: XOR<tecnologiaCreateWithoutHabilidadesInput, tecnologiaUncheckedCreateWithoutHabilidadesInput>
    where?: tecnologiaWhereInput
  }

  export type tecnologiaUpdateToOneWithWhereWithoutHabilidadesInput = {
    where?: tecnologiaWhereInput
    data: XOR<tecnologiaUpdateWithoutHabilidadesInput, tecnologiaUncheckedUpdateWithoutHabilidadesInput>
  }

  export type tecnologiaUpdateWithoutHabilidadesInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    projetos?: projetoTecnologiaUpdateManyWithoutTecnologiaNestedInput
  }

  export type tecnologiaUncheckedUpdateWithoutHabilidadesInput = {
    tecnologia_id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    projetos?: projetoTecnologiaUncheckedUpdateManyWithoutTecnologiaNestedInput
  }

  export type projetoCreateWithoutRecursosInput = {
    nome: string
    descricao: string
    created_at?: Date | string
    conclude_at?: Date | string | null
    projetoUsuarios?: projetoUsuarioCreateNestedManyWithoutProjetoInput
    tecnologias?: projetoTecnologiaCreateNestedManyWithoutProjetoInput
    anexos?: anexoProjetoCreateNestedManyWithoutProjetoInput
    permissoes?: permissaoProjetoCreateNestedManyWithoutProjetoInput
  }

  export type projetoUncheckedCreateWithoutRecursosInput = {
    projeto_id?: number
    nome: string
    descricao: string
    created_at?: Date | string
    conclude_at?: Date | string | null
    projetoUsuarios?: projetoUsuarioUncheckedCreateNestedManyWithoutProjetoInput
    tecnologias?: projetoTecnologiaUncheckedCreateNestedManyWithoutProjetoInput
    anexos?: anexoProjetoUncheckedCreateNestedManyWithoutProjetoInput
    permissoes?: permissaoProjetoUncheckedCreateNestedManyWithoutProjetoInput
  }

  export type projetoCreateOrConnectWithoutRecursosInput = {
    where: projetoWhereUniqueInput
    create: XOR<projetoCreateWithoutRecursosInput, projetoUncheckedCreateWithoutRecursosInput>
  }

  export type projetoUpsertWithoutRecursosInput = {
    update: XOR<projetoUpdateWithoutRecursosInput, projetoUncheckedUpdateWithoutRecursosInput>
    create: XOR<projetoCreateWithoutRecursosInput, projetoUncheckedCreateWithoutRecursosInput>
    where?: projetoWhereInput
  }

  export type projetoUpdateToOneWithWhereWithoutRecursosInput = {
    where?: projetoWhereInput
    data: XOR<projetoUpdateWithoutRecursosInput, projetoUncheckedUpdateWithoutRecursosInput>
  }

  export type projetoUpdateWithoutRecursosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    conclude_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projetoUsuarios?: projetoUsuarioUpdateManyWithoutProjetoNestedInput
    tecnologias?: projetoTecnologiaUpdateManyWithoutProjetoNestedInput
    anexos?: anexoProjetoUpdateManyWithoutProjetoNestedInput
    permissoes?: permissaoProjetoUpdateManyWithoutProjetoNestedInput
  }

  export type projetoUncheckedUpdateWithoutRecursosInput = {
    projeto_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    conclude_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projetoUsuarios?: projetoUsuarioUncheckedUpdateManyWithoutProjetoNestedInput
    tecnologias?: projetoTecnologiaUncheckedUpdateManyWithoutProjetoNestedInput
    anexos?: anexoProjetoUncheckedUpdateManyWithoutProjetoNestedInput
    permissoes?: permissaoProjetoUncheckedUpdateManyWithoutProjetoNestedInput
  }

  export type projetoCreateWithoutAnexosInput = {
    nome: string
    descricao: string
    created_at?: Date | string
    conclude_at?: Date | string | null
    projetoUsuarios?: projetoUsuarioCreateNestedManyWithoutProjetoInput
    tecnologias?: projetoTecnologiaCreateNestedManyWithoutProjetoInput
    recursos?: recursoCreateNestedManyWithoutProjetoInput
    permissoes?: permissaoProjetoCreateNestedManyWithoutProjetoInput
  }

  export type projetoUncheckedCreateWithoutAnexosInput = {
    projeto_id?: number
    nome: string
    descricao: string
    created_at?: Date | string
    conclude_at?: Date | string | null
    projetoUsuarios?: projetoUsuarioUncheckedCreateNestedManyWithoutProjetoInput
    tecnologias?: projetoTecnologiaUncheckedCreateNestedManyWithoutProjetoInput
    recursos?: recursoUncheckedCreateNestedManyWithoutProjetoInput
    permissoes?: permissaoProjetoUncheckedCreateNestedManyWithoutProjetoInput
  }

  export type projetoCreateOrConnectWithoutAnexosInput = {
    where: projetoWhereUniqueInput
    create: XOR<projetoCreateWithoutAnexosInput, projetoUncheckedCreateWithoutAnexosInput>
  }

  export type projetoUpsertWithoutAnexosInput = {
    update: XOR<projetoUpdateWithoutAnexosInput, projetoUncheckedUpdateWithoutAnexosInput>
    create: XOR<projetoCreateWithoutAnexosInput, projetoUncheckedCreateWithoutAnexosInput>
    where?: projetoWhereInput
  }

  export type projetoUpdateToOneWithWhereWithoutAnexosInput = {
    where?: projetoWhereInput
    data: XOR<projetoUpdateWithoutAnexosInput, projetoUncheckedUpdateWithoutAnexosInput>
  }

  export type projetoUpdateWithoutAnexosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    conclude_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projetoUsuarios?: projetoUsuarioUpdateManyWithoutProjetoNestedInput
    tecnologias?: projetoTecnologiaUpdateManyWithoutProjetoNestedInput
    recursos?: recursoUpdateManyWithoutProjetoNestedInput
    permissoes?: permissaoProjetoUpdateManyWithoutProjetoNestedInput
  }

  export type projetoUncheckedUpdateWithoutAnexosInput = {
    projeto_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    conclude_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projetoUsuarios?: projetoUsuarioUncheckedUpdateManyWithoutProjetoNestedInput
    tecnologias?: projetoTecnologiaUncheckedUpdateManyWithoutProjetoNestedInput
    recursos?: recursoUncheckedUpdateManyWithoutProjetoNestedInput
    permissoes?: permissaoProjetoUncheckedUpdateManyWithoutProjetoNestedInput
  }

  export type tarefaCreateWithoutParticipacoesInput = {
    titulo: string
    descricao: string
    createdAt?: Date | string
    doing?: Date | string | null
    concludeAt?: Date | string | null
    colorBar?: string
    anexos?: anexoTarefaCreateNestedManyWithoutTarefaInput
    pausas?: pausaTarefaCreateNestedManyWithoutTarefaInput
  }

  export type tarefaUncheckedCreateWithoutParticipacoesInput = {
    tarefa_id?: number
    titulo: string
    descricao: string
    createdAt?: Date | string
    doing?: Date | string | null
    concludeAt?: Date | string | null
    colorBar?: string
    anexos?: anexoTarefaUncheckedCreateNestedManyWithoutTarefaInput
    pausas?: pausaTarefaUncheckedCreateNestedManyWithoutTarefaInput
  }

  export type tarefaCreateOrConnectWithoutParticipacoesInput = {
    where: tarefaWhereUniqueInput
    create: XOR<tarefaCreateWithoutParticipacoesInput, tarefaUncheckedCreateWithoutParticipacoesInput>
  }

  export type projetoUsuarioCreateWithoutParticipacoesInput = {
    owner?: boolean
    projeto: projetoCreateNestedOneWithoutProjetoUsuariosInput
    usuario: usuarioCreateNestedOneWithoutProjetoUsuariosInput
  }

  export type projetoUsuarioUncheckedCreateWithoutParticipacoesInput = {
    projetoUsuario_id?: number
    projeto_id: number
    usuario_id: number
    owner?: boolean
  }

  export type projetoUsuarioCreateOrConnectWithoutParticipacoesInput = {
    where: projetoUsuarioWhereUniqueInput
    create: XOR<projetoUsuarioCreateWithoutParticipacoesInput, projetoUsuarioUncheckedCreateWithoutParticipacoesInput>
  }

  export type comentarioCreateWithoutParticipacaoTarefaInput = {
    comentario: string
    data_hora?: Date | string
    usuario: usuarioCreateNestedOneWithoutComentariosInput
    anexos?: anexoComentarioCreateNestedManyWithoutComentarioInput
  }

  export type comentarioUncheckedCreateWithoutParticipacaoTarefaInput = {
    comentario_id?: number
    comentario: string
    data_hora?: Date | string
    usuario_id: number
    anexos?: anexoComentarioUncheckedCreateNestedManyWithoutComentarioInput
  }

  export type comentarioCreateOrConnectWithoutParticipacaoTarefaInput = {
    where: comentarioWhereUniqueInput
    create: XOR<comentarioCreateWithoutParticipacaoTarefaInput, comentarioUncheckedCreateWithoutParticipacaoTarefaInput>
  }

  export type comentarioCreateManyParticipacaoTarefaInputEnvelope = {
    data: comentarioCreateManyParticipacaoTarefaInput | comentarioCreateManyParticipacaoTarefaInput[]
    skipDuplicates?: boolean
  }

  export type usuarioCreateWithoutParticipacoesInput = {
    nome: string
    created_at?: Date | string
    roule?: string | null
    login: loginCreateNestedOneWithoutUsuarioInput
    projetoUsuarios?: projetoUsuarioCreateNestedManyWithoutUsuarioInput
    habilidades?: habilidadeUsuarioCreateNestedManyWithoutUsuarioInput
    permissoes?: permissaoCreateNestedManyWithoutUsuarioInput
    permissoesProjeto?: permissaoProjetoCreateNestedManyWithoutUsuarioInput
    comentarios?: comentarioCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutParticipacoesInput = {
    usuario_id?: number
    nome: string
    created_at?: Date | string
    roule?: string | null
    login_id: number
    projetoUsuarios?: projetoUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    habilidades?: habilidadeUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    permissoes?: permissaoUncheckedCreateNestedManyWithoutUsuarioInput
    permissoesProjeto?: permissaoProjetoUncheckedCreateNestedManyWithoutUsuarioInput
    comentarios?: comentarioUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutParticipacoesInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutParticipacoesInput, usuarioUncheckedCreateWithoutParticipacoesInput>
  }

  export type tarefaUpsertWithoutParticipacoesInput = {
    update: XOR<tarefaUpdateWithoutParticipacoesInput, tarefaUncheckedUpdateWithoutParticipacoesInput>
    create: XOR<tarefaCreateWithoutParticipacoesInput, tarefaUncheckedCreateWithoutParticipacoesInput>
    where?: tarefaWhereInput
  }

  export type tarefaUpdateToOneWithWhereWithoutParticipacoesInput = {
    where?: tarefaWhereInput
    data: XOR<tarefaUpdateWithoutParticipacoesInput, tarefaUncheckedUpdateWithoutParticipacoesInput>
  }

  export type tarefaUpdateWithoutParticipacoesInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doing?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    colorBar?: StringFieldUpdateOperationsInput | string
    anexos?: anexoTarefaUpdateManyWithoutTarefaNestedInput
    pausas?: pausaTarefaUpdateManyWithoutTarefaNestedInput
  }

  export type tarefaUncheckedUpdateWithoutParticipacoesInput = {
    tarefa_id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doing?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    colorBar?: StringFieldUpdateOperationsInput | string
    anexos?: anexoTarefaUncheckedUpdateManyWithoutTarefaNestedInput
    pausas?: pausaTarefaUncheckedUpdateManyWithoutTarefaNestedInput
  }

  export type projetoUsuarioUpsertWithoutParticipacoesInput = {
    update: XOR<projetoUsuarioUpdateWithoutParticipacoesInput, projetoUsuarioUncheckedUpdateWithoutParticipacoesInput>
    create: XOR<projetoUsuarioCreateWithoutParticipacoesInput, projetoUsuarioUncheckedCreateWithoutParticipacoesInput>
    where?: projetoUsuarioWhereInput
  }

  export type projetoUsuarioUpdateToOneWithWhereWithoutParticipacoesInput = {
    where?: projetoUsuarioWhereInput
    data: XOR<projetoUsuarioUpdateWithoutParticipacoesInput, projetoUsuarioUncheckedUpdateWithoutParticipacoesInput>
  }

  export type projetoUsuarioUpdateWithoutParticipacoesInput = {
    owner?: BoolFieldUpdateOperationsInput | boolean
    projeto?: projetoUpdateOneRequiredWithoutProjetoUsuariosNestedInput
    usuario?: usuarioUpdateOneRequiredWithoutProjetoUsuariosNestedInput
  }

  export type projetoUsuarioUncheckedUpdateWithoutParticipacoesInput = {
    projetoUsuario_id?: IntFieldUpdateOperationsInput | number
    projeto_id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    owner?: BoolFieldUpdateOperationsInput | boolean
  }

  export type comentarioUpsertWithWhereUniqueWithoutParticipacaoTarefaInput = {
    where: comentarioWhereUniqueInput
    update: XOR<comentarioUpdateWithoutParticipacaoTarefaInput, comentarioUncheckedUpdateWithoutParticipacaoTarefaInput>
    create: XOR<comentarioCreateWithoutParticipacaoTarefaInput, comentarioUncheckedCreateWithoutParticipacaoTarefaInput>
  }

  export type comentarioUpdateWithWhereUniqueWithoutParticipacaoTarefaInput = {
    where: comentarioWhereUniqueInput
    data: XOR<comentarioUpdateWithoutParticipacaoTarefaInput, comentarioUncheckedUpdateWithoutParticipacaoTarefaInput>
  }

  export type comentarioUpdateManyWithWhereWithoutParticipacaoTarefaInput = {
    where: comentarioScalarWhereInput
    data: XOR<comentarioUpdateManyMutationInput, comentarioUncheckedUpdateManyWithoutParticipacaoTarefaInput>
  }

  export type usuarioUpsertWithWhereUniqueWithoutParticipacoesInput = {
    where: usuarioWhereUniqueInput
    update: XOR<usuarioUpdateWithoutParticipacoesInput, usuarioUncheckedUpdateWithoutParticipacoesInput>
    create: XOR<usuarioCreateWithoutParticipacoesInput, usuarioUncheckedCreateWithoutParticipacoesInput>
  }

  export type usuarioUpdateWithWhereUniqueWithoutParticipacoesInput = {
    where: usuarioWhereUniqueInput
    data: XOR<usuarioUpdateWithoutParticipacoesInput, usuarioUncheckedUpdateWithoutParticipacoesInput>
  }

  export type usuarioUpdateManyWithWhereWithoutParticipacoesInput = {
    where: usuarioScalarWhereInput
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyWithoutParticipacoesInput>
  }

  export type usuarioScalarWhereInput = {
    AND?: usuarioScalarWhereInput | usuarioScalarWhereInput[]
    OR?: usuarioScalarWhereInput[]
    NOT?: usuarioScalarWhereInput | usuarioScalarWhereInput[]
    usuario_id?: IntFilter<"usuario"> | number
    nome?: StringFilter<"usuario"> | string
    created_at?: DateTimeFilter<"usuario"> | Date | string
    roule?: StringNullableFilter<"usuario"> | string | null
    login_id?: IntFilter<"usuario"> | number
  }

  export type participacaoTarefaCreateWithoutComentariosInput = {
    tarefa: tarefaCreateNestedOneWithoutParticipacoesInput
    projetoUsuario: projetoUsuarioCreateNestedOneWithoutParticipacoesInput
    usuarios?: usuarioCreateNestedManyWithoutParticipacoesInput
  }

  export type participacaoTarefaUncheckedCreateWithoutComentariosInput = {
    participacaoTarefa_id?: number
    tarefa_id: number
    projetoUsuario_id: number
    usuarios?: usuarioUncheckedCreateNestedManyWithoutParticipacoesInput
  }

  export type participacaoTarefaCreateOrConnectWithoutComentariosInput = {
    where: participacaoTarefaWhereUniqueInput
    create: XOR<participacaoTarefaCreateWithoutComentariosInput, participacaoTarefaUncheckedCreateWithoutComentariosInput>
  }

  export type usuarioCreateWithoutComentariosInput = {
    nome: string
    created_at?: Date | string
    roule?: string | null
    login: loginCreateNestedOneWithoutUsuarioInput
    projetoUsuarios?: projetoUsuarioCreateNestedManyWithoutUsuarioInput
    habilidades?: habilidadeUsuarioCreateNestedManyWithoutUsuarioInput
    permissoes?: permissaoCreateNestedManyWithoutUsuarioInput
    permissoesProjeto?: permissaoProjetoCreateNestedManyWithoutUsuarioInput
    participacoes?: participacaoTarefaCreateNestedManyWithoutUsuariosInput
  }

  export type usuarioUncheckedCreateWithoutComentariosInput = {
    usuario_id?: number
    nome: string
    created_at?: Date | string
    roule?: string | null
    login_id: number
    projetoUsuarios?: projetoUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    habilidades?: habilidadeUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    permissoes?: permissaoUncheckedCreateNestedManyWithoutUsuarioInput
    permissoesProjeto?: permissaoProjetoUncheckedCreateNestedManyWithoutUsuarioInput
    participacoes?: participacaoTarefaUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type usuarioCreateOrConnectWithoutComentariosInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutComentariosInput, usuarioUncheckedCreateWithoutComentariosInput>
  }

  export type anexoComentarioCreateWithoutComentarioInput = {
    anexoTarefa: anexoTarefaCreateNestedOneWithoutAnexosComentarioInput
  }

  export type anexoComentarioUncheckedCreateWithoutComentarioInput = {
    anexoComentario_id?: number
    anexoTarefa_id: number
  }

  export type anexoComentarioCreateOrConnectWithoutComentarioInput = {
    where: anexoComentarioWhereUniqueInput
    create: XOR<anexoComentarioCreateWithoutComentarioInput, anexoComentarioUncheckedCreateWithoutComentarioInput>
  }

  export type anexoComentarioCreateManyComentarioInputEnvelope = {
    data: anexoComentarioCreateManyComentarioInput | anexoComentarioCreateManyComentarioInput[]
    skipDuplicates?: boolean
  }

  export type participacaoTarefaUpsertWithoutComentariosInput = {
    update: XOR<participacaoTarefaUpdateWithoutComentariosInput, participacaoTarefaUncheckedUpdateWithoutComentariosInput>
    create: XOR<participacaoTarefaCreateWithoutComentariosInput, participacaoTarefaUncheckedCreateWithoutComentariosInput>
    where?: participacaoTarefaWhereInput
  }

  export type participacaoTarefaUpdateToOneWithWhereWithoutComentariosInput = {
    where?: participacaoTarefaWhereInput
    data: XOR<participacaoTarefaUpdateWithoutComentariosInput, participacaoTarefaUncheckedUpdateWithoutComentariosInput>
  }

  export type participacaoTarefaUpdateWithoutComentariosInput = {
    tarefa?: tarefaUpdateOneRequiredWithoutParticipacoesNestedInput
    projetoUsuario?: projetoUsuarioUpdateOneRequiredWithoutParticipacoesNestedInput
    usuarios?: usuarioUpdateManyWithoutParticipacoesNestedInput
  }

  export type participacaoTarefaUncheckedUpdateWithoutComentariosInput = {
    participacaoTarefa_id?: IntFieldUpdateOperationsInput | number
    tarefa_id?: IntFieldUpdateOperationsInput | number
    projetoUsuario_id?: IntFieldUpdateOperationsInput | number
    usuarios?: usuarioUncheckedUpdateManyWithoutParticipacoesNestedInput
  }

  export type usuarioUpsertWithoutComentariosInput = {
    update: XOR<usuarioUpdateWithoutComentariosInput, usuarioUncheckedUpdateWithoutComentariosInput>
    create: XOR<usuarioCreateWithoutComentariosInput, usuarioUncheckedCreateWithoutComentariosInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutComentariosInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutComentariosInput, usuarioUncheckedUpdateWithoutComentariosInput>
  }

  export type usuarioUpdateWithoutComentariosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    roule?: NullableStringFieldUpdateOperationsInput | string | null
    login?: loginUpdateOneRequiredWithoutUsuarioNestedInput
    projetoUsuarios?: projetoUsuarioUpdateManyWithoutUsuarioNestedInput
    habilidades?: habilidadeUsuarioUpdateManyWithoutUsuarioNestedInput
    permissoes?: permissaoUpdateManyWithoutUsuarioNestedInput
    permissoesProjeto?: permissaoProjetoUpdateManyWithoutUsuarioNestedInput
    participacoes?: participacaoTarefaUpdateManyWithoutUsuariosNestedInput
  }

  export type usuarioUncheckedUpdateWithoutComentariosInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    roule?: NullableStringFieldUpdateOperationsInput | string | null
    login_id?: IntFieldUpdateOperationsInput | number
    projetoUsuarios?: projetoUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    habilidades?: habilidadeUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    permissoes?: permissaoUncheckedUpdateManyWithoutUsuarioNestedInput
    permissoesProjeto?: permissaoProjetoUncheckedUpdateManyWithoutUsuarioNestedInput
    participacoes?: participacaoTarefaUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type anexoComentarioUpsertWithWhereUniqueWithoutComentarioInput = {
    where: anexoComentarioWhereUniqueInput
    update: XOR<anexoComentarioUpdateWithoutComentarioInput, anexoComentarioUncheckedUpdateWithoutComentarioInput>
    create: XOR<anexoComentarioCreateWithoutComentarioInput, anexoComentarioUncheckedCreateWithoutComentarioInput>
  }

  export type anexoComentarioUpdateWithWhereUniqueWithoutComentarioInput = {
    where: anexoComentarioWhereUniqueInput
    data: XOR<anexoComentarioUpdateWithoutComentarioInput, anexoComentarioUncheckedUpdateWithoutComentarioInput>
  }

  export type anexoComentarioUpdateManyWithWhereWithoutComentarioInput = {
    where: anexoComentarioScalarWhereInput
    data: XOR<anexoComentarioUpdateManyMutationInput, anexoComentarioUncheckedUpdateManyWithoutComentarioInput>
  }

  export type anexoComentarioScalarWhereInput = {
    AND?: anexoComentarioScalarWhereInput | anexoComentarioScalarWhereInput[]
    OR?: anexoComentarioScalarWhereInput[]
    NOT?: anexoComentarioScalarWhereInput | anexoComentarioScalarWhereInput[]
    anexoComentario_id?: IntFilter<"anexoComentario"> | number
    comentario_id?: IntFilter<"anexoComentario"> | number
    anexoTarefa_id?: IntFilter<"anexoComentario"> | number
  }

  export type tarefaCreateWithoutAnexosInput = {
    titulo: string
    descricao: string
    createdAt?: Date | string
    doing?: Date | string | null
    concludeAt?: Date | string | null
    colorBar?: string
    participacoes?: participacaoTarefaCreateNestedManyWithoutTarefaInput
    pausas?: pausaTarefaCreateNestedManyWithoutTarefaInput
  }

  export type tarefaUncheckedCreateWithoutAnexosInput = {
    tarefa_id?: number
    titulo: string
    descricao: string
    createdAt?: Date | string
    doing?: Date | string | null
    concludeAt?: Date | string | null
    colorBar?: string
    participacoes?: participacaoTarefaUncheckedCreateNestedManyWithoutTarefaInput
    pausas?: pausaTarefaUncheckedCreateNestedManyWithoutTarefaInput
  }

  export type tarefaCreateOrConnectWithoutAnexosInput = {
    where: tarefaWhereUniqueInput
    create: XOR<tarefaCreateWithoutAnexosInput, tarefaUncheckedCreateWithoutAnexosInput>
  }

  export type anexoComentarioCreateWithoutAnexoTarefaInput = {
    comentario: comentarioCreateNestedOneWithoutAnexosInput
  }

  export type anexoComentarioUncheckedCreateWithoutAnexoTarefaInput = {
    anexoComentario_id?: number
    comentario_id: number
  }

  export type anexoComentarioCreateOrConnectWithoutAnexoTarefaInput = {
    where: anexoComentarioWhereUniqueInput
    create: XOR<anexoComentarioCreateWithoutAnexoTarefaInput, anexoComentarioUncheckedCreateWithoutAnexoTarefaInput>
  }

  export type anexoComentarioCreateManyAnexoTarefaInputEnvelope = {
    data: anexoComentarioCreateManyAnexoTarefaInput | anexoComentarioCreateManyAnexoTarefaInput[]
    skipDuplicates?: boolean
  }

  export type tarefaUpsertWithoutAnexosInput = {
    update: XOR<tarefaUpdateWithoutAnexosInput, tarefaUncheckedUpdateWithoutAnexosInput>
    create: XOR<tarefaCreateWithoutAnexosInput, tarefaUncheckedCreateWithoutAnexosInput>
    where?: tarefaWhereInput
  }

  export type tarefaUpdateToOneWithWhereWithoutAnexosInput = {
    where?: tarefaWhereInput
    data: XOR<tarefaUpdateWithoutAnexosInput, tarefaUncheckedUpdateWithoutAnexosInput>
  }

  export type tarefaUpdateWithoutAnexosInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doing?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    colorBar?: StringFieldUpdateOperationsInput | string
    participacoes?: participacaoTarefaUpdateManyWithoutTarefaNestedInput
    pausas?: pausaTarefaUpdateManyWithoutTarefaNestedInput
  }

  export type tarefaUncheckedUpdateWithoutAnexosInput = {
    tarefa_id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doing?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    colorBar?: StringFieldUpdateOperationsInput | string
    participacoes?: participacaoTarefaUncheckedUpdateManyWithoutTarefaNestedInput
    pausas?: pausaTarefaUncheckedUpdateManyWithoutTarefaNestedInput
  }

  export type anexoComentarioUpsertWithWhereUniqueWithoutAnexoTarefaInput = {
    where: anexoComentarioWhereUniqueInput
    update: XOR<anexoComentarioUpdateWithoutAnexoTarefaInput, anexoComentarioUncheckedUpdateWithoutAnexoTarefaInput>
    create: XOR<anexoComentarioCreateWithoutAnexoTarefaInput, anexoComentarioUncheckedCreateWithoutAnexoTarefaInput>
  }

  export type anexoComentarioUpdateWithWhereUniqueWithoutAnexoTarefaInput = {
    where: anexoComentarioWhereUniqueInput
    data: XOR<anexoComentarioUpdateWithoutAnexoTarefaInput, anexoComentarioUncheckedUpdateWithoutAnexoTarefaInput>
  }

  export type anexoComentarioUpdateManyWithWhereWithoutAnexoTarefaInput = {
    where: anexoComentarioScalarWhereInput
    data: XOR<anexoComentarioUpdateManyMutationInput, anexoComentarioUncheckedUpdateManyWithoutAnexoTarefaInput>
  }

  export type comentarioCreateWithoutAnexosInput = {
    comentario: string
    data_hora?: Date | string
    participacaoTarefa: participacaoTarefaCreateNestedOneWithoutComentariosInput
    usuario: usuarioCreateNestedOneWithoutComentariosInput
  }

  export type comentarioUncheckedCreateWithoutAnexosInput = {
    comentario_id?: number
    comentario: string
    data_hora?: Date | string
    participacaoTarefa_id: number
    usuario_id: number
  }

  export type comentarioCreateOrConnectWithoutAnexosInput = {
    where: comentarioWhereUniqueInput
    create: XOR<comentarioCreateWithoutAnexosInput, comentarioUncheckedCreateWithoutAnexosInput>
  }

  export type anexoTarefaCreateWithoutAnexosComentarioInput = {
    nome: string
    tipo: string
    conteudo: Buffer
    created_at?: Date | string
    tarefa: tarefaCreateNestedOneWithoutAnexosInput
  }

  export type anexoTarefaUncheckedCreateWithoutAnexosComentarioInput = {
    anexoTarefa_id?: number
    nome: string
    tipo: string
    conteudo: Buffer
    created_at?: Date | string
    tarefa_id: number
  }

  export type anexoTarefaCreateOrConnectWithoutAnexosComentarioInput = {
    where: anexoTarefaWhereUniqueInput
    create: XOR<anexoTarefaCreateWithoutAnexosComentarioInput, anexoTarefaUncheckedCreateWithoutAnexosComentarioInput>
  }

  export type comentarioUpsertWithoutAnexosInput = {
    update: XOR<comentarioUpdateWithoutAnexosInput, comentarioUncheckedUpdateWithoutAnexosInput>
    create: XOR<comentarioCreateWithoutAnexosInput, comentarioUncheckedCreateWithoutAnexosInput>
    where?: comentarioWhereInput
  }

  export type comentarioUpdateToOneWithWhereWithoutAnexosInput = {
    where?: comentarioWhereInput
    data: XOR<comentarioUpdateWithoutAnexosInput, comentarioUncheckedUpdateWithoutAnexosInput>
  }

  export type comentarioUpdateWithoutAnexosInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    participacaoTarefa?: participacaoTarefaUpdateOneRequiredWithoutComentariosNestedInput
    usuario?: usuarioUpdateOneRequiredWithoutComentariosNestedInput
  }

  export type comentarioUncheckedUpdateWithoutAnexosInput = {
    comentario_id?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    participacaoTarefa_id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type anexoTarefaUpsertWithoutAnexosComentarioInput = {
    update: XOR<anexoTarefaUpdateWithoutAnexosComentarioInput, anexoTarefaUncheckedUpdateWithoutAnexosComentarioInput>
    create: XOR<anexoTarefaCreateWithoutAnexosComentarioInput, anexoTarefaUncheckedCreateWithoutAnexosComentarioInput>
    where?: anexoTarefaWhereInput
  }

  export type anexoTarefaUpdateToOneWithWhereWithoutAnexosComentarioInput = {
    where?: anexoTarefaWhereInput
    data: XOR<anexoTarefaUpdateWithoutAnexosComentarioInput, anexoTarefaUncheckedUpdateWithoutAnexosComentarioInput>
  }

  export type anexoTarefaUpdateWithoutAnexosComentarioInput = {
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    conteudo?: BytesFieldUpdateOperationsInput | Buffer
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tarefa?: tarefaUpdateOneRequiredWithoutAnexosNestedInput
  }

  export type anexoTarefaUncheckedUpdateWithoutAnexosComentarioInput = {
    anexoTarefa_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    conteudo?: BytesFieldUpdateOperationsInput | Buffer
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tarefa_id?: IntFieldUpdateOperationsInput | number
  }

  export type usuarioCreateWithoutPermissoesInput = {
    nome: string
    created_at?: Date | string
    roule?: string | null
    login: loginCreateNestedOneWithoutUsuarioInput
    projetoUsuarios?: projetoUsuarioCreateNestedManyWithoutUsuarioInput
    habilidades?: habilidadeUsuarioCreateNestedManyWithoutUsuarioInput
    permissoesProjeto?: permissaoProjetoCreateNestedManyWithoutUsuarioInput
    participacoes?: participacaoTarefaCreateNestedManyWithoutUsuariosInput
    comentarios?: comentarioCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutPermissoesInput = {
    usuario_id?: number
    nome: string
    created_at?: Date | string
    roule?: string | null
    login_id: number
    projetoUsuarios?: projetoUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    habilidades?: habilidadeUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    permissoesProjeto?: permissaoProjetoUncheckedCreateNestedManyWithoutUsuarioInput
    participacoes?: participacaoTarefaUncheckedCreateNestedManyWithoutUsuariosInput
    comentarios?: comentarioUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutPermissoesInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutPermissoesInput, usuarioUncheckedCreateWithoutPermissoesInput>
  }

  export type usuarioUpsertWithoutPermissoesInput = {
    update: XOR<usuarioUpdateWithoutPermissoesInput, usuarioUncheckedUpdateWithoutPermissoesInput>
    create: XOR<usuarioCreateWithoutPermissoesInput, usuarioUncheckedCreateWithoutPermissoesInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutPermissoesInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutPermissoesInput, usuarioUncheckedUpdateWithoutPermissoesInput>
  }

  export type usuarioUpdateWithoutPermissoesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    roule?: NullableStringFieldUpdateOperationsInput | string | null
    login?: loginUpdateOneRequiredWithoutUsuarioNestedInput
    projetoUsuarios?: projetoUsuarioUpdateManyWithoutUsuarioNestedInput
    habilidades?: habilidadeUsuarioUpdateManyWithoutUsuarioNestedInput
    permissoesProjeto?: permissaoProjetoUpdateManyWithoutUsuarioNestedInput
    participacoes?: participacaoTarefaUpdateManyWithoutUsuariosNestedInput
    comentarios?: comentarioUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutPermissoesInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    roule?: NullableStringFieldUpdateOperationsInput | string | null
    login_id?: IntFieldUpdateOperationsInput | number
    projetoUsuarios?: projetoUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    habilidades?: habilidadeUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    permissoesProjeto?: permissaoProjetoUncheckedUpdateManyWithoutUsuarioNestedInput
    participacoes?: participacaoTarefaUncheckedUpdateManyWithoutUsuariosNestedInput
    comentarios?: comentarioUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioCreateWithoutPermissoesProjetoInput = {
    nome: string
    created_at?: Date | string
    roule?: string | null
    login: loginCreateNestedOneWithoutUsuarioInput
    projetoUsuarios?: projetoUsuarioCreateNestedManyWithoutUsuarioInput
    habilidades?: habilidadeUsuarioCreateNestedManyWithoutUsuarioInput
    permissoes?: permissaoCreateNestedManyWithoutUsuarioInput
    participacoes?: participacaoTarefaCreateNestedManyWithoutUsuariosInput
    comentarios?: comentarioCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutPermissoesProjetoInput = {
    usuario_id?: number
    nome: string
    created_at?: Date | string
    roule?: string | null
    login_id: number
    projetoUsuarios?: projetoUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    habilidades?: habilidadeUsuarioUncheckedCreateNestedManyWithoutUsuarioInput
    permissoes?: permissaoUncheckedCreateNestedManyWithoutUsuarioInput
    participacoes?: participacaoTarefaUncheckedCreateNestedManyWithoutUsuariosInput
    comentarios?: comentarioUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutPermissoesProjetoInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutPermissoesProjetoInput, usuarioUncheckedCreateWithoutPermissoesProjetoInput>
  }

  export type projetoCreateWithoutPermissoesInput = {
    nome: string
    descricao: string
    created_at?: Date | string
    conclude_at?: Date | string | null
    projetoUsuarios?: projetoUsuarioCreateNestedManyWithoutProjetoInput
    tecnologias?: projetoTecnologiaCreateNestedManyWithoutProjetoInput
    recursos?: recursoCreateNestedManyWithoutProjetoInput
    anexos?: anexoProjetoCreateNestedManyWithoutProjetoInput
  }

  export type projetoUncheckedCreateWithoutPermissoesInput = {
    projeto_id?: number
    nome: string
    descricao: string
    created_at?: Date | string
    conclude_at?: Date | string | null
    projetoUsuarios?: projetoUsuarioUncheckedCreateNestedManyWithoutProjetoInput
    tecnologias?: projetoTecnologiaUncheckedCreateNestedManyWithoutProjetoInput
    recursos?: recursoUncheckedCreateNestedManyWithoutProjetoInput
    anexos?: anexoProjetoUncheckedCreateNestedManyWithoutProjetoInput
  }

  export type projetoCreateOrConnectWithoutPermissoesInput = {
    where: projetoWhereUniqueInput
    create: XOR<projetoCreateWithoutPermissoesInput, projetoUncheckedCreateWithoutPermissoesInput>
  }

  export type usuarioUpsertWithoutPermissoesProjetoInput = {
    update: XOR<usuarioUpdateWithoutPermissoesProjetoInput, usuarioUncheckedUpdateWithoutPermissoesProjetoInput>
    create: XOR<usuarioCreateWithoutPermissoesProjetoInput, usuarioUncheckedCreateWithoutPermissoesProjetoInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutPermissoesProjetoInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutPermissoesProjetoInput, usuarioUncheckedUpdateWithoutPermissoesProjetoInput>
  }

  export type usuarioUpdateWithoutPermissoesProjetoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    roule?: NullableStringFieldUpdateOperationsInput | string | null
    login?: loginUpdateOneRequiredWithoutUsuarioNestedInput
    projetoUsuarios?: projetoUsuarioUpdateManyWithoutUsuarioNestedInput
    habilidades?: habilidadeUsuarioUpdateManyWithoutUsuarioNestedInput
    permissoes?: permissaoUpdateManyWithoutUsuarioNestedInput
    participacoes?: participacaoTarefaUpdateManyWithoutUsuariosNestedInput
    comentarios?: comentarioUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutPermissoesProjetoInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    roule?: NullableStringFieldUpdateOperationsInput | string | null
    login_id?: IntFieldUpdateOperationsInput | number
    projetoUsuarios?: projetoUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    habilidades?: habilidadeUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    permissoes?: permissaoUncheckedUpdateManyWithoutUsuarioNestedInput
    participacoes?: participacaoTarefaUncheckedUpdateManyWithoutUsuariosNestedInput
    comentarios?: comentarioUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type projetoUpsertWithoutPermissoesInput = {
    update: XOR<projetoUpdateWithoutPermissoesInput, projetoUncheckedUpdateWithoutPermissoesInput>
    create: XOR<projetoCreateWithoutPermissoesInput, projetoUncheckedCreateWithoutPermissoesInput>
    where?: projetoWhereInput
  }

  export type projetoUpdateToOneWithWhereWithoutPermissoesInput = {
    where?: projetoWhereInput
    data: XOR<projetoUpdateWithoutPermissoesInput, projetoUncheckedUpdateWithoutPermissoesInput>
  }

  export type projetoUpdateWithoutPermissoesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    conclude_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projetoUsuarios?: projetoUsuarioUpdateManyWithoutProjetoNestedInput
    tecnologias?: projetoTecnologiaUpdateManyWithoutProjetoNestedInput
    recursos?: recursoUpdateManyWithoutProjetoNestedInput
    anexos?: anexoProjetoUpdateManyWithoutProjetoNestedInput
  }

  export type projetoUncheckedUpdateWithoutPermissoesInput = {
    projeto_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    conclude_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    projetoUsuarios?: projetoUsuarioUncheckedUpdateManyWithoutProjetoNestedInput
    tecnologias?: projetoTecnologiaUncheckedUpdateManyWithoutProjetoNestedInput
    recursos?: recursoUncheckedUpdateManyWithoutProjetoNestedInput
    anexos?: anexoProjetoUncheckedUpdateManyWithoutProjetoNestedInput
  }

  export type tarefaCreateWithoutPausasInput = {
    titulo: string
    descricao: string
    createdAt?: Date | string
    doing?: Date | string | null
    concludeAt?: Date | string | null
    colorBar?: string
    participacoes?: participacaoTarefaCreateNestedManyWithoutTarefaInput
    anexos?: anexoTarefaCreateNestedManyWithoutTarefaInput
  }

  export type tarefaUncheckedCreateWithoutPausasInput = {
    tarefa_id?: number
    titulo: string
    descricao: string
    createdAt?: Date | string
    doing?: Date | string | null
    concludeAt?: Date | string | null
    colorBar?: string
    participacoes?: participacaoTarefaUncheckedCreateNestedManyWithoutTarefaInput
    anexos?: anexoTarefaUncheckedCreateNestedManyWithoutTarefaInput
  }

  export type tarefaCreateOrConnectWithoutPausasInput = {
    where: tarefaWhereUniqueInput
    create: XOR<tarefaCreateWithoutPausasInput, tarefaUncheckedCreateWithoutPausasInput>
  }

  export type tarefaUpsertWithoutPausasInput = {
    update: XOR<tarefaUpdateWithoutPausasInput, tarefaUncheckedUpdateWithoutPausasInput>
    create: XOR<tarefaCreateWithoutPausasInput, tarefaUncheckedCreateWithoutPausasInput>
    where?: tarefaWhereInput
  }

  export type tarefaUpdateToOneWithWhereWithoutPausasInput = {
    where?: tarefaWhereInput
    data: XOR<tarefaUpdateWithoutPausasInput, tarefaUncheckedUpdateWithoutPausasInput>
  }

  export type tarefaUpdateWithoutPausasInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doing?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    colorBar?: StringFieldUpdateOperationsInput | string
    participacoes?: participacaoTarefaUpdateManyWithoutTarefaNestedInput
    anexos?: anexoTarefaUpdateManyWithoutTarefaNestedInput
  }

  export type tarefaUncheckedUpdateWithoutPausasInput = {
    tarefa_id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doing?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concludeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    colorBar?: StringFieldUpdateOperationsInput | string
    participacoes?: participacaoTarefaUncheckedUpdateManyWithoutTarefaNestedInput
    anexos?: anexoTarefaUncheckedUpdateManyWithoutTarefaNestedInput
  }

  export type projetoUsuarioCreateManyUsuarioInput = {
    projetoUsuario_id?: number
    projeto_id: number
    owner?: boolean
  }

  export type habilidadeUsuarioCreateManyUsuarioInput = {
    habilidadeUsuario_id?: number
    tecnologia_id: number
  }

  export type permissaoCreateManyUsuarioInput = {
    permissao_id?: number
    tipo: string
  }

  export type permissaoProjetoCreateManyUsuarioInput = {
    permissaoProjeto_id?: number
    tipo: string
    projeto_id: number
  }

  export type comentarioCreateManyUsuarioInput = {
    comentario_id?: number
    comentario: string
    data_hora?: Date | string
    participacaoTarefa_id: number
  }

  export type projetoUsuarioUpdateWithoutUsuarioInput = {
    owner?: BoolFieldUpdateOperationsInput | boolean
    projeto?: projetoUpdateOneRequiredWithoutProjetoUsuariosNestedInput
    participacoes?: participacaoTarefaUpdateManyWithoutProjetoUsuarioNestedInput
  }

  export type projetoUsuarioUncheckedUpdateWithoutUsuarioInput = {
    projetoUsuario_id?: IntFieldUpdateOperationsInput | number
    projeto_id?: IntFieldUpdateOperationsInput | number
    owner?: BoolFieldUpdateOperationsInput | boolean
    participacoes?: participacaoTarefaUncheckedUpdateManyWithoutProjetoUsuarioNestedInput
  }

  export type projetoUsuarioUncheckedUpdateManyWithoutUsuarioInput = {
    projetoUsuario_id?: IntFieldUpdateOperationsInput | number
    projeto_id?: IntFieldUpdateOperationsInput | number
    owner?: BoolFieldUpdateOperationsInput | boolean
  }

  export type habilidadeUsuarioUpdateWithoutUsuarioInput = {
    tecnologia?: tecnologiaUpdateOneRequiredWithoutHabilidadesNestedInput
  }

  export type habilidadeUsuarioUncheckedUpdateWithoutUsuarioInput = {
    habilidadeUsuario_id?: IntFieldUpdateOperationsInput | number
    tecnologia_id?: IntFieldUpdateOperationsInput | number
  }

  export type habilidadeUsuarioUncheckedUpdateManyWithoutUsuarioInput = {
    habilidadeUsuario_id?: IntFieldUpdateOperationsInput | number
    tecnologia_id?: IntFieldUpdateOperationsInput | number
  }

  export type permissaoUpdateWithoutUsuarioInput = {
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type permissaoUncheckedUpdateWithoutUsuarioInput = {
    permissao_id?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type permissaoUncheckedUpdateManyWithoutUsuarioInput = {
    permissao_id?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type permissaoProjetoUpdateWithoutUsuarioInput = {
    tipo?: StringFieldUpdateOperationsInput | string
    projeto?: projetoUpdateOneRequiredWithoutPermissoesNestedInput
  }

  export type permissaoProjetoUncheckedUpdateWithoutUsuarioInput = {
    permissaoProjeto_id?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    projeto_id?: IntFieldUpdateOperationsInput | number
  }

  export type permissaoProjetoUncheckedUpdateManyWithoutUsuarioInput = {
    permissaoProjeto_id?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    projeto_id?: IntFieldUpdateOperationsInput | number
  }

  export type participacaoTarefaUpdateWithoutUsuariosInput = {
    tarefa?: tarefaUpdateOneRequiredWithoutParticipacoesNestedInput
    projetoUsuario?: projetoUsuarioUpdateOneRequiredWithoutParticipacoesNestedInput
    comentarios?: comentarioUpdateManyWithoutParticipacaoTarefaNestedInput
  }

  export type participacaoTarefaUncheckedUpdateWithoutUsuariosInput = {
    participacaoTarefa_id?: IntFieldUpdateOperationsInput | number
    tarefa_id?: IntFieldUpdateOperationsInput | number
    projetoUsuario_id?: IntFieldUpdateOperationsInput | number
    comentarios?: comentarioUncheckedUpdateManyWithoutParticipacaoTarefaNestedInput
  }

  export type participacaoTarefaUncheckedUpdateManyWithoutUsuariosInput = {
    participacaoTarefa_id?: IntFieldUpdateOperationsInput | number
    tarefa_id?: IntFieldUpdateOperationsInput | number
    projetoUsuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type comentarioUpdateWithoutUsuarioInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    participacaoTarefa?: participacaoTarefaUpdateOneRequiredWithoutComentariosNestedInput
    anexos?: anexoComentarioUpdateManyWithoutComentarioNestedInput
  }

  export type comentarioUncheckedUpdateWithoutUsuarioInput = {
    comentario_id?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    participacaoTarefa_id?: IntFieldUpdateOperationsInput | number
    anexos?: anexoComentarioUncheckedUpdateManyWithoutComentarioNestedInput
  }

  export type comentarioUncheckedUpdateManyWithoutUsuarioInput = {
    comentario_id?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    participacaoTarefa_id?: IntFieldUpdateOperationsInput | number
  }

  export type projetoUsuarioCreateManyProjetoInput = {
    projetoUsuario_id?: number
    usuario_id: number
    owner?: boolean
  }

  export type projetoTecnologiaCreateManyProjetoInput = {
    projetoTecnologia_id?: number
    tecnologia_id: number
  }

  export type recursoCreateManyProjetoInput = {
    recurso_id?: number
    descricao: string
  }

  export type anexoProjetoCreateManyProjetoInput = {
    anexo_id?: number
    nome: string
    tipo: string
    conteudo: Buffer
    created_at?: Date | string
  }

  export type permissaoProjetoCreateManyProjetoInput = {
    permissaoProjeto_id?: number
    tipo: string
    usuario_id: number
  }

  export type projetoUsuarioUpdateWithoutProjetoInput = {
    owner?: BoolFieldUpdateOperationsInput | boolean
    usuario?: usuarioUpdateOneRequiredWithoutProjetoUsuariosNestedInput
    participacoes?: participacaoTarefaUpdateManyWithoutProjetoUsuarioNestedInput
  }

  export type projetoUsuarioUncheckedUpdateWithoutProjetoInput = {
    projetoUsuario_id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    owner?: BoolFieldUpdateOperationsInput | boolean
    participacoes?: participacaoTarefaUncheckedUpdateManyWithoutProjetoUsuarioNestedInput
  }

  export type projetoUsuarioUncheckedUpdateManyWithoutProjetoInput = {
    projetoUsuario_id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
    owner?: BoolFieldUpdateOperationsInput | boolean
  }

  export type projetoTecnologiaUpdateWithoutProjetoInput = {
    tecnologia?: tecnologiaUpdateOneRequiredWithoutProjetosNestedInput
  }

  export type projetoTecnologiaUncheckedUpdateWithoutProjetoInput = {
    projetoTecnologia_id?: IntFieldUpdateOperationsInput | number
    tecnologia_id?: IntFieldUpdateOperationsInput | number
  }

  export type projetoTecnologiaUncheckedUpdateManyWithoutProjetoInput = {
    projetoTecnologia_id?: IntFieldUpdateOperationsInput | number
    tecnologia_id?: IntFieldUpdateOperationsInput | number
  }

  export type recursoUpdateWithoutProjetoInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type recursoUncheckedUpdateWithoutProjetoInput = {
    recurso_id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type recursoUncheckedUpdateManyWithoutProjetoInput = {
    recurso_id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type anexoProjetoUpdateWithoutProjetoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    conteudo?: BytesFieldUpdateOperationsInput | Buffer
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type anexoProjetoUncheckedUpdateWithoutProjetoInput = {
    anexo_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    conteudo?: BytesFieldUpdateOperationsInput | Buffer
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type anexoProjetoUncheckedUpdateManyWithoutProjetoInput = {
    anexo_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    conteudo?: BytesFieldUpdateOperationsInput | Buffer
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type permissaoProjetoUpdateWithoutProjetoInput = {
    tipo?: StringFieldUpdateOperationsInput | string
    usuario?: usuarioUpdateOneRequiredWithoutPermissoesProjetoNestedInput
  }

  export type permissaoProjetoUncheckedUpdateWithoutProjetoInput = {
    permissaoProjeto_id?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type permissaoProjetoUncheckedUpdateManyWithoutProjetoInput = {
    permissaoProjeto_id?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type habilidadeUsuarioCreateManyTecnologiaInput = {
    habilidadeUsuario_id?: number
    usuario_id: number
  }

  export type projetoTecnologiaCreateManyTecnologiaInput = {
    projetoTecnologia_id?: number
    projeto_id: number
  }

  export type habilidadeUsuarioUpdateWithoutTecnologiaInput = {
    usuario?: usuarioUpdateOneRequiredWithoutHabilidadesNestedInput
  }

  export type habilidadeUsuarioUncheckedUpdateWithoutTecnologiaInput = {
    habilidadeUsuario_id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type habilidadeUsuarioUncheckedUpdateManyWithoutTecnologiaInput = {
    habilidadeUsuario_id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type projetoTecnologiaUpdateWithoutTecnologiaInput = {
    projeto?: projetoUpdateOneRequiredWithoutTecnologiasNestedInput
  }

  export type projetoTecnologiaUncheckedUpdateWithoutTecnologiaInput = {
    projetoTecnologia_id?: IntFieldUpdateOperationsInput | number
    projeto_id?: IntFieldUpdateOperationsInput | number
  }

  export type projetoTecnologiaUncheckedUpdateManyWithoutTecnologiaInput = {
    projetoTecnologia_id?: IntFieldUpdateOperationsInput | number
    projeto_id?: IntFieldUpdateOperationsInput | number
  }

  export type participacaoTarefaCreateManyTarefaInput = {
    participacaoTarefa_id?: number
    projetoUsuario_id: number
  }

  export type anexoTarefaCreateManyTarefaInput = {
    anexoTarefa_id?: number
    nome: string
    tipo: string
    conteudo: Buffer
    created_at?: Date | string
  }

  export type pausaTarefaCreateManyTarefaInput = {
    pausa_id?: number
    inicioPausa: Date | string
    fimPausa?: Date | string | null
  }

  export type participacaoTarefaUpdateWithoutTarefaInput = {
    projetoUsuario?: projetoUsuarioUpdateOneRequiredWithoutParticipacoesNestedInput
    comentarios?: comentarioUpdateManyWithoutParticipacaoTarefaNestedInput
    usuarios?: usuarioUpdateManyWithoutParticipacoesNestedInput
  }

  export type participacaoTarefaUncheckedUpdateWithoutTarefaInput = {
    participacaoTarefa_id?: IntFieldUpdateOperationsInput | number
    projetoUsuario_id?: IntFieldUpdateOperationsInput | number
    comentarios?: comentarioUncheckedUpdateManyWithoutParticipacaoTarefaNestedInput
    usuarios?: usuarioUncheckedUpdateManyWithoutParticipacoesNestedInput
  }

  export type participacaoTarefaUncheckedUpdateManyWithoutTarefaInput = {
    participacaoTarefa_id?: IntFieldUpdateOperationsInput | number
    projetoUsuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type anexoTarefaUpdateWithoutTarefaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    conteudo?: BytesFieldUpdateOperationsInput | Buffer
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    anexosComentario?: anexoComentarioUpdateManyWithoutAnexoTarefaNestedInput
  }

  export type anexoTarefaUncheckedUpdateWithoutTarefaInput = {
    anexoTarefa_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    conteudo?: BytesFieldUpdateOperationsInput | Buffer
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    anexosComentario?: anexoComentarioUncheckedUpdateManyWithoutAnexoTarefaNestedInput
  }

  export type anexoTarefaUncheckedUpdateManyWithoutTarefaInput = {
    anexoTarefa_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    conteudo?: BytesFieldUpdateOperationsInput | Buffer
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pausaTarefaUpdateWithoutTarefaInput = {
    inicioPausa?: DateTimeFieldUpdateOperationsInput | Date | string
    fimPausa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pausaTarefaUncheckedUpdateWithoutTarefaInput = {
    pausa_id?: IntFieldUpdateOperationsInput | number
    inicioPausa?: DateTimeFieldUpdateOperationsInput | Date | string
    fimPausa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pausaTarefaUncheckedUpdateManyWithoutTarefaInput = {
    pausa_id?: IntFieldUpdateOperationsInput | number
    inicioPausa?: DateTimeFieldUpdateOperationsInput | Date | string
    fimPausa?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type participacaoTarefaCreateManyProjetoUsuarioInput = {
    participacaoTarefa_id?: number
    tarefa_id: number
  }

  export type participacaoTarefaUpdateWithoutProjetoUsuarioInput = {
    tarefa?: tarefaUpdateOneRequiredWithoutParticipacoesNestedInput
    comentarios?: comentarioUpdateManyWithoutParticipacaoTarefaNestedInput
    usuarios?: usuarioUpdateManyWithoutParticipacoesNestedInput
  }

  export type participacaoTarefaUncheckedUpdateWithoutProjetoUsuarioInput = {
    participacaoTarefa_id?: IntFieldUpdateOperationsInput | number
    tarefa_id?: IntFieldUpdateOperationsInput | number
    comentarios?: comentarioUncheckedUpdateManyWithoutParticipacaoTarefaNestedInput
    usuarios?: usuarioUncheckedUpdateManyWithoutParticipacoesNestedInput
  }

  export type participacaoTarefaUncheckedUpdateManyWithoutProjetoUsuarioInput = {
    participacaoTarefa_id?: IntFieldUpdateOperationsInput | number
    tarefa_id?: IntFieldUpdateOperationsInput | number
  }

  export type comentarioCreateManyParticipacaoTarefaInput = {
    comentario_id?: number
    comentario: string
    data_hora?: Date | string
    usuario_id: number
  }

  export type comentarioUpdateWithoutParticipacaoTarefaInput = {
    comentario?: StringFieldUpdateOperationsInput | string
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: usuarioUpdateOneRequiredWithoutComentariosNestedInput
    anexos?: anexoComentarioUpdateManyWithoutComentarioNestedInput
  }

  export type comentarioUncheckedUpdateWithoutParticipacaoTarefaInput = {
    comentario_id?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario_id?: IntFieldUpdateOperationsInput | number
    anexos?: anexoComentarioUncheckedUpdateManyWithoutComentarioNestedInput
  }

  export type comentarioUncheckedUpdateManyWithoutParticipacaoTarefaInput = {
    comentario_id?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    data_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type usuarioUpdateWithoutParticipacoesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    roule?: NullableStringFieldUpdateOperationsInput | string | null
    login?: loginUpdateOneRequiredWithoutUsuarioNestedInput
    projetoUsuarios?: projetoUsuarioUpdateManyWithoutUsuarioNestedInput
    habilidades?: habilidadeUsuarioUpdateManyWithoutUsuarioNestedInput
    permissoes?: permissaoUpdateManyWithoutUsuarioNestedInput
    permissoesProjeto?: permissaoProjetoUpdateManyWithoutUsuarioNestedInput
    comentarios?: comentarioUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutParticipacoesInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    roule?: NullableStringFieldUpdateOperationsInput | string | null
    login_id?: IntFieldUpdateOperationsInput | number
    projetoUsuarios?: projetoUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    habilidades?: habilidadeUsuarioUncheckedUpdateManyWithoutUsuarioNestedInput
    permissoes?: permissaoUncheckedUpdateManyWithoutUsuarioNestedInput
    permissoesProjeto?: permissaoProjetoUncheckedUpdateManyWithoutUsuarioNestedInput
    comentarios?: comentarioUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateManyWithoutParticipacoesInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    roule?: NullableStringFieldUpdateOperationsInput | string | null
    login_id?: IntFieldUpdateOperationsInput | number
  }

  export type anexoComentarioCreateManyComentarioInput = {
    anexoComentario_id?: number
    anexoTarefa_id: number
  }

  export type anexoComentarioUpdateWithoutComentarioInput = {
    anexoTarefa?: anexoTarefaUpdateOneRequiredWithoutAnexosComentarioNestedInput
  }

  export type anexoComentarioUncheckedUpdateWithoutComentarioInput = {
    anexoComentario_id?: IntFieldUpdateOperationsInput | number
    anexoTarefa_id?: IntFieldUpdateOperationsInput | number
  }

  export type anexoComentarioUncheckedUpdateManyWithoutComentarioInput = {
    anexoComentario_id?: IntFieldUpdateOperationsInput | number
    anexoTarefa_id?: IntFieldUpdateOperationsInput | number
  }

  export type anexoComentarioCreateManyAnexoTarefaInput = {
    anexoComentario_id?: number
    comentario_id: number
  }

  export type anexoComentarioUpdateWithoutAnexoTarefaInput = {
    comentario?: comentarioUpdateOneRequiredWithoutAnexosNestedInput
  }

  export type anexoComentarioUncheckedUpdateWithoutAnexoTarefaInput = {
    anexoComentario_id?: IntFieldUpdateOperationsInput | number
    comentario_id?: IntFieldUpdateOperationsInput | number
  }

  export type anexoComentarioUncheckedUpdateManyWithoutAnexoTarefaInput = {
    anexoComentario_id?: IntFieldUpdateOperationsInput | number
    comentario_id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsuarioCountOutputTypeDefaultArgs instead
     */
    export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjetoCountOutputTypeDefaultArgs instead
     */
    export type ProjetoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjetoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TecnologiaCountOutputTypeDefaultArgs instead
     */
    export type TecnologiaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TecnologiaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TarefaCountOutputTypeDefaultArgs instead
     */
    export type TarefaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TarefaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjetoUsuarioCountOutputTypeDefaultArgs instead
     */
    export type ProjetoUsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjetoUsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParticipacaoTarefaCountOutputTypeDefaultArgs instead
     */
    export type ParticipacaoTarefaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParticipacaoTarefaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComentarioCountOutputTypeDefaultArgs instead
     */
    export type ComentarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComentarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnexoTarefaCountOutputTypeDefaultArgs instead
     */
    export type AnexoTarefaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnexoTarefaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use loginDefaultArgs instead
     */
    export type loginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = loginDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usuarioDefaultArgs instead
     */
    export type usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use projetoDefaultArgs instead
     */
    export type projetoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = projetoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tecnologiaDefaultArgs instead
     */
    export type tecnologiaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tecnologiaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tarefaDefaultArgs instead
     */
    export type tarefaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tarefaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use projetoUsuarioDefaultArgs instead
     */
    export type projetoUsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = projetoUsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use projetoTecnologiaDefaultArgs instead
     */
    export type projetoTecnologiaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = projetoTecnologiaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use habilidadeUsuarioDefaultArgs instead
     */
    export type habilidadeUsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = habilidadeUsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use recursoDefaultArgs instead
     */
    export type recursoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = recursoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use anexoProjetoDefaultArgs instead
     */
    export type anexoProjetoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = anexoProjetoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use participacaoTarefaDefaultArgs instead
     */
    export type participacaoTarefaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = participacaoTarefaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use comentarioDefaultArgs instead
     */
    export type comentarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = comentarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use anexoTarefaDefaultArgs instead
     */
    export type anexoTarefaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = anexoTarefaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use anexoComentarioDefaultArgs instead
     */
    export type anexoComentarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = anexoComentarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use permissaoDefaultArgs instead
     */
    export type permissaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = permissaoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use permissaoProjetoDefaultArgs instead
     */
    export type permissaoProjetoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = permissaoProjetoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use pausaTarefaDefaultArgs instead
     */
    export type pausaTarefaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = pausaTarefaDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}